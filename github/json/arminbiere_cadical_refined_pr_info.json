[
  {
    "pr_number": 143,
    "title": "Add dynamic lib",
    "author": "msoos",
    "head_sha": "c24469097b830ddf83e384a9f85ca0ea92db6c65",
    "base_sha": "f13d74439a5b5c963ac5b02d05ce93a8098018b8",
    "head_ref": "add_dynamic_lib",
    "base_ref": "master",
    "merge_commit_sha": "e47e8ef6944fc8b71ed934db7e646a4bee23ec9d",
    "state": "closed",
    "created_at": "2025-09-15T18:17:21Z",
    "updated_at": "2025-09-15T18:19:25Z",
    "merged_at": null,
    "pr_body": null,
    "diff": "\"\"\"diff --git a/.github/workflows/nix.yml b/.github/workflows/nix.yml\nnew file mode 100644\nindex 000000000..18e6b202e\n--- /dev/null\n+++ b/.github/workflows/nix.yml\n@@ -0,0 +1,22 @@\n+name: nix build\n+\n+on:\n+  push:\n+    branches: [ \"*\" ]\n+  pull_request:\n+    branches: [ \"*\" ]\n+\n+jobs:\n+  tests:\n+    runs-on: ubuntu-latest\n+    steps:\n+    - uses: actions/checkout@v4\n+    - uses: cachix/install-nix-action@v25\n+      with:\n+        nix_path: nixpkgs=channel:nixos-unstable\n+    - uses: cachix/cachix-action@v14\n+      with:\n+        name: msoos\n+        # If you chose API tokens for write access OR if you have a private cache\n+        authToken: '${{ secrets.CACHIX_AUTH_TOKEN }}'\n+    - run: nix build\ndiff --git a/.gitignore b/.gitignore\nindex ff29e0d4e..5e23cefc2 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -1,2 +1,5 @@\n build\n makefile\n+/result\n+.cache\n+*.json\ndiff --git a/build_emscripten.sh b/build_emscripten.sh\nnew file mode 100755\nindex 000000000..0907a9c8a\n--- /dev/null\n+++ b/build_emscripten.sh\n@@ -0,0 +1,6 @@\n+#!/bin/bash\n+rm -f build/libcadi*\n+rm -f build/cadical\n+emconfigure ./configure --no-contracts --no-tracing\n+emmake make -j12\n+cp build/libcadical* $EMINSTALL/lib/\ndiff --git a/build_norm.sh b/build_norm.sh\nnew file mode 100755\nindex 000000000..db664bc8a\n--- /dev/null\n+++ b/build_norm.sh\n@@ -0,0 +1,6 @@\n+#!/usr/bin/env bash\n+rm -rf build/libcadical.*\n+rm -f compile_commands.json\n+make clean\n+CXXFLAGS=-fPIC ./configure --no-contracts --no-tracing\n+bear -- make -j12\ndiff --git a/configure b/configure\nindex 76c6753de..f241f823b 100755\n--- a/configure\n+++ b/configure\n@@ -274,6 +274,7 @@ fi\n \n [ x\"$CXX\" = x ] && CXX=g++\n [ x\"$CXXFLAGS\" = x ] || CXXFLAGS=\"$CXXFLAGS \"\n+[ x\"$AR\" = x ] && AR=ar\n \n case x\"$CXX\" in\n   x*g++*|x*clang++*) CXXFLAGS=\"${CXXFLAGS}-Wall -Wextra\";;\n@@ -548,6 +549,7 @@ sed \\\n # This 'makefile' is generated from '../makefile.in'.\" \\\n -e \"s,@CXX@,$CXX,\" \\\n -e \"s#@CXXFLAGS@#$CXXFLAGS#\" \\\n+-e \"s#@AR@#$AR#\" \\\n -e \"s#@LIBS@#$libs#\" \\\n -e \"s#@CONTRIB@#$contrib#\" \\\n -e \"s#@IPASIR@#$ipasir#\" \\\n@@ -601,7 +603,6 @@ then\n fi\n \n msg \"linking '$root/makefile'\"\n-ln -s $root/makefile $src/makefile\n \n #--------------------------------------------------------------------------#\n \ndiff --git a/flake.lock b/flake.lock\nnew file mode 100644\nindex 000000000..39c03c375\n--- /dev/null\n+++ b/flake.lock\n@@ -0,0 +1,27 @@\n+{\n+  \"nodes\": {\n+    \"nixpkgs\": {\n+      \"locked\": {\n+        \"lastModified\": 1750811787,\n+        \"narHash\": \"sha256-rD/978c35JXz6JLAzciTIOCMenPumF6zrQOj4rVZeHE=\",\n+        \"owner\": \"nixos\",\n+        \"repo\": \"nixpkgs\",\n+        \"rev\": \"992f916556fcfaa94451ebc7fc6e396134bbf5b1\",\n+        \"type\": \"github\"\n+      },\n+      \"original\": {\n+        \"owner\": \"nixos\",\n+        \"ref\": \"nixpkgs-unstable\",\n+        \"repo\": \"nixpkgs\",\n+        \"type\": \"github\"\n+      }\n+    },\n+    \"root\": {\n+      \"inputs\": {\n+        \"nixpkgs\": \"nixpkgs\"\n+      }\n+    }\n+  },\n+  \"root\": \"root\",\n+  \"version\": 7\n+}\ndiff --git a/flake.nix b/flake.nix\nnew file mode 100644\nindex 000000000..85ee0cb49\n--- /dev/null\n+++ b/flake.nix\n@@ -0,0 +1,62 @@\n+{\n+  description = \"Simplified Satisfiability Solver\";\n+  inputs = {\n+    nixpkgs.url = \"github:nixos/nixpkgs/nixpkgs-unstable\";\n+  };\n+  outputs =\n+    {\n+      self,\n+      nixpkgs,\n+    }:\n+    let\n+      inherit (nixpkgs) lib;\n+      systems = lib.intersectLists lib.systems.flakeExposed lib.platforms.linux;\n+      forAllSystems = lib.genAttrs systems;\n+      nixpkgsFor = forAllSystems (system: nixpkgs.legacyPackages.${system});\n+      fs = lib.fileset;\n+\n+      cadical-package =\n+        {\n+          stdenv,\n+          fetchFromGitHub,\n+          lsd,\n+        }:\n+        stdenv.mkDerivation {\n+          name = \"cadical\";\n+          src = fs.toSource {\n+            root = ./.;\n+            fileset = fs.unions [\n+              ./configure\n+              ./scripts\n+              ./makefile.in\n+              ./src\n+              ./test\n+              ./VERSION\n+            ];\n+          };\n+          configurePhase = ''./configure --competition'';\n+\n+          installPhase = ''\n+            mkdir -p $out/lib\n+            # once cadiback doesn't need these folders anymore, remove this copy\n+            rm build/makefile\n+            cp -r configure src/ build/ $out\n+            cp build/libcadical.a $out/lib\n+            mkdir -p $out/include\n+            cp src/*.hpp $out/include\n+          '';\n+        };\n+    in\n+    {\n+      packages = forAllSystems (\n+        system:\n+        let\n+          cadical = nixpkgsFor.${system}.callPackage cadical-package { };\n+        in\n+        {\n+          inherit cadical;\n+          default = cadical;\n+        }\n+      );\n+    };\n+}\ndiff --git a/makefile.in b/makefile.in\nindex 5e1c1b3ad..2882458d8 100644\n--- a/makefile.in\n+++ b/makefile.in\n@@ -9,6 +9,7 @@\n \n CXX=@CXX@\n CXXFLAGS=@CXXFLAGS@\n+AR=@AR@\n \n LIBS=@LIBS@\n CONTRIB=@CONTRIB@\n@@ -38,7 +39,7 @@ COMPILE=$(CXX) $(CXXFLAGS) -I$(DIR) -I../src\n \n #--------------------------------------------------------------------------#\n \n-all: libcadical.a cadical mobical\n+all: libcadical.so libcadical.a\n \n #--------------------------------------------------------------------------#\n \n@@ -52,14 +53,11 @@ all: libcadical.a cadical mobical\n # Application binaries (the stand alone solver 'cadical' and the model based\n # tester 'mobical') and the library are the main build targets.\n \n-cadical: cadical.o libcadical.a makefile\n-\t$(COMPILE) -o $@ $< -L. -lcadical $(LIBS)\n-\n-mobical: mobical.o libcadical.a makefile $(LIBS)\n-\t$(COMPILE) -o $@ $< -L. -lcadical\n-\n libcadical.a: $(OBJ_SOLVER) $(OBJ_CONTRIB) makefile\n-\tar rc $@ $(OBJ_SOLVER) $(OBJ_CONTRIB)\n+\t$(AR) rc $@ $(OBJ_SOLVER) $(OBJ_CONTRIB)\n+\n+libcadical.so: $(OBJ_SOLVER) $(OBJ_CONTRIB) $(LIBS) makefile\n+\t$(COMPILE) -shared -o $@ $(OBJ_SOLVER) $(OBJ_CONTRIB) $(LIBS)\n \n #--------------------------------------------------------------------------#\n \ndiff --git a/src/cadical.hpp b/src/cadical.hpp\nindex 49adee9e9..40c8aa157 100644\n--- a/src/cadical.hpp\n+++ b/src/cadical.hpp\n@@ -879,8 +879,10 @@ class Solver {\n   //   ensure (VALID)\n   //\n   bool traverse_clauses (ClauseIterator &) const;\n+  bool traverse_red_clauses (ClauseIterator &) const;\n   bool traverse_witnesses_backward (WitnessIterator &) const;\n   bool traverse_witnesses_forward (WitnessIterator &) const;\n+  const std::vector<std::pair<int,int>>& get_eqiv_lits () const;\n \n   //------------------------------------------------------------------------\n   // Files with explicit path argument support compressed input and output\ndiff --git a/src/configure b/src/configure\ndeleted file mode 120000\nindex c9d4efb4f..000000000\n--- a/src/configure\n+++ /dev/null\n@@ -1 +0,0 @@\n-../configure\n\\ No newline at end of file\ndiff --git a/src/decompose.cpp b/src/decompose.cpp\nindex 06d2eedee..af9f510b6 100644\n--- a/src/decompose.cpp\n+++ b/src/decompose.cpp\n@@ -461,6 +461,7 @@ bool Internal::decompose_round () {\n       proof->weaken_minus (id1, clause);\n     }\n     external->push_binary_clause_on_extension_stack (id1, -idx, other);\n+    external->eqLits.push_back(std::make_pair(internal->externalize(idx), internal->externalize(other)));\n \n     decompose_ids[vlit (-idx)] = id1;\n \ndiff --git a/src/external.hpp b/src/external.hpp\nindex 22969427e..e3c5b8c71 100644\n--- a/src/external.hpp\n+++ b/src/external.hpp\n@@ -59,6 +59,7 @@ struct External {\n   int max_var;  // External maximum variable index.\n   size_t vsize; // Allocated external size.\n \n+  vector<std::pair<int, int>> eqLits;\n   vector<bool> vals; // Current external (extended) assignment.\n   vector<int> e2i;   // External 'idx' to internal 'lit'.\n \ndiff --git a/src/internal.cpp b/src/internal.cpp\nindex 3c0612d0e..c358256ef 100644\n--- a/src/internal.cpp\n+++ b/src/internal.cpp\n@@ -1128,4 +1128,32 @@ bool Internal::traverse_clauses (ClauseIterator &it) {\n   return true;\n }\n \n+bool Internal::traverse_red_clauses (ClauseIterator &it) {\n+  vector<int> eclause;\n+  if (unsat)\n+    return it.clause (eclause);\n+  for (const auto &c : clauses) {\n+    if (c->garbage)\n+      continue;\n+    if (!c->redundant)\n+      continue;\n+    bool satisfied = false;\n+    for (const auto &ilit : *c) {\n+      const int tmp = fixed (ilit);\n+      if (tmp > 0) {\n+        satisfied = true;\n+        break;\n+      }\n+      if (tmp < 0)\n+        continue;\n+      const int elit = externalize (ilit);\n+      eclause.push_back (elit);\n+    }\n+    if (!satisfied && !it.clause (eclause))\n+      return false;\n+    eclause.clear ();\n+  }\n+  return true;\n+}\n+\n } // namespace CaDiCaL\ndiff --git a/src/internal.hpp b/src/internal.hpp\nindex 0a5314ec3..bc2a99a90 100644\n--- a/src/internal.hpp\n+++ b/src/internal.hpp\n@@ -1388,6 +1388,7 @@ struct Internal {\n   // Export and traverse all irredundant (non-unit) clauses.\n   //\n   bool traverse_clauses (ClauseIterator &);\n+  bool traverse_red_clauses (ClauseIterator &);\n \n   // Export and traverse all irredundant (non-unit) clauses.\n   //\ndiff --git a/src/solver.cpp b/src/solver.cpp\nindex 9c002f3a4..2f1c81dbd 100644\n--- a/src/solver.cpp\n+++ b/src/solver.cpp\n@@ -1489,6 +1489,14 @@ bool Solver::traverse_clauses (ClauseIterator &it) const {\n   return res;\n }\n \n+bool Solver::traverse_red_clauses (ClauseIterator &it) const {\n+  LOG_API_CALL_BEGIN (\"traverse_red_clauses\");\n+  REQUIRE_VALID_STATE ();\n+  bool res = internal->traverse_red_clauses (it);\n+  LOG_API_CALL_RETURNS (\"traverse_red_clauses\", res);\n+  return res;\n+}\n+\n bool Solver::traverse_witnesses_backward (WitnessIterator &it) const {\n   LOG_API_CALL_BEGIN (\"traverse_witnesses_backward\");\n   REQUIRE_VALID_STATE ();\n@@ -1507,6 +1515,13 @@ bool Solver::traverse_witnesses_forward (WitnessIterator &it) const {\n   return res;\n }\n \n+const std::vector<std::pair<int,int>>& Solver::get_eqiv_lits () const {\n+  LOG_API_CALL_BEGIN (\"get_eqiv_lits\");\n+  REQUIRE_VALID_STATE ();\n+  LOG_API_CALL_RETURNS (\"get_eqiv_lits\", res);\n+  return external->eqLits;\n+}\n+\n /*------------------------------------------------------------------------*/\n \n class ClauseCounter : public ClauseIterator {\n\"\"\""
  },
  {
    "pr_number": 141,
    "title": "Shared library option",
    "author": "samysweb",
    "head_sha": "bb3b394f06d4c5a3fc2561eb24a630799477ef27",
    "base_sha": "f13d74439a5b5c963ac5b02d05ce93a8098018b8",
    "head_ref": "feat/configurable-so",
    "base_ref": "master",
    "merge_commit_sha": "03327b6ebac2b1e932ac395bc23e4fa650ad3733",
    "state": "closed",
    "created_at": "2025-09-09T09:49:31Z",
    "updated_at": "2025-09-15T19:04:02Z",
    "merged_at": null,
    "pr_body": "I am currently working on an integration of CaDiCaL and its IPASIR-UP interface for Julia. To this end, I need CaDiCaL as a shared library. I have seen in #40 and #100 that there is, in principle, interest in adding this feature.\r\n\r\nBased on the comments from these two pages, I have reconstructed the `--shared` functionality from Kissat for CaDiCaL in this pull request. Is this the change you had in mind for this feature?\r\n\r\nTo summarize:\r\n- By default only the static library is built\r\n- The `-shared` option activates `-fpic` and builds the shared library in addition to the static library\r\n\r\nSince this code was essentially taken from Kissat's build files, I have not yet signed the commit.\r\nIf you agree with this, I'm happy to sign it to have the pull request merged...",
    "diff": "\"\"\"diff --git a/configure b/configure\nindex 76c6753de..810762eaa 100755\n--- a/configure\n+++ b/configure\n@@ -34,6 +34,8 @@ quiet=no\n m32=no\n contrib=yes\n ipasir=yes\n+shared=no\n+pic=no\n \n #--------------------------------------------------------------------------#\n \n@@ -114,6 +116,7 @@ where '<option>' is one of the following\n -ggdb3             pass '-ggdb3' to makefile (like '-s')\n -O|-O[123]         pass '-O' or '-O[123]' to the makefile\n -static...         pass '-static...' option to makefile\n+-shared            add '-fpic' compilation flag and produce shared library\n \n The environment variable CXX can be used to set a different C++\n compiler than the default 'g++'.  Similarly you can add additional\n@@ -176,9 +179,11 @@ do\n     --no-unlocked) unlocked=no;;\n \n     -m32) options=\"$options $1\";m32=yes;;\n+    -fpic|-fPIC) options=\"$options $1\"; pic=yes;;\n     -f*|-W*|-ggdb3|-O|-O1|-O2|-O3) options=\"$options $1\";;\n     -s|--symbols) options=\"$options -ggdb3\";;\n     -static*) options=\"$options $1\";;\n+    -shared|--shared) shared=yes;;\n \n     CXX=*)\n       CXX=\"`expr \\\"$1\\\" : 'CXX=\\(.*\\)'`\"\n@@ -326,6 +331,7 @@ fi\n [ $tracing = no ] && CXXFLAGS=\"$CXXFLAGS -DNTRACING\"\n [ $contrib = no ] && CXXFLAGS=\"$CXXFLAGS -DNCONTRIB\"\n [ $ipasir = no ] && CXXFLAGS=\"$CXXFLAGS -DNIPASIR\"\n+[ $shared = yes -a $pic = no ] && CXXFLAGS=\"$CXXFLAGS -fpic\"\n \n CXXFLAGS=\"$CXXFLAGS$options\"\n \n@@ -536,6 +542,24 @@ fi\n \n [ $closefrom = no ] && CXXFLAGS=\"$CXXFLAGS -DNCLOSEFROM\"\n \n+#--------------------------------------------------------------------------#\n+# Preparing make goals (@GOALS@)\n+goals=\"libcadical.a cadical mobical\"\n+sharedlibrary=\"libcadical.so\"\n+if [ $shared = yes ]\n+then\n+  msg \"adding '$sharedlibrary' shared library to default makefile goal, too\"\n+  goals=\"$goals $sharedlibrary\"\n+else\n+  if [ -f $sharedlibrary ]\n+  then\n+    msg \"removing stale dynamic library '$sharedlibrary' (without '-shared')\"\n+    rm -f $sharedlibrary || exit 1\n+  fi\n+  msg \"no '$sharedlibrary' shared library generated (without '-shared')\"\n+fi\n+\n+\n #--------------------------------------------------------------------------#\n \n # Instantiate '../makefile.in' template to produce 'makefile' in 'build'.\n@@ -552,6 +576,7 @@ sed \\\n -e \"s#@CONTRIB@#$contrib#\" \\\n -e \"s#@IPASIR@#$ipasir#\" \\\n -e \"s#@ROOT@#$root#\" \\\n+-e \"s#@GOALS@#$goals#\" \\\n ../makefile.in > makefile\n \n msg \"generated '$build/makefile' from '../makefile.in'\"\ndiff --git a/makefile.in b/makefile.in\nindex 5e1c1b3ad..195603b52 100644\n--- a/makefile.in\n+++ b/makefile.in\n@@ -38,7 +38,7 @@ COMPILE=$(CXX) $(CXXFLAGS) -I$(DIR) -I../src\n \n #--------------------------------------------------------------------------#\n \n-all: libcadical.a cadical mobical\n+all: @GOALS@\n \n #--------------------------------------------------------------------------#\n \n@@ -53,14 +53,17 @@ all: libcadical.a cadical mobical\n # tester 'mobical') and the library are the main build targets.\n \n cadical: cadical.o libcadical.a makefile\n-\t$(COMPILE) -o $@ $< -L. -lcadical $(LIBS)\n+\t$(COMPILE) -o $@ $< -L. libcadical.a $(LIBS)\n \n mobical: mobical.o libcadical.a makefile $(LIBS)\n-\t$(COMPILE) -o $@ $< -L. -lcadical\n+\t$(COMPILE) -o $@ $< -L. libcadical.a\n \n libcadical.a: $(OBJ_SOLVER) $(OBJ_CONTRIB) makefile\n \tar rc $@ $(OBJ_SOLVER) $(OBJ_CONTRIB)\n \n+libcadical.so: $(OBJ_SOLVER) $(OBJ_CONTRIB) $(LIBS) makefile\n+\t$(COMPILE) -shared -o $@ $(OBJ_SOLVER) $(OBJ_CONTRIB) $(LIBS)\n+\n #--------------------------------------------------------------------------#\n \n # Note that 'build.hpp' is generated and resides in the build directory.\ndiff --git a/scripts/build-and-test-all-configurations.sh b/scripts/build-and-test-all-configurations.sh\nindex e58e31392..2e01b4922 100755\n--- a/scripts/build-and-test-all-configurations.sh\n+++ b/scripts/build-and-test-all-configurations.sh\n@@ -112,4 +112,9 @@ run --no-tracing -a -p\n run -m32 -q\n run -m32 -a -p\n \n+# Shared library builds\n+\n+run -shared\n+run -shared -p\n+\n echo \"successfully compiled and tested ${GOOD}${ok}${NORMAL} configurations\"\ndiff --git a/test/api/run.sh b/test/api/run.sh\nindex 954b0a02a..4f83e383f 100755\n--- a/test/api/run.sh\n+++ b/test/api/run.sh\n@@ -87,7 +87,7 @@ run () {\n   rm -f $name.log $name.o $name\n   status=0\n   cmd $COMPILE$language -o $name.o -c $src\n-  cmd $COMPILE -o $name $name.o -L$CADICALBUILD -lcadical\n+  cmd $COMPILE -o $name $name.o -L$CADICALBUILD $CADICALBUILD/libcadical.a\n   cmd $name\n   if test $status = 0\n   then\ndiff --git a/test/contrib/run.sh b/test/contrib/run.sh\nindex 386924e32..c83b5b9e7 100755\n--- a/test/contrib/run.sh\n+++ b/test/contrib/run.sh\n@@ -88,7 +88,7 @@ run () {\n   rm -f $name.log $name.o $name\n   status=0\n   cmd $COMPILE$language -I$source -I$contrib -o $name.o -c $src\n-  cmd $COMPILE -o $name $name.o -L$CADICALBUILD -lcadical\n+  cmd $COMPILE -o $name $name.o -L$CADICALBUILD $CADICALBUILD/libcadical.a\n   cmd $name\n   if test $status = 0\n   then\n\"\"\""
  },
  {
    "pr_number": 138,
    "title": "Add getting equivalent literals",
    "author": "msoos",
    "head_sha": "b7647d7fde46c690de54931fe5422ceced14bab2",
    "base_sha": "f13d74439a5b5c963ac5b02d05ce93a8098018b8",
    "head_ref": "add_getting_equiv_lits",
    "base_ref": "master",
    "merge_commit_sha": "417d4a44671ffe1f42687a7cc901b03f98127d4a",
    "state": "open",
    "created_at": "2025-07-24T12:58:12Z",
    "updated_at": "2025-07-24T12:58:12Z",
    "merged_at": null,
    "pr_body": "This quick hack allows one to get equivalent literals from the outside. It gathers all equivalences during decompose(), so there is some memory overhead. However, it should be small. The memory is packed (with std::pair and std::vector), so it's not too bad.\r\n\r\nQuite useful -- sometimes after a CaDiCaL call, it can be useful to extract units, and equivalences. I use this in my version of CadiBack, for model counting. It actually helps. File `mc2024_track2-random_186.cnf.gz` when preprocessed with equivalences obtained from CadiBack:\r\n\r\n```\r\nc o --- [ backbone statistics ] ------------------------------------------------\r\nc o\r\nc o found              9009 backbones      16%\r\nc o dropped           45860 candidates     84%\r\nc o\r\nc o filtered          45158 candidates     82%\r\nc o flippable             7 candidates      0%\r\nc o flipped               0 candidates      0%\r\nc o fixed              8789 candidates     16%\r\nc o core                  0 candidates      0%\r\nc o found                 0 big_backbone   0%\r\nc o failed                0 candidates      0%\r\nc o\r\nc o called solver       869 times           2%\r\nc o satisfiable         696 times          80%\r\nc o unsatisfiable       173 times          20%\r\nc o\r\nc o --- [ backbone profiling ] -------------------------------------------------\r\nc o\r\nc o         1.90   1.24 % first\r\nc o         5.73   3.75 % sat\r\nc o         2.73   1.78 % unsat\r\nc o         1.90   1.24 % satmax\r\nc o         1.49   0.98 % unsatmax\r\nc o         8.46   5.53 % solving\r\nc o         0.68   0.45 % flip\r\nc o ====================================\r\nc o         9.48 100.00 % total\r\nc o\r\nc o\r\nc o\r\nc o exit 10\r\nc o [backbone-simpl] res: 10 num units added: 6500 num eq added: 180 num bins: 389 T: 14.08\r\n```\r\n\r\nNotice the 180 equivalent literals received.\r\n\r\nThe difference in the preprocessed CNF:\r\n```\r\n 804   \u2502 c o ind size: 208 nvars: 815\r\n...\r\n 807   \u2502 c o Sampling set size: 208\r\n 808   \u2502 c o Opt sampling set size: 815\r\n 809   \u2502 c o Bin irred/red      988        3698\r\n 810   \u2502 c o Long irred cls/tri 1391       1067\r\n 811   \u2502 c o Long red cls/tri   9154       3578\r\n```\r\n\r\nvs:\r\n\r\n```\r\n 801   \u2502 c o ind size: 208 nvars: 842\r\n...\r\n 804   \u2502 c o Sampling set size: 208\r\n 805   \u2502 c o Opt sampling set size: 842\r\n 806   \u2502 c o Bin irred/red      1050       4015\r\n 807   \u2502 c o Long irred cls/tri 1407       1077\r\n 808   \u2502 c o Long red cls/tri   10108      3552\r\n```",
    "diff": "\"\"\"diff --git a/src/cadical.hpp b/src/cadical.hpp\nindex 49adee9e9..17df4a952 100644\n--- a/src/cadical.hpp\n+++ b/src/cadical.hpp\n@@ -882,6 +882,12 @@ class Solver {\n   bool traverse_witnesses_backward (WitnessIterator &) const;\n   bool traverse_witnesses_forward (WitnessIterator &) const;\n \n+  //------------------------------------------------------------------------\n+  // Allows to obtain equivalent literals, where the pair (a,b) means that\n+  // a == b. It is possible that (a == a) is returned.\n+\n+  const std::vector<std::pair<int,int>>& get_eqiv_lits () const;\n+\n   //------------------------------------------------------------------------\n   // Files with explicit path argument support compressed input and output\n   // if appropriate helper functions 'gzip' etc. are available.  They are\ndiff --git a/src/decompose.cpp b/src/decompose.cpp\nindex 06d2eedee..20c7c3b3c 100644\n--- a/src/decompose.cpp\n+++ b/src/decompose.cpp\n@@ -461,6 +461,9 @@ bool Internal::decompose_round () {\n       proof->weaken_minus (id1, clause);\n     }\n     external->push_binary_clause_on_extension_stack (id1, -idx, other);\n+    external->eq_lits.push_back(std::make_pair(\n+      internal->externalize(idx),\n+      internal->externalize(other)));\n \n     decompose_ids[vlit (-idx)] = id1;\n \ndiff --git a/src/external.hpp b/src/external.hpp\nindex 22969427e..22abeed6a 100644\n--- a/src/external.hpp\n+++ b/src/external.hpp\n@@ -59,6 +59,7 @@ struct External {\n   int max_var;  // External maximum variable index.\n   size_t vsize; // Allocated external size.\n \n+  vector<std::pair<int, int>> eq_lits; // Stores equivalent literals\n   vector<bool> vals; // Current external (extended) assignment.\n   vector<int> e2i;   // External 'idx' to internal 'lit'.\n \ndiff --git a/src/solver.cpp b/src/solver.cpp\nindex 9c002f3a4..9beb1b4ae 100644\n--- a/src/solver.cpp\n+++ b/src/solver.cpp\n@@ -1507,6 +1507,13 @@ bool Solver::traverse_witnesses_forward (WitnessIterator &it) const {\n   return res;\n }\n \n+const std::vector<std::pair<int,int>>& Solver::get_eqiv_lits () const {\n+  LOG_API_CALL_BEGIN (\"get_eqiv_lits\");\n+  REQUIRE_VALID_STATE ();\n+  LOG_API_CALL_RETURNS (\"get_eqiv_lits\", res);\n+  return external->eq_lits;\n+}\n+\n /*------------------------------------------------------------------------*/\n \n class ClauseCounter : public ClauseIterator {\n\"\"\""
  },
  {
    "pr_number": 136,
    "title": "fix: remove incorrect forward-declarations",
    "author": "eric-wieser",
    "head_sha": "33f84fac55fc44d9f46815358897fe78c14c71b4",
    "base_sha": "806ac1da034cdb82d3d713d51488b31b8fb3e40a",
    "head_ref": "forward-declarations",
    "base_ref": "development",
    "merge_commit_sha": null,
    "state": "closed",
    "created_at": "2025-07-11T13:18:32Z",
    "updated_at": "2025-09-15T19:20:45Z",
    "merged_at": null,
    "pr_body": "This code was trying to forward-declare `CaDiCaL::FileTracer`, but was actually forward-declaring `::FileTracer`. Forward-declarations are nonsensical here anyway, as it is not legal to use forward-declarations as a base class.\r\n\r\nInstead, this includes the header that defines the class, which is consistent with what `src/drattracer.hpp` already does.",
    "diff": "\"\"\"diff --git a/src/frattracer.hpp b/src/frattracer.hpp\nindex f9a1cccf3..f719351bb 100644\n--- a/src/frattracer.hpp\n+++ b/src/frattracer.hpp\n@@ -1,6 +1,8 @@\n #ifndef _frattracer_h_INCLUDED\n #define _frattracer_h_INCLUDED\n \n+#include \"tracer.hpp\"\n+\n namespace CaDiCaL {\n \n class FratTracer : public FileTracer {\ndiff --git a/src/idruptracer.hpp b/src/idruptracer.hpp\nindex 0b43e7a9c..6c15cf6df 100644\n--- a/src/idruptracer.hpp\n+++ b/src/idruptracer.hpp\n@@ -1,7 +1,7 @@\n #ifndef _idruptracer_h_INCLUDED\n #define _idruptracer_h_INCLUDED\n \n-class FileTracer;\n+#include \"tracer.hpp\"\n \n namespace CaDiCaL {\n \ndiff --git a/src/lidruptracer.hpp b/src/lidruptracer.hpp\nindex 196e74670..74825d553 100644\n--- a/src/lidruptracer.hpp\n+++ b/src/lidruptracer.hpp\n@@ -1,7 +1,7 @@\n #ifndef _lidruptracer_h_INCLUDED\n #define _lidruptracer_h_INCLUDED\n \n-class FileTracer;\n+#include \"tracer.hpp\"\n \n namespace CaDiCaL {\n \ndiff --git a/src/lrattracer.hpp b/src/lrattracer.hpp\nindex 208cf81e2..40758ff43 100644\n--- a/src/lrattracer.hpp\n+++ b/src/lrattracer.hpp\n@@ -1,6 +1,8 @@\n #ifndef _lrattracer_h_INCLUDED\n #define _lrattracer_h_INCLUDED\n \n+#include \"tracer.hpp\"\n+\n namespace CaDiCaL {\n \n class LratTracer : public FileTracer {\ndiff --git a/src/veripbtracer.hpp b/src/veripbtracer.hpp\nindex d8e3dafdf..58ba99cf3 100644\n--- a/src/veripbtracer.hpp\n+++ b/src/veripbtracer.hpp\n@@ -1,7 +1,7 @@\n #ifndef _veripbtracer_h_INCLUDED\n #define _veripbtracer_h_INCLUDED\n \n-class FileTracer;\n+#include \"tracer.hpp\"\n \n namespace CaDiCaL {\n \n\"\"\""
  },
  {
    "pr_number": 135,
    "title": "Fixes for __WIN32 build:",
    "author": "mmaroti",
    "head_sha": "0903b456b364bb1b41b117cb72cdfa3b4245b1a0",
    "base_sha": "f13d74439a5b5c963ac5b02d05ce93a8098018b8",
    "head_ref": "master",
    "base_ref": "master",
    "merge_commit_sha": "8552446309aa66c0c854ca013a473070c0d3bcc9",
    "state": "closed",
    "created_at": "2025-04-24T16:21:05Z",
    "updated_at": "2025-09-15T19:16:43Z",
    "merged_at": null,
    "pr_body": "* __WIN32 is replaced with _WIN32 (both were used inconsistently)\r\n* CADICAL_ATTRIBUTE_FORMAT is disabled\r\n* __builtin_clz is replaced with _BitScanReverse\r\n* getpid is replaced with GetCurrentProcessId\r\n* __PRETTY_FUNCTION__ is replaced with __FUNCTION__\r\n* __builtin_prefetch is replaced with _m_prefetch\r\n* unistd.h is always guarded with #ifdef\r\n* io operations (isatty, etc) are defined with macros",
    "diff": "\"\"\"diff --git a/src/cadical.cpp b/src/cadical.cpp\nindex a06ded3fb..2dfab6ab7 100644\n--- a/src/cadical.cpp\n+++ b/src/cadical.cpp\n@@ -25,7 +25,7 @@ class App : public Handler, public Terminator {\n \n   Solver *solver; // Global solver.\n \n-#ifndef __WIN32\n+#ifndef _WIN32\n   // Command line options.\n   //\n   int time_limit; // '-t <sec>'\n@@ -109,7 +109,7 @@ void App::print_usage (bool all) {\n             \"  -q             be quiet\\n\"\n #endif\n             \"\\n\"\n-#ifndef __WIN32\n+#ifndef _WIN32\n             \"  -t <sec>       set wall clock time limit\\n\"\n #endif\n     );\n@@ -125,7 +125,7 @@ void App::print_usage (bool all) {\n         \"  -v             increase verbosity (see also '--verbose' below)\\n\"\n         \"  -q             be quiet (same as '--quiet')\\n\"\n #endif\n-#ifndef __WIN32\n+#ifndef _WIN32\n         \"  -t <sec>       set wall clock time limit\\n\"\n #endif\n         \"\\n\"\n@@ -226,7 +226,7 @@ void App::print_usage (bool all) {\n         \"stops at the first satisfied cube if there is one and uses that\\n\"\n         \"one for the witness to print.  Conflict and decision limits are\\n\"\n         \"applied to each individual cube solving call while '-P', '-L'\"\n-#ifdef __WIN32\n+#ifdef _WIN32\n         \"\\n\"\n #else\n         \" and\\n\"\n@@ -491,7 +491,7 @@ int App::main (int argc, char **argv) {\n       else\n         decision_limit_specified = argv[i];\n     }\n-#ifndef __WIN32\n+#ifndef _WIN32\n     else if (!strcmp (argv[i], \"-t\")) {\n       if (++i == argc)\n         APPERR (\"argument to '-t' missing\");\n@@ -624,7 +624,7 @@ int App::main (int argc, char **argv) {\n   }\n #endif\n   if (preprocessing > 0 || localsearch > 0 ||\n-#ifndef __WIN32\n+#ifndef _WIN32\n       time_limit >= 0 ||\n #endif\n       conflict_limit >= 0 || decision_limit >= 0) {\n@@ -641,7 +641,7 @@ int App::main (int argc, char **argv) {\n           localsearch, localsearch_specified);\n       solver->limit (\"localsearch\", localsearch);\n     }\n-#ifndef __WIN32\n+#ifndef _WIN32\n     if (time_limit >= 0) {\n       solver->message (\n           \"setting time limit to %d seconds real time (due to '-t %s')\",\n@@ -909,7 +909,7 @@ int App::main (int argc, char **argv) {\n     close (1);\n     pclose (less_pipe);\n   }\n-#ifndef __WIN32\n+#ifndef _WIN32\n   if (time_limit > 0)\n     alarm (0);\n #endif\n@@ -925,7 +925,7 @@ void App::init () {\n \n   assert (!solver);\n \n-#ifndef __WIN32\n+#ifndef _WIN32\n   time_limit = -1;\n #endif\n   force_strict_parsing = 1;\ndiff --git a/src/cadical.hpp b/src/cadical.hpp\nindex 49adee9e9..c02ca40ff 100644\n--- a/src/cadical.hpp\n+++ b/src/cadical.hpp\n@@ -1054,10 +1054,14 @@ class Solver {\n   //\n   // TODO: support for other compilers (beside 'gcc' and 'clang').\n \n+#ifndef _WIN32\n #define CADICAL_ATTRIBUTE_FORMAT(FORMAT_POSITION, \\\n                                  VARIADIC_ARGUMENT_POSITION) \\\n   __attribute__ ((format (PRINTF_FORMAT, FORMAT_POSITION, \\\n                           VARIADIC_ARGUMENT_POSITION)))\n+#else\n+#define CADICAL_ATTRIBUTE_FORMAT(X,Y) /**/\n+#endif\n \n   // Messages in a common style.\n   //\ndiff --git a/src/file.cpp b/src/file.cpp\nindex 7f8a82dea..4e9ecb67c 100644\n--- a/src/file.cpp\n+++ b/src/file.cpp\n@@ -11,12 +11,12 @@ extern \"C\" {\n #include <string.h>\n #include <sys/stat.h>\n #include <sys/types.h>\n-#include <unistd.h>\n }\n \n #ifndef _WIN32\n \n extern \"C\" {\n+#include <unistd.h>\n #include <sys/wait.h>\n }\n \ndiff --git a/src/file.hpp b/src/file.hpp\nindex a42b31bbb..488210d78 100644\n--- a/src/file.hpp\n+++ b/src/file.hpp\n@@ -57,7 +57,7 @@ class File {\n                           const char *mode);\n   static FILE *read_pipe (Internal *, const char *fmt, const int *sig,\n                           const char *path);\n-#ifndef __WIN32\n+#ifndef _WIN32\n   static FILE *write_pipe (Internal *, const char *fmt, const char *path,\n                            int &child_pid);\n #endif\ndiff --git a/src/internal.hpp b/src/internal.hpp\nindex 0a5314ec3..5fe9e3552 100644\n--- a/src/internal.hpp\n+++ b/src/internal.hpp\n@@ -22,10 +22,32 @@\n \n // Less common 'C' header.\n \n+#ifndef _WIN32\n+\n extern \"C\" {\n #include <unistd.h>\n }\n \n+#else\n+\n+#include <io.h>\n+#include <intrin.h>\n+\n+#define pclose _pclose\n+#define popen _popen\n+#define access _access\n+#define isatty _isatty\n+\n+#define R_OK 4\n+#define W_OK 2\n+#define S_ISDIR(mode)  (((mode) & S_IFMT) == S_IFDIR)\n+#define S_ISFIFO(mode)\t(((mode) & _S_IFMT) == _S_IFIFO)\n+\n+#define __PRETTY_FUNCTION__ __FUNCTION__\n+#define  __builtin_prefetch(A,B,C) _m_prefetch((void*)(A))\n+\n+#endif\n+\n /*------------------------------------------------------------------------*/\n \n // Common 'C++' headers.\ndiff --git a/src/mobical.cpp b/src/mobical.cpp\nindex 1d517bd2c..29e97c0fd 100644\n--- a/src/mobical.cpp\n+++ b/src/mobical.cpp\n@@ -154,7 +154,6 @@ extern \"C\" {\n #include <dlfcn.h>\n #include <execinfo.h>\n #endif\n-#include <unistd.h>\n }\n \n #ifdef MOBICAL_MEMORY\n@@ -1212,9 +1211,9 @@ struct Call {\n     REDUNDANT       = shift (  5 ),\n     IRREDUNDANT     = shift (  6 ),\n     RESERVE         = shift (  7 ),\n-                              \n+\n     PHASE           = shift (  8 ),\n-                              \n+\n     ADD             = shift (  9 ),\n     ASSUME          = shift ( 10 ),\n \ndiff --git a/src/random.cpp b/src/random.cpp\nindex b5f02e71e..1a97d4095 100644\n--- a/src/random.cpp\n+++ b/src/random.cpp\n@@ -78,7 +78,7 @@ static uint64_t hash_machine_identifier () {\n // work.  As an additional measure to increase the possibility to get\n // different seeds we are now also using network addresses (explicitly).\n \n-#ifndef __WIN32\n+#ifndef _WIN32\n \n extern \"C\" {\n #include <ifaddrs.h>\n@@ -102,7 +102,7 @@ static uint64_t hash_network_addresses () {\n   // you really need to run 'mobical' on a Windows cluster where each node\n   // has identical IP addresses.\n \n-#ifndef __WIN32\n+#ifndef _WIN32\n   struct ifaddrs *addrs;\n   if (!getifaddrs (&addrs)) {\n     for (struct ifaddrs *addr = addrs; addr; addr = addr->ifa_next) {\n@@ -157,15 +157,23 @@ static uint64_t hash_time () {\n \n // Hash the process identified.\n \n+#ifndef _WIN32\n extern \"C\" {\n #include <sys/types.h>\n #include <unistd.h>\n }\n+#else\n+#include <windows.h>\n+#endif\n \n namespace CaDiCaL {\n \n static uint64_t hash_process () {\n+#ifndef _WIN32\n   uint64_t res = getpid ();\n+#else\n+  uint64_t res = GetCurrentProcessId();\n+#endif\n   PRINT_HASH (res);\n   return res;\n }\ndiff --git a/src/reap.cpp b/src/reap.cpp\nindex 8c383cb66..d44676c11 100644\n--- a/src/reap.cpp\n+++ b/src/reap.cpp\n@@ -26,9 +26,17 @@ Reap::Reap () {\n   max_bucket = 0;\n }\n \n+#ifndef _WIN32\n static inline unsigned leading_zeroes_of_unsigned (unsigned x) {\n   return x ? __builtin_clz (x) : sizeof (unsigned) * 8;\n }\n+#else\n+#include <intrin.h>\n+static inline unsigned leading_zeroes_of_unsigned (unsigned x) {\n+  unsigned long i;\n+  return _BitScanReverse(&i, x) ? sizeof (unsigned) * 8 - 1 - i : sizeof (unsigned) * 8;\n+}\n+#endif\n \n void Reap::push (unsigned e) {\n   assert (last_deleted <= e);\ndiff --git a/src/resources.cpp b/src/resources.cpp\nindex 712a8ec67..4a057ca6a 100644\n--- a/src/resources.cpp\n+++ b/src/resources.cpp\n@@ -9,10 +9,10 @@\n \n extern \"C\" {\n \n-#ifdef __WIN32\n+#ifdef _WIN32\n \n-#ifndef __WIN32_WINNT\n-#define __WIN32_WINNT 0x0600\n+#ifndef _WIN32_WINNT\n+#define _WIN32_WINNT 0x0600\n #endif\n \n // Clang-format would reorder the includes which breaks the Windows code\n@@ -41,7 +41,7 @@ namespace CaDiCaL {\n \n /*------------------------------------------------------------------------*/\n \n-#ifdef __WIN32\n+#ifdef _WIN32\n \n double absolute_real_time () {\n   FILETIME f;\n@@ -104,8 +104,9 @@ double Internal::process_time () const {\n \n /*------------------------------------------------------------------------*/\n \n-#ifdef __WIN32\n+#ifdef _WIN32\n \n+#if 0\n uint64_t current_resident_set_size () {\n   PROCESS_MEMORY_COUNTERS pmc;\n   if (GetProcessMemoryInfo (GetCurrentProcess (), &pmc, sizeof (pmc))) {\n@@ -121,6 +122,15 @@ uint64_t maximum_resident_set_size () {\n   } else\n     return 0;\n }\n+#else\n+uint64_t current_resident_set_size () {\n+  return 0;\n+}\n+\n+uint64_t maximum_resident_set_size () {\n+  return 0;\n+}\n+#endif\n \n #else\n \ndiff --git a/src/signal.cpp b/src/signal.cpp\nindex 384ba986f..a80ea0744 100644\n--- a/src/signal.cpp\n+++ b/src/signal.cpp\n@@ -9,9 +9,11 @@\n \n /*------------------------------------------------------------------------*/\n \n+#ifndef _WIN32\n extern \"C\" {\n-#include <unistd.h>\n+  #include <unistd.h>\n }\n+#endif\n \n /*------------------------------------------------------------------------*/\n \n@@ -22,7 +24,7 @@ namespace CaDiCaL {\n static volatile bool caught_signal = false;\n static Handler *signal_handler;\n \n-#ifndef __WIN32\n+#ifndef _WIN32\n \n static volatile bool caught_alarm = false;\n static volatile bool alarm_set = false;\n@@ -42,7 +44,7 @@ void Handler::catch_alarm () { catch_signal (SIGALRM); }\n SIGNALS\n #undef SIGNAL\n \n-#ifndef __WIN32\n+#ifndef _WIN32\n \n static void (*SIGALRM_handler) (int);\n \n@@ -65,7 +67,7 @@ void Signal::reset () {\n   SIG##_handler = 0;\n   SIGNALS\n #undef SIGNAL\n-#ifndef __WIN32\n+#ifndef _WIN32\n   reset_alarm ();\n #endif\n   caught_signal = false;\n@@ -77,7 +79,7 @@ const char *Signal::name (int sig) {\n     return #SIG;\n   SIGNALS\n #undef SIGNAL\n-#ifndef __WIN32\n+#ifndef _WIN32\n   if (sig == SIGALRM)\n     return \"SIGALRM\";\n #endif\n@@ -91,7 +93,7 @@ const char *Signal::name (int sig) {\n // exclusive access to.  All these solutions are painful and not elegant.\n \n static void catch_signal (int sig) {\n-#ifndef __WIN32\n+#ifndef _WIN32\n   if (sig == SIGALRM && absolute_real_time () >= alarm_time) {\n     if (!caught_alarm) {\n       caught_alarm = true;\n@@ -119,7 +121,7 @@ void Signal::set (Handler *h) {\n #undef SIGNAL\n }\n \n-#ifndef __WIN32\n+#ifndef _WIN32\n \n void Signal::alarm (int seconds) {\n   assert (seconds >= 0);\ndiff --git a/src/signal.hpp b/src/signal.hpp\nindex 5984b66f1..c751339cc 100644\n--- a/src/signal.hpp\n+++ b/src/signal.hpp\n@@ -10,7 +10,7 @@ class Handler {\n   Handler () {}\n   virtual ~Handler () {}\n   virtual void catch_signal (int sig) = 0;\n-#ifndef __WIN32\n+#ifndef _WIN32\n   virtual void catch_alarm ();\n #endif\n };\n@@ -20,7 +20,7 @@ class Signal {\n public:\n   static void set (Handler *);\n   static void reset ();\n-#ifndef __WIN32\n+#ifndef _WIN32\n   static void alarm (int seconds);\n   static void reset_alarm ();\n #endif\n\"\"\""
  },
  {
    "pr_number": 126,
    "title": "mobical.cpp: define MAP_ANONYMOUS if undefined",
    "author": "barracuda156",
    "head_sha": "e19cdcb915b0b7e6c0c1e86a33da51e8a0164630",
    "base_sha": "ab7e803f4e53224e9a699c54168d602835224d04",
    "head_ref": "MAP_ANON",
    "base_ref": "master",
    "merge_commit_sha": null,
    "state": "closed",
    "created_at": "2025-01-07T02:35:33Z",
    "updated_at": "2025-09-15T19:15:42Z",
    "merged_at": null,
    "pr_body": "Trivial fix for platforms where `MAP_ANONYMOUS` is not present.",
    "diff": "\"\"\"diff --git a/src/mobical.cpp b/src/mobical.cpp\nindex 9339e96f9..7f60c7118 100644\n--- a/src/mobical.cpp\n+++ b/src/mobical.cpp\n@@ -4581,6 +4581,10 @@ extern \"C\" {\n #include <sys/mman.h>\n }\n \n+#ifndef MAP_ANONYMOUS\n+#define MAP_ANONYMOUS MAP_ANON\n+#endif\n+\n Mobical::Mobical () {\n   const int prot = PROT_READ | PROT_WRITE;\n   const int flags = MAP_ANONYMOUS | MAP_SHARED;\n\"\"\""
  },
  {
    "pr_number": 123,
    "title": "Adding missing #include to incproof.cpp",
    "author": "eric-wieser",
    "head_sha": "158c99651aeca60b25246bc700ddcb2f860522dd",
    "base_sha": "31f9aae44947c673dc6190c9beb399acb9ffec6a",
    "head_ref": "patch-3",
    "base_ref": "master",
    "merge_commit_sha": "e3579b5af9a5aafaae5cb4209113b1f5cfb54ebc",
    "state": "closed",
    "created_at": "2024-11-14T17:20:59Z",
    "updated_at": "2024-11-18T13:10:26Z",
    "merged_at": null,
    "pr_body": "The `getenv` function is provided by `<cstdlib>`, and the fact that on some compilers it can be found through `<cstdio>` (via `cadical.hpp`) is not guaranteed by the standard.",
    "diff": "\"\"\"diff --git a/test/api/incproof.cpp b/test/api/incproof.cpp\nindex f8869a84c..ab0793f3f 100644\n--- a/test/api/incproof.cpp\n+++ b/test/api/incproof.cpp\n@@ -1,5 +1,6 @@\n #include \"../../src/cadical.hpp\"\n \n+#include <cstdlib>\n #include <string>\n \n using namespace std;\n\"\"\""
  },
  {
    "pr_number": 122,
    "title": "Added memory fuzzing to mobical",
    "author": "TobiasFaller",
    "head_sha": "7fde61064c35b1d983d0a23bb202f5a3c7320392",
    "base_sha": "cc0493ee04519d5e921f5b1400ad993a2c0ad4d1",
    "head_ref": "feature-mobical-memory-fuzzing",
    "base_ref": "development",
    "merge_commit_sha": "138437a2ac2591747baeb733fd80bbe78c8a45e3",
    "state": "closed",
    "created_at": "2024-10-31T22:37:45Z",
    "updated_at": "2024-11-01T08:20:39Z",
    "merged_at": "2024-11-01T08:20:39Z",
    "pr_body": "The following changes have been done:\r\n- Added option to enable memory fuzzing via configure script (`./configure --memory-fuzzing`)\r\n- Added two options to mobical to check for crashes (`--bad-alloc`) caused by bad allocations and memory leaks (`--leak-alloc`)\r\n- Added two new trace entries (`max_alloc` and `leak_alloc`) that specify the limit for the allocator beyond which it will produce a failed allocation and enables the memory leak tracking\r\n- Added comments to mobical trace files which contain stack traces when a crash or memory leak has been detected\r\n- Added mobical option to generate tiny samples (`--tiny`) to make fuzzing faster\r\n\r\n`--memory-fuzzing` has a huge runtime impact due to malloc hooks, and should only be enabled when actually performing memory fuzzing:\r\n- Mobical compiled without `--memory-fuzzing`: 2.163 s\r\n- Mobical compiled with `--memory-fuzzing`: 14.036 s\r\n- Mobical compiled with `--memory-fuzzing` and running with `--bad-alloc`: 14.071 s\r\n- Mobical compiled with `--memory-fuzzing` and running with `--leak-alloc`: 16.980 s\r\n\r\n# New memory trace outputs\r\n\r\nExample mobical trace output of `mobical --bad-alloc` for a crash after a bad allocation:\r\n\r\n```\r\n0 max_alloc 10320\r\n1 init\r\n2 set check 1\r\n3 configure default\r\n# V---------------------------------------------------------------------- bad alloc: allocation\r\n4 add -9\r\n5 add 0\r\n# V---------------------------------------------------------------------- bad alloc: crashed\r\n6 reset\r\n# ---------------------------------------------------\r\n# Memory was tried to be allocated here:\r\n# mobical(CaDiCaL::Trace::hook_malloc(unsigned long)+0x1ad) [0x560a158d481d]\r\n# libstdc++.so.6(operator new(unsigned long)+0x1c) [0x7f07af636f0c]\r\n# mobical(std::vector<signed char, std::allocator<signed char> >::_M_fill_insert(__gnu_cxx::__normal_iterator<signed char*, std::vector<signed char, std::allocator<signed char> > >, unsigned long, signed char const&)+0x109) [0x560a15948d49]\r\n# mobical(CaDiCaL::Internal::enlarge(int)+0x406) [0x560a159479e6]\r\n# mobical(CaDiCaL::Internal::init_vars(int)+0x75) [0x560a15947c45]\r\n# mobical(CaDiCaL::External::init(int)+0x6a) [0x560a1593e0aa]\r\n# mobical(+0xa67a0) [0x560a1593e7a0]\r\n# mobical(CaDiCaL::External::add(int)+0xba) [0x560a1593e91a]\r\n# mobical(CaDiCaL::Solver::add(int)+0xc0) [0x560a159225b0]\r\n# mobical(CaDiCaL::Trace::execute()+0x11e) [0x560a158ede6e]\r\n# mobical(CaDiCaL::Trace::fork_and_execute()+0x92) [0x560a158d8392]\r\n# mobical(CaDiCaL::Trace::shrink(int)+0x30a) [0x560a158e366a]\r\n# mobical(CaDiCaL::Mobical::main(int, char**)+0xf13) [0x560a158d3113]\r\n# libc.so.6(+0x2638a) [0x7f07af2b038a]\r\n# libc.so.6(__libc_start_main+0x8c) [0x7f07af2b044c]\r\n# mobical(_start+0x25) [0x560a158d4545]\r\n#\r\n# ---------------------------------------------------\r\n# A crash happened here:\r\n# mobical(CaDiCaL::Trace::child_signal_handler(int)+0x166) [0x560a158d71d6]\r\n# libc.so.6(+0x3d050) [0x7f07af2c7050]\r\n# libc.so.6(+0x9126c) [0x7f07af31b26c]\r\n# libc.so.6(gsignal+0x1e) [0x7f07af2c6f9e]\r\n# libc.so.6(abort+0xdf) [0x7f07af2ae8ff]\r\n# libc.so.6(+0x2599d) [0x7f07af2af99d]\r\n# libc.so.6(+0x9b6a5) [0x7f07af3256a5]\r\n# libc.so.6(+0x9da2c) [0x7f07af327a2c]\r\n# libc.so.6(__libc_free+0x7e) [0x7f07af32a4de]\r\n# mobical(CaDiCaL::Trace::hook_free(void*)+0x16) [0x560a158d4b36]\r\n# mobical(CaDiCaL::Internal::~Internal()+0x4af) [0x560a159431af]\r\n# mobical(CaDiCaL::Solver::~Solver()+0x9d) [0x560a159210fd]\r\n# mobical(CaDiCaL::ResetCall::execute(CaDiCaL::Solver*&)+0x1e) [0x560a158e81de]\r\n# mobical(CaDiCaL::Trace::execute()+0x11e) [0x560a158ede6e]\r\n# mobical(CaDiCaL::Trace::fork_and_execute()+0x92) [0x560a158d8392]\r\n# mobical(CaDiCaL::Trace::shrink(int)+0x30a) [0x560a158e366a]\r\n# mobical(CaDiCaL::Mobical::main(int, char**)+0xf13) [0x560a158d3113]\r\n# libc.so.6(+0x2638a) [0x7f07af2b038a]\r\n# libc.so.6(__libc_start_main+0x8c) [0x7f07af2b044c]\r\n# mobical(_start+0x25) [0x560a158d4545]\r\n#\r\n```\r\n\r\nExample mobical trace output of `mobical --bad-alloc --leak-alloc` for a memory leak after a bad allocation:\r\n\r\n```\r\n0 max_alloc 32861\r\n1 leak_alloc\r\n2 init\r\n3 add -4\r\n4 add 0\r\n5 add -6\r\n6 add 0\r\n# V---------------------------------------------------------------------- bad alloc: allocation\r\n# V---------------------------------------------------------------------- leak alloc: allocation\r\n7 simplify 10 0\r\n8 reset\r\n# ---------------------------------------------------\r\n# Memory was tried to be allocated here:\r\n# mobical(CaDiCaL::Trace::hook_malloc(unsigned long)+0x1ad) [0x56531ef597ad]\r\n# libstdc++.so.6(operator new(unsigned long)+0x1c) [0x7f3e13efcf0c]\r\n# mobical(CaDiCaL::Internal::decompose_round()+0x2638) [0x56531f024078]\r\n# mobical(CaDiCaL::Internal::decompose()+0x35) [0x56531f024235]\r\n# mobical(CaDiCaL::Internal::probe(bool)+0x5e) [0x56531efe25ae]\r\n# mobical(CaDiCaL::Internal::preprocess_round(int)+0x1da) [0x56531efca0ba]\r\n# mobical(CaDiCaL::Internal::solve(bool)+0x3f0) [0x56531efcb790]\r\n# mobical(CaDiCaL::External::solve(bool)+0x4a) [0x56531efc28ba]\r\n# mobical(CaDiCaL::Solver::simplify(int)+0xce) [0x56531efa959e]\r\n# mobical(CaDiCaL::SimplifyCall::execute(CaDiCaL::Solver*&)+0x1b) [0x56531ef6d14b]\r\n# mobical(CaDiCaL::Trace::execute()+0x34c) [0x56531ef7309c]\r\n# mobical(CaDiCaL::Trace::fork_and_execute()+0x92) [0x56531ef5d342]\r\n# mobical(CaDiCaL::Trace::shrink(int)+0x30a) [0x56531ef6866a]\r\n# mobical(CaDiCaL::Mobical::main(int, char**)+0xf15) [0x56531ef58085]\r\n# libc.so.6(+0x2638a) [0x7f3e13b7638a]\r\n# libc.so.6(__libc_start_main+0x8c) [0x7f3e13b7644c]\r\n# mobical(_start+0x25) [0x56531ef594d5]\r\n#\r\n# ---------------------------------------------------\r\n# Leak of 224 bytes at (0x000x5653201dcee0)\r\n# Memory was allocated here:\r\n# mobical(CaDiCaL::Trace::hook_malloc(unsigned long)+0xf2) [0x56531ef596f2]\r\n# libstdc++.so.6(operator new(unsigned long)+0x1c) [0x7f3e13efcf0c]\r\n# mobical(CaDiCaL::Internal::decompose_round()+0x130) [0x56531f021b70]\r\n# mobical(CaDiCaL::Internal::decompose()+0x35) [0x56531f024235]\r\n# mobical(CaDiCaL::Internal::probe(bool)+0x5e) [0x56531efe25ae]\r\n# mobical(CaDiCaL::Internal::preprocess_round(int)+0x1da) [0x56531efca0ba]\r\n# mobical(CaDiCaL::Internal::solve(bool)+0x3f0) [0x56531efcb790]\r\n# mobical(CaDiCaL::External::solve(bool)+0x4a) [0x56531efc28ba]\r\n# mobical(CaDiCaL::Solver::simplify(int)+0xce) [0x56531efa959e]\r\n# mobical(CaDiCaL::SimplifyCall::execute(CaDiCaL::Solver*&)+0x1b) [0x56531ef6d14b]\r\n# mobical(CaDiCaL::Trace::execute()+0x34c) [0x56531ef7309c]\r\n# mobical(CaDiCaL::Trace::fork_and_execute()+0x92) [0x56531ef5d342]\r\n# mobical(CaDiCaL::Trace::shrink(int)+0x30a) [0x56531ef6866a]\r\n# mobical(CaDiCaL::Mobical::main(int, char**)+0xf15) [0x56531ef58085]\r\n# libc.so.6(+0x2638a) [0x7f3e13b7638a]\r\n# libc.so.6(__libc_start_main+0x8c) [0x7f3e13b7644c]\r\n# mobical(_start+0x25) [0x56531ef594d5]\r\n#\r\n# ---------------------------------------------------\r\n# Leak of 56 bytes at (0x000x5653201e3a60)\r\n# Memory was allocated here:\r\n# mobical(CaDiCaL::Trace::hook_malloc(unsigned long)+0xf2) [0x56531ef596f2]\r\n# libstdc++.so.6(operator new(unsigned long)+0x1c) [0x7f3e13efcf0c]\r\n# mobical(CaDiCaL::Internal::decompose_round()+0x205) [0x56531f021c45]\r\n# mobical(CaDiCaL::Internal::decompose()+0x35) [0x56531f024235]\r\n# mobical(CaDiCaL::Internal::probe(bool)+0x5e) [0x56531efe25ae]\r\n# mobical(CaDiCaL::Internal::preprocess_round(int)+0x1da) [0x56531efca0ba]\r\n# mobical(CaDiCaL::Internal::solve(bool)+0x3f0) [0x56531efcb790]\r\n# mobical(CaDiCaL::External::solve(bool)+0x4a) [0x56531efc28ba]\r\n# mobical(CaDiCaL::Solver::simplify(int)+0xce) [0x56531efa959e]\r\n# mobical(CaDiCaL::SimplifyCall::execute(CaDiCaL::Solver*&)+0x1b) [0x56531ef6d14b]\r\n# mobical(CaDiCaL::Trace::execute()+0x34c) [0x56531ef7309c]\r\n# mobical(CaDiCaL::Trace::fork_and_execute()+0x92) [0x56531ef5d342]\r\n# mobical(CaDiCaL::Trace::shrink(int)+0x30a) [0x56531ef6866a]\r\n# mobical(CaDiCaL::Mobical::main(int, char**)+0xf15) [0x56531ef58085]\r\n# libc.so.6(+0x2638a) [0x7f3e13b7638a]\r\n# libc.so.6(__libc_start_main+0x8c) [0x7f3e13b7644c]\r\n# mobical(_start+0x25) [0x56531ef594d5]\r\n#\r\n```\r\n",
    "diff": "\"\"\"diff --git a/configure b/configure\nindex a6e63efee..3f9dfbbcc 100755\n--- a/configure\n+++ b/configure\n@@ -23,6 +23,7 @@ competition=no\n coverage=no\n flexible=yes\n profile=no\n+memory_fuzzing=no\n contracts=yes\n tracing=yes\n unlocked=yes\n@@ -95,6 +96,8 @@ where '<option>' is one of the following\n \n --coverage         compile with '-ftest-coverage -fprofile-arcs' for 'gcov'\n --profile          compile with '-pg' to profile with 'gprof'\n+--memory-fuzzing   compile with '-rdynamic -fno-omit-frame-pointer' and\n+                   '-DMOBICAL_MEMORY' to fuzz for bad memory allocation handling\n \n --no-contracts     compile without API contract checking code\n --no-tracing       compile without API call tracing code\n@@ -162,6 +165,7 @@ do\n \n     --coverage) coverage=yes;;\n     --profile) profile=yes;;\n+    --memory-fuzzing) memory_fuzzing=yes;;\n \n     --competition) competition=yes;;\n \n@@ -306,6 +310,7 @@ fi\n [ $quiet = yes ] && CXXFLAGS=\"$CXXFLAGS -DQUIET\"\n [ $profile = yes ] && CXXFLAGS=\"$CXXFLAGS -pg\"\n [ $coverage = yes ] && CXXFLAGS=\"$CXXFLAGS -ftest-coverage -fprofile-arcs\"\n+[ $memory_fuzzing = yes ] && CXXFLAGS=\"$CXXFLAGS -rdynamic -fno-omit-frame-pointer -DMOBICAL_MEMORY\"\n if [ $pedantic = yes ]\n then\n   CXXFLAGS=\"$CXXFLAGS --pedantic -Werror -std=c++11\"\ndiff --git a/src/mobical.cpp b/src/mobical.cpp\nindex bac534fae..e40267b1c 100644\n--- a/src/mobical.cpp\n+++ b/src/mobical.cpp\n@@ -32,10 +32,13 @@ static const char *USAGE =\n \"  -<n>              specify the number of solving phases explicitly\\n\"\n \"  --time <seconds>  set time limit per trace (none=0, default=%d)\\n\"\n \"  --space <MB>      set space limit (none=0, default=%d)\\n\"\n+\"  --bad-alloc       generate failing memory allocations, monitor for crashes\\n\"\n+\"  --leak-alloc      generate failing memory allocations, monitor for leaks\\n\"\n \"\\n\"\n \"  --do-not-ignore-resource-limits  consider out-of-time or memory as \"\n \"error\\n\"\n \"\\n\"\n+\"  --tiny            generate tiny formulas only\\n\"\n \"  --small           generate small formulas only\\n\"\n \"  --medium          generate medium sized formulas only\\n\"\n \"  --big             generate big formulas only\\n\"\n@@ -127,12 +130,14 @@ static const char *USAGE =\n \n #include <cstdarg>\n #include <cstring>\n+#include <cstddef>\n #include <fstream>\n #include <iomanip>\n #include <iostream>\n #include <sstream>\n #include <string>\n #include <vector>\n+#include <regex>\n \n // MockPropagator\n #include <deque>\n@@ -142,9 +147,44 @@ static const char *USAGE =\n /*------------------------------------------------------------------------*/\n \n extern \"C\" {\n+#ifdef MOBICAL_MEMORY\n+#include <cxxabi.h>\n+#include <dlfcn.h>\n+#include <execinfo.h>\n+#endif\n #include <unistd.h>\n }\n \n+#ifdef MOBICAL_MEMORY\n+typedef void* (*malloc_t)(size_t);\n+typedef void* (*realloc_t)(void*, size_t);\n+typedef void (*free_t)(void*);\n+static malloc_t libc_malloc = nullptr;\n+static realloc_t libc_realloc = nullptr;\n+static free_t libc_free = nullptr;\n+static malloc_t hook_malloc = nullptr;\n+static realloc_t hook_realloc = nullptr;\n+static free_t hook_free = nullptr;\n+\n+void* malloc (size_t size) {\n+  return hook_malloc ? (*hook_malloc)(size) : (*libc_malloc)(size);\n+}\n+void* realloc (void* ptr, size_t size) {\n+  return hook_realloc ? (*hook_realloc)(ptr, size) : (*libc_realloc)(ptr, size);\n+}\n+void free (void* ptr) {\n+  (hook_free) ? (*hook_free)(ptr) : (*libc_free)(ptr);\n+}\n+\n+void initialize_allocators () {\n+  libc_malloc = reinterpret_cast<malloc_t> (dlsym (RTLD_NEXT, \"malloc\"));\n+  libc_realloc = reinterpret_cast<realloc_t> (dlsym (RTLD_NEXT, \"realloc\"));\n+  libc_free = reinterpret_cast<free_t> (dlsym (RTLD_NEXT, \"free\"));\n+}\n+__attribute__ ((section (\".preinit_array\")))\n+void (*init_allocators_ptr)(void) = initialize_allocators;\n+#endif\n+\n /*------------------------------------------------------------------------*/\n namespace CaDiCaL { // All except 'main' below.\n /*------------------------------------------------------------------------*/\n@@ -161,7 +201,7 @@ class Trace;\n \n // Options to generate traces.\n \n-enum Size { NOSIZE = 0, SMALL = 10, MEDIUM = 30, BIG = 50 };\n+enum Size { NOSIZE = 0, TINY = 5, SMALL = 10, MEDIUM = 30, BIG = 50 };\n \n struct Force {\n   Size size = NOSIZE;\n@@ -199,6 +239,28 @@ struct Shared {\n   int64_t sat;\n   int64_t memout;\n   int64_t timeout;\n+  int64_t oom;\n+\n+#ifdef MOBICAL_MEMORY\n+#define MOBICAL_MEMORY_STACK_COUNT 64\n+#define MOBICAL_MEMORY_LEAK_COUNT (1024 * 64)\n+  struct {\n+    size_t debug_filter_index;\n+    size_t alloc_call_index;\n+    void*  alloc_stack_array [MOBICAL_MEMORY_STACK_COUNT];\n+    size_t alloc_stack_size;\n+    size_t signal_call_index;\n+    void*  signal_stack_array [MOBICAL_MEMORY_STACK_COUNT];\n+    size_t signal_stack_size;\n+  } bad_alloc;\n+  struct {\n+    size_t call_index [MOBICAL_MEMORY_LEAK_COUNT];\n+    size_t alloc_size [MOBICAL_MEMORY_LEAK_COUNT];\n+    void*  alloc_ptr  [MOBICAL_MEMORY_LEAK_COUNT];\n+    void*  stack_array [MOBICAL_MEMORY_LEAK_COUNT][MOBICAL_MEMORY_STACK_COUNT];\n+    size_t stack_size [MOBICAL_MEMORY_LEAK_COUNT];\n+  } leak_alloc;\n+#endif\n };\n \n /*------------------------------------------------------------------------*/\n@@ -276,7 +338,9 @@ class MockPropagator : public ExternalPropagator, public FixedAssignmentListener\n \n     size_t size = clause.size ();\n     ExternalLemma *lemma = new ExternalLemma;\n+    DeferDeletePtr<ExternalLemma> delete_lemma (lemma);\n     lemma->literals = new int[size];\n+    DeferDeleteArray<int> delete_literals (lemma->literals);\n \n     lemma->id = external_lemmas.size ();\n     lemma->add_count = 0;\n@@ -291,6 +355,8 @@ class MockPropagator : public ExternalPropagator, public FixedAssignmentListener\n       *q++ = lit;\n \n     external_lemmas.push_back (lemma);\n+    delete_literals.release ();\n+    delete_lemma.release ();\n \n     return lemma->id;\n   }\n@@ -920,6 +986,10 @@ class Mobical : public Handler {\n \n   int64_t time_limit = DEFAULT_TIME_LIMIT;   // in seconds, none if zero\n   int64_t space_limit = DEFAULT_SPACE_LIMIT; // in MB, none if zero\n+#ifdef MOBICAL_MEMORY\n+  bool bad_alloc = false;\n+  bool leak_alloc = false;\n+#endif\n \n   Terminal &terminal = terr;\n \n@@ -1166,19 +1236,27 @@ struct Call {\n     FLUSHPROOFTRACE = shift ( 35 ),\n     CLOSEPROOFTRACE = shift ( 36 ),\n \n+#ifdef MOBICAL_MEMORY\n+    MAXALLOC        = shift ( 37 ),\n+    LEAKALLOC       = shift ( 38 ),\n+#endif\n+\n     // clang-format on\n \n     ALWAYS = VARS | ACTIVE | REDUNDANT | IRREDUNDANT | FREEZE | FROZEN |\n              MELT | LIMIT | OPTIMIZE | DUMP | STATS | RESERVE | FIXED |\n-             PHASE,\n-\n+             PHASE\n+#ifdef MOBICAL_MEMORY\n+            | MAXALLOC | LEAKALLOC\n+#endif\n+            ,\n     CONFIG = INIT | SET | CONFIGURE | ALWAYS | TRACEPROOF,\n-    BEFORE =\n-        ADD | CONSTRAIN | ASSUME | ALWAYS | DISCONNECT | CONNECT | OBSERVE,\n+    BEFORE = ADD | CONSTRAIN | ASSUME | ALWAYS | DISCONNECT | CONNECT |\n+             OBSERVE,\n     PROCESS = SOLVE | SIMPLIFY | LOOKAHEAD | CUBING,\n     DURING = LEMMA, // | CONTINUE,\n-    AFTER = VAL | FLIP | FAILED | CONCLUDE | ALWAYS | FLUSHPROOFTRACE |\n-            CLOSEPROOFTRACE,\n+    AFTER = VAL | FLIP | FLIPPABLE | FAILED | CONCLUDE | ALWAYS |\n+            FLUSHPROOFTRACE | CLOSEPROOFTRACE,\n   };\n \n   Type type; // Explicit typing.\n@@ -1241,6 +1319,23 @@ struct InitCall : public Call {\n   const char *keyword () { return \"init\"; }\n };\n \n+#ifdef MOBICAL_MEMORY\n+struct MaxAllocCall : public Call {\n+  MaxAllocCall (int val) : Call (MAXALLOC, 0, 0, 0, val) {}\n+  void execute (Solver *&s) { (void) s; }\n+  void print (ostream &o) { o << \"max_alloc \" << val << endl; }\n+  Call *copy () { return new MaxAllocCall (val); }\n+  const char *keyword () { return \"max_alloc\"; }\n+};\n+struct LeakAllocCall : public Call {\n+  LeakAllocCall () : Call (LEAKALLOC) {}\n+  void execute (Solver *&s) { (void) s; }\n+  void print (ostream &o) { o << \"leak_alloc\" << endl; }\n+  Call *copy () { return new LeakAllocCall (); }\n+  const char *keyword () { return \"leak_alloc\"; }\n+};\n+#endif\n+\n struct VarsCall : public Call {\n   VarsCall () : Call (VARS) {}\n   void execute (Solver *&s) { res = s->vars (); }\n@@ -1638,12 +1733,23 @@ class Trace {\n   static int64_t failed;\n   static int64_t ok;\n \n+#ifdef MOBICAL_MEMORY\n+  static int64_t memory_call_index;\n+  static int64_t memory_bad_alloc;\n+  static int64_t memory_bad_size;\n+  static int64_t memory_bad_failed;\n+  static int64_t memory_leak_alloc;\n+  static int64_t memory_leak_next_free;\n+#endif\n+\n #define SIGNALS \\\n   SIGNAL (SIGINT) \\\n   SIGNAL (SIGSEGV) \\\n   SIGNAL (SIGABRT) \\\n   SIGNAL (SIGTERM) \\\n-  SIGNAL (SIGBUS)\n+  SIGNAL (SIGBUS) \\\n+  SIGNAL (SIGUSR1) \\\n+  SIGNAL (SIGUSR2)\n \n #define SIGNAL(SIG) static void (*old_##SIG##_handler) (int);\n   SIGNALS\n@@ -1652,6 +1758,15 @@ class Trace {\n   static void init_child_signal_handlers ();\n   static void reset_child_signal_handlers ();\n \n+#ifdef MOBICAL_MEMORY\n+  static void  hooks_install (void);\n+  static void  hooks_uninstall (void);\n+  static void *hook_malloc (size_t);\n+  static void *hook_realloc (void *, size_t);\n+  static void  hook_free (void *);\n+  static void  print_trace (void **, size_t, ostream&, size_t);\n+#endif\n+\n   Trace (int64_t i = 0, uint64_t s = 0) : id (i), seed (s), solver (0) {}\n \n   void clear () {\n@@ -1670,48 +1785,153 @@ class Trace {\n   void push_back (Call *c) { calls.push_back (c); }\n \n   void print (ostream &o) {\n-    for (size_t i = 0; i < calls.size (); i++)\n-      calls[i]->print (o << i << ' ');\n+    for (size_t i = 0; i < calls.size (); i++) {\n+#ifdef MOBICAL_MEMORY\n+      if (mobical.shared->bad_alloc.alloc_call_index == i + 1)\n+        o << \"# V---------------------------------------------------------------------- bad alloc: allocation\" << endl;\n+      if (mobical.shared->bad_alloc.signal_call_index == i + 1)\n+        o << \"# V---------------------------------------------------------------------- bad alloc: crashed\" << endl;\n+      if (mobical.shared->bad_alloc.debug_filter_index == i + 1)\n+        o << \"# V---------------------------------------------------------------------- debug: call was filtered\" << endl;\n+      for (size_t index { 0u }; index < MOBICAL_MEMORY_LEAK_COUNT; index++) {\n+        if (mobical.shared->leak_alloc.call_index[index] == i + 1) {\n+          o << \"# V---------------------------------------------------------------------- leak alloc: allocation\" << endl;\n+          break;\n+        }\n+      }\n+#endif\n+      o << i << ' ';\n+      calls[i]->print (o);\n+    }\n+\n+#ifdef MOBICAL_MEMORY\n+    if (mobical.shared->bad_alloc.alloc_call_index > 0) {\n+      o << \"# ---------------------------------------------------\" << endl;\n+      o << \"# Memory was tried to be allocated here:\" << endl;\n+      assert (mobical.shared->bad_alloc.alloc_stack_size <= MOBICAL_MEMORY_STACK_COUNT);\n+      print_trace (mobical.shared->bad_alloc.alloc_stack_array,\n+        mobical.shared->bad_alloc.alloc_stack_size, o, 0);\n+      o << \"#\" << endl;\n+    }\n+    if (mobical.shared->bad_alloc.signal_call_index > 0) {\n+      o << \"# ---------------------------------------------------\" << endl;\n+      o << \"# A crash happened here:\" << endl;\n+      assert (mobical.shared->bad_alloc.signal_stack_size <= MOBICAL_MEMORY_STACK_COUNT);\n+      print_trace (mobical.shared->bad_alloc.signal_stack_array,\n+        mobical.shared->bad_alloc.signal_stack_size, o, 0);\n+      o << \"#\" << endl;\n+    }\n+    for (size_t index { 0u }; index < MOBICAL_MEMORY_LEAK_COUNT; index++) {\n+      if (mobical.shared->leak_alloc.alloc_ptr[index] != nullptr) {\n+        o << \"# ---------------------------------------------------\" << endl;\n+        o << \"# Leak of \" << mobical.shared->leak_alloc.alloc_size[index]\n+          << \" bytes at (0x\" << hex << setw (64/4) << setfill ('0')\n+          << mobical.shared->leak_alloc.alloc_ptr[index] << dec << \")\" << endl;\n+        o << \"# Memory was allocated here:\" << endl;\n+        assert (mobical.shared->leak_alloc.stack_size[index] <= MOBICAL_MEMORY_STACK_COUNT);\n+        print_trace (mobical.shared->leak_alloc.stack_array[index],\n+          mobical.shared->leak_alloc.stack_size[index], o, 0);\n+        o << \"#\" << endl;\n+      }\n+    }\n+#endif\n   }\n \n   void execute () {\n+#ifdef MOBICAL_MEMORY\n+    memory_bad_alloc = 0;\n+    memory_bad_size = 0;\n+    memory_bad_failed = 0;\n+    memory_leak_alloc = 0;\n+    memory_leak_next_free = 0;\n+    std::memset (&mobical.shared->bad_alloc, 0, sizeof(mobical.shared->bad_alloc));\n+    std::memset (&mobical.shared->leak_alloc, 0, sizeof(mobical.shared->leak_alloc));\n+    hooks_install ();\n+#endif\n+\n     executed++;\n     bool first = true;\n+    bool deallocated = false;\n     for (size_t i = 0; i < calls.size (); i++) {\n       Call *c = calls[i];\n-      // They are (ideally) are executed already\n-      if (c->type == Call::LEMMA)\n-        continue;\n-      // if (c->type == Call::CONTINUE)\n-      //   continue;\n-\n-      if (c->type == Call::SOLVE) {\n-        // Look ahead and collect LemmaCalls to be executed\n-        // before solve is executed\n-        for (size_t j = i + 1; j < calls.size (); j++) {\n-          Call *next_c = calls[j];\n-          if (next_c->type == Call::LEMMA)\n-            next_c->execute (solver);\n-          // else if (next_c->type == Call::CONTINUE)\n-          //   next_c->execute (solver);\n+\n+#ifdef MOBICAL_MEMORY\n+      memory_call_index = i + 1;\n+      if (memory_bad_failed && c->type != Call::RESET) {\n+        continue; // Ignore call, only RESET (deallocation) allowed.\n+      }\n+#else\n+      (void) deallocated;\n+#endif\n+\n+      try {\n+        // They are (ideally) are executed already\n+        if (c->type == Call::LEMMA)\n+          continue;\n+        // if (c->type == Call::CONTINUE)\n+        //   continue;\n+#ifdef MOBICAL_MEMORY\n+        if (c->type == Call::MAXALLOC) {\n+          memory_bad_alloc = c->val;\n+          memory_bad_size = 0;\n+          continue;\n+        } else if (c->type == Call::LEAKALLOC) {\n+          memory_leak_alloc = 1;\n+          memory_leak_next_free = 0;\n+          continue;\n+        } else if (c->type == Call::RESET) {\n+          deallocated = true;\n+        }\n+#endif\n+\n+        if (c->type == Call::SOLVE) {\n+          // Look ahead and collect LemmaCalls to be executed\n+          // before solve is executed\n+          for (size_t j = i + 1; j < calls.size (); j++) {\n+            Call *next_c = calls[j];\n+            if (next_c->type == Call::LEMMA)\n+              next_c->execute (solver);\n+            // else if (next_c->type == Call::CONTINUE)\n+            //   next_c->execute (solver);\n+            else\n+              break;\n+          }\n+        }\n+        if (mobical.shared && process_type (c->type)) {\n+          mobical.shared->solved++;\n+          if (first)\n+            first = false;\n           else\n-            break;\n+            mobical.shared->incremental++;\n+          c->execute (solver);\n+          if (c->res == 10)\n+            mobical.shared->sat++;\n+          if (c->res == 20)\n+            mobical.shared->unsat++;\n+        } else\n+          c->execute (solver);\n+      } catch (const std::bad_alloc& e) {\n+        // Ignore out-of-memory errors and assume solver state is consistent.\n+        mobical.shared->oom++;\n+      }\n+    }\n+#ifdef MOBICAL_MEMORY\n+    if (deallocated && mobical.mock_pointer) {\n+      delete mobical.mock_pointer;\n+      mobical.mock_pointer = nullptr;\n+    }\n+    hooks_uninstall ();\n+    // Note: Do not force-deallocate here as otherwise the shrink procedure will\n+    // remove the RESET call.\n+    if (deallocated) {\n+      for (size_t index { 0u }; index < MOBICAL_MEMORY_LEAK_COUNT; index++) {\n+        if (mobical.shared->leak_alloc.alloc_ptr[index] != nullptr) {\n+          reset_child_signal_handlers ();\n+          raise (SIGUSR2);\n         }\n       }\n-      if (mobical.shared && process_type (c->type)) {\n-        mobical.shared->solved++;\n-        if (first)\n-          first = false;\n-        else\n-          mobical.shared->incremental++;\n-        c->execute (solver);\n-        if (c->res == 10)\n-          mobical.shared->sat++;\n-        if (c->res == 20)\n-          mobical.shared->unsat++;\n-      } else\n-        c->execute (solver);\n     }\n+#endif\n   }\n \n   int vars () {\n@@ -2453,10 +2673,18 @@ void Trace::generate (uint64_t i, uint64_t s) {\n \n   id = i;\n   seed = s;\n+  Random random (seed);\n \n-  push_back (new InitCall ());\n+#ifdef MOBICAL_MEMORY\n+  if (mobical.bad_alloc && (random.pick_int (0, 2) == 0)) {\n+    push_back (new MaxAllocCall (random.pick_log (1e2, 1e6)));\n+  }\n+  if (mobical.leak_alloc && (random.pick_int (0, 2) == 0)) {\n+    push_back (new LeakAllocCall ());\n+  }\n+#endif\n \n-  Random random (seed);\n+  push_back (new InitCall ());\n \n   Size size;\n \n@@ -2495,7 +2723,9 @@ void Trace::generate (uint64_t i, uint64_t s) {\n     double ratio;\n     int uniform;\n \n-    if (size == SMALL)\n+    if (size == TINY)\n+      range = random.pick_int (1, TINY);\n+    else if (size == SMALL)\n       range = random.pick_int (1, SMALL);\n     else if (size == MEDIUM)\n       range = random.pick_int (SMALL + 1, MEDIUM);\n@@ -2504,6 +2734,8 @@ void Trace::generate (uint64_t i, uint64_t s) {\n \n     if (random.generate_bool ())\n       uniform = 0;\n+    else if (size == TINY)\n+      uniform = 0;\n     else if (size == SMALL)\n       uniform = random.pick_int (3, 7);\n     else if (size == MEDIUM)\n@@ -2616,6 +2848,9 @@ void Mobical::print_statistics () {\n          << terr.normal_code () << \", \" << shared->incremental\n          << \" incremental \"\n          << rounded_percent (shared->incremental, shared->solved) << \"%\"\n+         << terr.normal_code () << \", \" << terr.yellow_code ()\n+         << shared->oom << \" oom \"\n+         << rounded_percent (shared->oom, shared->solved) << \"%\"\n          << endl\n          << flush;\n     if (shared->memout || shared->timeout) {\n@@ -2652,10 +2887,19 @@ extern \"C\" {\n \n #endif\n \n-int64_t Trace::generated;\n-int64_t Trace::executed;\n-int64_t Trace::failed;\n-int64_t Trace::ok;\n+int64_t Trace::generated = 0;\n+int64_t Trace::executed = 0;\n+int64_t Trace::failed = 0;\n+int64_t Trace::ok = 0;\n+\n+#ifdef MOBICAL_MEMORY\n+int64_t Trace::memory_call_index = -1;\n+int64_t Trace::memory_bad_alloc = 0;\n+int64_t Trace::memory_bad_size = 0;\n+int64_t Trace::memory_bad_failed = 0;\n+int64_t Trace::memory_leak_alloc = 0;\n+int64_t Trace::memory_leak_next_free = 0;\n+#endif\n \n #define SIGNAL(SIG) void (*Trace::old_##SIG##_handler) (int);\n SIGNALS\n@@ -2668,6 +2912,22 @@ void Trace::reset_child_signal_handlers () {\n }\n \n void Trace::child_signal_handler (int sig) {\n+#ifdef MOBICAL_MEMORY\n+  hooks_uninstall ();\n+  if (memory_bad_failed) {\n+    mobical.shared->bad_alloc.signal_call_index = memory_call_index;\n+    mobical.shared->bad_alloc.signal_stack_size = backtrace (\n+      mobical.shared->bad_alloc.signal_stack_array,\n+      MOBICAL_MEMORY_STACK_COUNT);\n+    // The signal probably has been raised as a result\n+    // of the forced failed memory allocation.\n+    // Raise a custom signal code for the parent to\n+    // create a unique result code (2 instead of 1).\n+    reset_child_signal_handlers ();\n+    raise (SIGUSR1);\n+  }\n+#endif\n+\n   struct rusage u;\n   if (!getrusage (RUSAGE_SELF, &u)) {\n     if ((int64_t) u.ru_maxrss >> 10 >= mobical.space_limit) {\n@@ -2697,6 +2957,166 @@ void Trace::init_child_signal_handlers () {\n #undef SIGNAL\n }\n \n+#ifdef MOBICAL_MEMORY\n+void Trace::hooks_install (void) {\n+  *static_cast<volatile malloc_t*> (&::hook_malloc) = &hook_malloc;\n+  *static_cast<volatile realloc_t*> (&::hook_realloc) = &hook_realloc;\n+  *static_cast<volatile free_t*> (&::hook_free) = &hook_free;\n+}\n+\n+void Trace::hooks_uninstall (void) {\n+  *static_cast<volatile malloc_t*> (&::hook_malloc) = nullptr;\n+  *static_cast<volatile realloc_t*> (&::hook_realloc) = nullptr;\n+  *static_cast<volatile free_t*> (&::hook_free) = nullptr;\n+}\n+\n+void* Trace::hook_malloc (size_t size) {\n+  // Failing allocator\n+  if (memory_bad_alloc > 0) {\n+    memory_bad_size += size + 1; // + 1 to catch allocations of size 0\n+    if (memory_bad_size > memory_bad_alloc && !memory_bad_failed) {\n+      memory_bad_failed = 1;\n+      hooks_uninstall ();\n+      mobical.shared->bad_alloc.alloc_call_index = memory_call_index;\n+      mobical.shared->bad_alloc.alloc_stack_size = backtrace (\n+        mobical.shared->bad_alloc.alloc_stack_array,\n+        MOBICAL_MEMORY_STACK_COUNT);\n+      hooks_install ();\n+      return nullptr;\n+    }\n+  }\n+  // Default allocator\n+  void* ptr = (*libc_malloc)(size);\n+  // Leak detection\n+  if (memory_leak_alloc > 0) {\n+    for (size_t offset { 0u }; offset < MOBICAL_MEMORY_LEAK_COUNT; offset++) {\n+      size_t index { memory_leak_next_free + offset };\n+      if (index >= MOBICAL_MEMORY_LEAK_COUNT)\n+        index -= MOBICAL_MEMORY_LEAK_COUNT;\n+      if (mobical.shared->leak_alloc.alloc_ptr[index] != nullptr) {\n+        continue;\n+      }\n+      // Found free slot\n+      hooks_uninstall ();\n+      mobical.shared->leak_alloc.alloc_size[index] = size;\n+      mobical.shared->leak_alloc.alloc_ptr[index] = ptr;\n+      mobical.shared->leak_alloc.call_index[index] = memory_call_index;\n+      mobical.shared->leak_alloc.stack_size[index] = backtrace (\n+        mobical.shared->leak_alloc.stack_array[index],\n+        MOBICAL_MEMORY_STACK_COUNT);\n+      memory_leak_next_free = index + 1;\n+      hooks_install ();\n+      return ptr;\n+    }\n+  }\n+  return ptr;\n+}\n+\n+void* Trace::hook_realloc (void *ptr, size_t size) {\n+  // Failing allocator\n+  if (memory_bad_alloc > 0) {\n+    memory_bad_size += size + 1; // + 1 to catch allocations of size 0\n+    if (memory_bad_size > memory_bad_alloc && !memory_bad_failed) {\n+      hooks_uninstall ();\n+      memory_bad_failed = 1;\n+      mobical.shared->bad_alloc.alloc_call_index = memory_call_index;\n+      mobical.shared->bad_alloc.alloc_stack_size = backtrace (\n+        mobical.shared->bad_alloc.alloc_stack_array,\n+        MOBICAL_MEMORY_STACK_COUNT);\n+      hooks_install ();\n+      return nullptr;\n+    }\n+  }\n+  // Default allocator\n+  void* new_ptr = (*libc_realloc)(ptr, size);\n+  // Leak detection\n+  if (memory_leak_alloc > 0) {\n+    for (size_t index { 0u }; index < MOBICAL_MEMORY_LEAK_COUNT; index++) {\n+      if (mobical.shared->leak_alloc.alloc_ptr[index] != ptr) {\n+        continue;\n+      }\n+      // Found previous slot\n+      hooks_uninstall ();\n+      mobical.shared->leak_alloc.alloc_size[index] = size;\n+      mobical.shared->leak_alloc.alloc_ptr[index] = new_ptr;\n+      mobical.shared->leak_alloc.call_index[index] = memory_call_index;\n+      mobical.shared->leak_alloc.stack_size[index] = backtrace (\n+        mobical.shared->leak_alloc.stack_array[index],\n+        MOBICAL_MEMORY_STACK_COUNT);\n+      hooks_install ();\n+      return new_ptr;\n+    }\n+    for (size_t offset { 0u }; offset < MOBICAL_MEMORY_LEAK_COUNT; offset++) {\n+      size_t index { memory_leak_next_free + offset };\n+      if (index >= MOBICAL_MEMORY_LEAK_COUNT)\n+        index -= MOBICAL_MEMORY_LEAK_COUNT;\n+      if (mobical.shared->leak_alloc.alloc_ptr[index] != nullptr) {\n+        continue;\n+      }\n+      // Found free slot\n+      hooks_uninstall ();\n+      mobical.shared->leak_alloc.alloc_size[index] = size;\n+      mobical.shared->leak_alloc.alloc_ptr[index] = new_ptr;\n+      mobical.shared->leak_alloc.call_index[index] = memory_call_index;\n+      mobical.shared->leak_alloc.stack_size[index] = backtrace (\n+        mobical.shared->leak_alloc.stack_array[index],\n+        MOBICAL_MEMORY_STACK_COUNT);\n+      memory_leak_next_free = index + 1;\n+      hooks_install ();\n+      return new_ptr;\n+    }\n+\n+    hooks_uninstall ();\n+    printf (\"No free slot!\");\n+    hooks_install ();\n+  }\n+  return new_ptr;\n+}\n+\n+void Trace::hook_free (void* ptr) {\n+  (*libc_free)(ptr);\n+  // Leak detection\n+  if (memory_leak_alloc > 0) {\n+    for (size_t index { 0u }; index < MOBICAL_MEMORY_LEAK_COUNT; index++) {\n+      if (mobical.shared->leak_alloc.alloc_ptr[index] == ptr) {\n+        mobical.shared->leak_alloc.alloc_size[index] = 0;\n+        mobical.shared->leak_alloc.alloc_ptr[index] = nullptr;\n+        mobical.shared->leak_alloc.call_index[index] = 0;\n+        mobical.shared->leak_alloc.stack_size[index] = 0;\n+        //memory_leak_next_free = index;\n+        break;\n+      }\n+    }\n+  }\n+}\n+\n+void Trace::print_trace (void** stack_array, size_t stack_size, ostream& os, size_t start_index) {\n+  char ** stack_text = backtrace_symbols (stack_array, stack_size);\n+  for (size_t stack_index = start_index; stack_index < stack_size; stack_index++) {\n+    string stack_entry = stack_text[stack_index];\n+    if (size_t position = stack_entry.rfind (\"/\"); position != string::npos) {\n+      stack_entry = stack_entry.substr (position + 1);\n+    }\n+    smatch match; // Try to unmangle C++ method names\n+    regex regex_function_name(\"^(.*?)\\\\(([a-zA-Z0-9_]+)((?:\\\\+0x[0-9a-fA-F]+)?)\\\\)(.*?)\");\n+    if (regex_match (stack_entry, match, regex_function_name)) {\n+      string mangledName = match[2];\n+      int status = -1;\n+      char *demangledName = abi::__cxa_demangle (mangledName.c_str(), NULL, NULL, &status);\n+      if (status == 0) { // Print C++ method name\n+        os << \"# \" << match[1] << \"(\" << demangledName << match[3] << \")\" << match[4] << endl;\n+        free (static_cast<void*>(demangledName));\n+      } else { // Print C method name\n+        os << \"# \" << match[1] << \"(\" << mangledName << match[3] << \")\" << match[4] << endl;\n+      }\n+    } else { // Print unparsable stack entry\n+      os << \"# \" << stack_entry << endl;\n+    }\n+  }\n+  free (static_cast<void *>(stack_text));\n+}\n+#endif\n+\n int Trace::fork_and_execute () {\n \n   cerr << flush;\n@@ -2716,6 +3136,10 @@ int Trace::fork_and_execute () {\n       res = 0;\n     else if (mobical.donot.ignore_resource_limits)\n       res = 1;\n+    else if (WTERMSIG (status) == SIGUSR1)\n+      res = 2; // Bad allocation caused signal.\n+    else if (WTERMSIG (status) == SIGUSR2)\n+      res = 3; // Leaked allocation caused signal.\n     else\n       res = (WTERMSIG (status) != SIGXCPU);\n \n@@ -3098,11 +3522,20 @@ void Trace::add_options (int expected) {\n   const int max_var = vars ();\n   notify ('a');\n   assert (size ());\n-  assert (calls[0]->type == Call::INIT);\n   Trace extended;\n-  extended.push_back (calls[0]->copy ());\n-  size_t i = 1;\n+  size_t i = 0;\n   Call *c;\n+  for (; i < size (); i++) {\n+    c = calls[i];\n+#ifdef MOBICAL_MEMORY\n+    if (!(c->type == Call::INIT || c->type == Call::MAXALLOC)) {\n+#else\n+    if (!(c->type == Call::INIT)) {\n+#endif\n+      continue;\n+    }\n+    extended.push_back (c->copy ());\n+  }\n   while (i < size () && (c = calls[i])->type == Call::SET)\n     extended.push_back (c->copy ()), i++;\n   for (Options::const_iterator it = Options::begin ();\n@@ -3206,7 +3639,6 @@ bool Trace::reduce_values (int expected) {\n   notify ('r');\n \n   assert (size ());\n-  assert (calls[0]->type == Call::INIT);\n \n   bool changed = false, res = false;\n   do {\n@@ -3236,6 +3668,10 @@ bool Trace::reduce_values (int expected) {\n           continue;\n       } else if (c->type == Call::OPTIMIZE) {\n         lo = 0, hi = 9;\n+#ifdef MOBICAL_MEMORY\n+      } else if (c->type == Call::MAXALLOC) {\n+        lo = 0, hi = c->val;\n+#endif\n       } else\n         continue;\n \n@@ -3422,7 +3858,7 @@ void Trace::shrink (int expected) {\n   mobical.shrinking = true;\n   mobical.notified.clear ();\n   assert (!mobical.donot.shrink.atall);\n-  if (!size () || calls[0]->type != Call::INIT)\n+  if (!size ())\n     return;\n   add_options (expected);\n   Shrinking l = NONE;\n@@ -3448,6 +3884,9 @@ void Trace::shrink (int expected) {\n   } while (s);\n   map_variables (expected);\n   shrink_options (expected);\n+  // Execute one last time to get accurate results when memory fuzzing\n+  // is enabled.\n+  fork_and_execute ();\n   cerr << flush;\n   mobical.shrinking = false;\n }\n@@ -3518,6 +3957,14 @@ void Reader::parse () {\n   Call *before_trigger = 0;\n   char line[80];\n   while ((ch = next ()) != EOF) {\n+    // Ignore comments (used for additional human readable information).\n+    if (ch == '#') {\n+      while (ch != '\\n') {\n+        if ((ch = next ()) == EOF)\n+          error (\"unexpected end-of-file\");\n+      }\n+      continue;\n+    }\n     size_t n = 0;\n     while (ch != '\\n') {\n       if (n + 2 >= sizeof line)\n@@ -3891,15 +4338,32 @@ void Reader::parse () {\n       if (first)\n         error (\"additional argument '%s' to 'close_proof_trace'\", first);\n       c = new CloseProofTraceCall ();\n+#ifdef MOBICAL_MEMORY\n+    } else if (!strcmp (keyword, \"max_alloc\")) {\n+      if (!mobical.bad_alloc)\n+        error (\"option --bad-alloc has to be anabled for max_alloc calls\");\n+      if (!first)\n+        error (\"first argument to 'max_alloc' missing\");\n+      if (!parse_int_str (first, val))\n+        error (\"invalid first argument '%s' to 'max_alloc'\", first);\n+      c = new MaxAllocCall (val);\n+    } else if (!strcmp (keyword, \"leak_alloc\")) {\n+      if (!mobical.leak_alloc)\n+        error (\"option --leak-alloc has to be anabled for leak_alloc calls\");\n+      c = new LeakAllocCall ();\n+#endif\n     } else\n       error (\"invalid keyword '%s'\", keyword);\n \n     // This checks the legal structure of traces described above.\n     //\n     if (enforce) {\n-\n-      if (!state && c->type != Call::INIT)\n-        error (\"first call has to be an 'init' call\");\n+#ifdef MOBICAL_MEMORY\n+      if (!state && !(c->type & (Call::INIT | Call::MAXALLOC)))\n+#else\n+      if (!state && !(c->type == Call::INIT))\n+#endif\n+        error (\"first call has to be an 'init' or 'maxalloc' call\");\n \n       if (state == Call::RESET)\n         error (\"'%s' after 'reset'\", c->keyword ());\n@@ -4148,6 +4612,8 @@ int Mobical::main (int argc, char **argv) {\n              !strcmp (argv[i], \"--do-not-reduce-values\") ||\n              !strcmp (argv[i], \"--do-not-reduce-option-values\"))\n       donot.reduce = true;\n+    else if (!strcmp (argv[i], \"--tiny\"))\n+      force.size = TINY;\n     else if (!strcmp (argv[i], \"--small\"))\n       force.size = SMALL;\n     else if (!strcmp (argv[i], \"--medium\"))\n@@ -4186,6 +4652,17 @@ int Mobical::main (int argc, char **argv) {\n       if (!is_unsigned_str (argv[i]) ||\n           (space_limit = atol (argv[i])) < 0 || space_limit > 1e9)\n         die (\"invalid argument '%s' to '--space' (try '-h')\", argv[i]);\n+#ifdef MOBICAL_MEMORY\n+    } else if (!strcmp (argv[i], \"--bad-alloc\")) {\n+      bad_alloc = true;\n+    } else if (!strcmp (argv[i], \"--leak-alloc\")) {\n+      leak_alloc = true;\n+#else\n+    } else if (!strcmp (argv[i], \"--bad-alloc\")) {\n+      die (\"--bad-alloc requires memory fuzzing to be enabled at compile time\");\n+    } else if (!strcmp (argv[i], \"--leak-alloc\")) {\n+      die (\"--leak-alloc requires memory fuzzing to be enabled at compile time\");\n+#endif\n     } else if (!strcmp (argv[i], \"--do-not-ignore-resource-limits\")) {\n       donot.ignore_resource_limits = true;\n     } else if (argv[i][0] == '-' && is_unsigned_str (argv[i] + 1)) {\n@@ -4597,5 +5074,11 @@ int Mobical::main (int argc, char **argv) {\n /*------------------------------------------------------------------------*/\n \n int main (int argc, char **argv) {\n+#ifdef MOBICAL_MEMORY\n+  // Disable buffers as they are otherwise detected as memory leak\n+  setvbuf(stdout, NULL, _IONBF, 0);\n+  setvbuf(stderr, NULL, _IONBF, 0);\n+  setvbuf(stdin, NULL, _IONBF, 0);\n+#endif\n   return CaDiCaL::mobical.main (argc, argv);\n }\n\"\"\""
  },
  {
    "pr_number": 121,
    "title": "Added replacement for closefrom for Mac",
    "author": "TobiasFaller",
    "head_sha": "db1abe53b20cfcfe360fbe2cf651caf8e7769693",
    "base_sha": "75fff75bb0931571ecc1fdaad19c0e82a05778e1",
    "head_ref": "thread-safe-compressed-file-writing",
    "base_ref": "thread-safe-compressed-file-writing",
    "merge_commit_sha": "7c57b94000e4062d4286f5ac986b3e2e024c4625",
    "state": "closed",
    "created_at": "2024-10-31T17:21:31Z",
    "updated_at": "2024-10-31T18:03:06Z",
    "merged_at": "2024-10-31T18:03:05Z",
    "pr_body": null,
    "diff": "\"\"\"diff --git a/src/file.cpp b/src/file.cpp\nindex 938b2ed6f..f5c9e8dd1 100644\n--- a/src/file.cpp\n+++ b/src/file.cpp\n@@ -22,6 +22,15 @@ extern \"C\" {\n \n #endif\n \n+#if defined(__APPLE__) || defined(__MACH__)\n+\n+extern \"C\" {\n+#include <libproc.h>\n+#include <sys/proc_info.h>\n+}\n+\n+#endif\n+\n /*------------------------------------------------------------------------*/\n \n namespace CaDiCaL {\n@@ -300,7 +309,27 @@ FILE *File::write_pipe (Internal *internal, const char *command,\n     // These fds are cloned into the child process.\n     // As this inhibits pipes to be closed by the parent process\n     // we have to close all of the erroneously cloned fds here.\n+#if defined(__linux__) || defined(__unix__)\n     ::closefrom (3);\n+#elif defined(__APPLE__) || defined(__MACH__)\n+    {\n+      int fds, pid = getpid ();\n+      if ((fds = proc_pidinfo (pid, PROC_PIDLISTFDS, 0, nullptr, 0)) < 0) {\n+        MSG (\"could not get length of list of opened fds\");\n+        _exit (1);\n+      }\n+      auto fdinfos = new struct proc_fdinfo[fds];\n+      if (proc_pidinfo (pid, PROC_PIDLISTFDS, 0, fdinfos, fds) < 0) {\n+        delete[] fdinfos;\n+        MSG (\"could not get list of opened fds\");\n+        _exit (1);\n+      }\n+      for (int i = 0; i < fds; i++)\n+        if (fdinfos[i].proc_fd >= 3)\n+          ::close (fdinfos[i].proc_fd);\n+      delete[] fdinfos;\n+    }\n+#endif\n     execv (absolute_command_path, argv);\n     _exit (1);\n   }\ndiff --git a/test/api/parcompwrite.cpp b/test/api/parcompwrite.cpp\nindex 0ada2b76f..85091213f 100644\n--- a/test/api/parcompwrite.cpp\n+++ b/test/api/parcompwrite.cpp\n@@ -31,15 +31,15 @@ static string path (const char *tester, unsigned i) {\n   return prefix (tester) + \"-\" + to_string (i) + suffix;\n }\n \n-static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n+static pthread_mutex_t serialize_mutex = PTHREAD_MUTEX_INITIALIZER;\n \n static void lock () {\n-  if (pthread_mutex_lock (&mutex))\n+  if (pthread_mutex_lock (&serialize_mutex))\n     perror (\"error: pthread_mutex_lock failed\");\n }\n \n static void unlock () {\n-  if (pthread_mutex_unlock (&mutex))\n+  if (pthread_mutex_unlock (&serialize_mutex))\n     perror (\"error: pthread_mutex_unlock failed\");\n }\n \n@@ -240,6 +240,7 @@ static void catch_alarm (int sig) {\n   assert (sig == SIGALRM);\n   const char *msg = \"error: unexpected alarm (file I/O hanging?)\\n\";\n   ::write (2, msg, strlen (msg));\n+  (void) sig;\n   exit (1);\n }\n \n\"\"\""
  },
  {
    "pr_number": 120,
    "title": "Fixed fork() cloning unwanted file descriptors",
    "author": "TobiasFaller",
    "head_sha": "74a32237a6ea3311bfa7bdd746775ceeaa755292",
    "base_sha": "487612683114530f4176034cdfd59684dff3f2ea",
    "head_ref": "thread-safe-compressed-file-writing",
    "base_ref": "thread-safe-compressed-file-writing",
    "merge_commit_sha": "75fff75bb0931571ecc1fdaad19c0e82a05778e1",
    "state": "closed",
    "created_at": "2024-10-29T12:54:48Z",
    "updated_at": "2024-11-01T08:27:32Z",
    "merged_at": "2024-10-29T15:28:16Z",
    "pr_body": null,
    "diff": "\"\"\"diff --git a/src/file.cpp b/src/file.cpp\nindex 825bc25fd..938b2ed6f 100644\n--- a/src/file.cpp\n+++ b/src/file.cpp\n@@ -274,26 +274,33 @@ FILE *File::write_pipe (Internal *internal, const char *command,\n   FILE *res = 0;\n   if (!absolute_command_path)\n     MSG (\"could not find '%s' in 'PATH' environment variable\", argv[0]);\n-  else if (pipe (pipe_fds) < 0)\n+  else if (::pipe (pipe_fds) < 0)\n     MSG (\"could not generate pipe to '%s' command\", command);\n   else if ((out = ::open (path, O_CREAT | O_TRUNC | O_WRONLY, 0644)) < 0)\n     MSG (\"could not open '%s' for writing\", path);\n-  else if ((child_pid = fork ()) < 0) {\n+  else if ((child_pid = ::fork ()) < 0) {\n     MSG (\"could not fork process to execute '%s' command\", command);\n     ::close (out);\n   } else if (child_pid) {\n     ::close (pipe_fds[0]);\n     res = ::fdopen (pipe_fds[1], \"wb\");\n   } else {\n-    ::close (pipe_fds[1]);\n-    ::close (0);\n-    ::close (1);\n+    // Connect stdin and stdout in child\n+    ::dup2 (pipe_fds[0], 0);\n+    ::dup2 (out, 1);\n+    // Make sure to close all non-required fds to not cause hangs.\n+    // This is handled now by closefrom and remains for documentation\n+    // purposes:\n+    //   ::close (pipe_fds[0]);\n+    //   ::close (pipe_fds[1]);\n+    //   ::close (out);\n     if (command[0] == '7') // Surpress '7z' verbose output on 'stderr'.\n       ::close (2);\n-    int in = dup (pipe_fds[0]);\n-    assert (in == 0), (void) in;\n-    int tmp = dup2 (out, 1);\n-    assert (tmp == 1), (void) tmp;\n+    // Before the fork another thread could have created more fds.\n+    // These fds are cloned into the child process.\n+    // As this inhibits pipes to be closed by the parent process\n+    // we have to close all of the erroneously cloned fds here.\n+    ::closefrom (3);\n     execv (absolute_command_path, argv);\n     _exit (1);\n   }\n\"\"\""
  },
  {
    "pr_number": 119,
    "title": "Fix issues with memory safety when allocation fails",
    "author": "TobiasFaller",
    "head_sha": "34dd82b18b992b694c2a550c7dc751750b57eb2b",
    "base_sha": "aaadb0b28e8e223097e7ff5f3767c9112abf99a1",
    "head_ref": "fix-failed-allocations-memory-safety",
    "base_ref": "development",
    "merge_commit_sha": "cc0493ee04519d5e921f5b1400ad993a2c0ad4d1",
    "state": "closed",
    "created_at": "2024-10-28T16:22:36Z",
    "updated_at": "2024-10-31T16:32:59Z",
    "merged_at": "2024-10-31T08:57:23Z",
    "pr_body": "Fixes various conditions where consistency and memory safety can't be guaranteed in case of a failed allocation.\r\nThe goal is to guarantee the CaDiCaL instance can be deallocated and no memory is leaked after std::bad_alloc has been thrown by the allocator.\r\n\r\nThe fixes correct the following problems:\r\n\r\n- Assumptions that are invalidated (vectors that are incrementally built)\r\n- Arena affiliation check for clauses that ignores the new arena\r\n- Garbage collection that can't handle an inconsistent state\r\n- Reallocations happening between updating essential pointers\r\n- Profiling still being active after failed allocation\r\n- Memory being leaked using manual memory management (new, delete)\r\n\r\nToDo:\r\n- [x] Compilation / regression test (Tobias)\r\n- [x] Performance regression test on cluster\r\n- [x] Manual code review (Armin / Mathias)\r\n- ~~[ ] Evaluation for non-x86 platforms without TSO~~ (Terminator shouldn't cause bad allocations)\r\n- [ ] Upstreaming of memory fuzzing in Mobical (separate Pull Request) ",
    "diff": "\"\"\"diff --git a/src/arena.hpp b/src/arena.hpp\nindex f6d809f47..bc230ed5c 100644\n--- a/src/arena.hpp\n+++ b/src/arena.hpp\n@@ -76,7 +76,8 @@ class Arena {\n   //\n   bool contains (void *p) const {\n     char *c = (char *) p;\n-    return from.start <= c && c < from.top;\n+    return (from.start <= c && c < from.top)\n+      || (to.start <= c && c < to.top);\n   }\n \n   // Allocate that amount of memory in 'to' space.  This assumes the 'to'\ndiff --git a/src/checker.cpp b/src/checker.cpp\nindex 4398951ef..b386b1b9c 100644\n--- a/src/checker.cpp\n+++ b/src/checker.cpp\n@@ -40,6 +40,7 @@ CheckerClause *Checker::new_clause () {\n   assert (size > 1), assert (size <= UINT_MAX);\n   const size_t bytes = sizeof (CheckerClause) + (size - 2) * sizeof (int);\n   CheckerClause *res = (CheckerClause *) new char[bytes];\n+  DeferDeleteArray<char> delete_res ((char *) res);\n   res->next = 0;\n   res->hash = last_hash;\n   res->size = size;\n@@ -67,6 +68,7 @@ CheckerClause *Checker::new_clause () {\n   watcher (literals[0]).push_back (CheckerWatch (literals[1], res));\n   watcher (literals[1]).push_back (CheckerWatch (literals[0], res));\n \n+  delete_res.release ();\n   return res;\n }\n \n@@ -230,12 +232,12 @@ void Checker::enlarge_vars (int64_t idx) {\n   vals -= size_vars;\n   delete[] vals;\n   vals = new_vals;\n+  size_vars = new_size_vars;\n \n   watchers.resize (2 * new_size_vars);\n   marks.resize (2 * new_size_vars);\n \n   assert (idx < new_size_vars);\n-  size_vars = new_size_vars;\n }\n \n inline void Checker::import_literal (int lit) {\n@@ -461,6 +463,11 @@ void Checker::add_clause (const char *type) {\n   (void) type;\n #endif\n \n+  // If there are enough garbage clauses collect them first.\n+  if (num_garbage >\n+      0.5 * max ((size_t) size_clauses, (size_t) size_vars))\n+    collect_garbage_clauses ();\n+\n   int unit = 0;\n   for (const auto &lit : simplified) {\n     const signed char tmp = val (lit);\n@@ -546,6 +553,8 @@ void Checker::delete_clause (uint64_t id, bool, const vector<int> &c) {\n   START (checking);\n   LOG (c, \"CHECKER checking deletion of clause\");\n   stats.deleted++;\n+  simplified.clear();  // Can be non-empty if clause allocation fails.\n+  unsimplified.clear();  // Can be non-empty if clause allocation fails.\n   import_clause (c);\n   last_id = id;\n   if (!tautological ()) {\n@@ -560,10 +569,6 @@ void Checker::delete_clause (uint64_t id, bool, const vector<int> &c) {\n       d->next = garbage;\n       garbage = d;\n       d->size = 0;\n-      // If there are enough garbage clauses collect them.\n-      if (num_garbage >\n-          0.5 * max ((size_t) size_clauses, (size_t) size_vars))\n-        collect_garbage_clauses ();\n     } else {\n       fatal_message_start ();\n       fputs (\"deleted clause not in proof:\\n\", stderr);\ndiff --git a/src/checker.hpp b/src/checker.hpp\nindex a6179801f..02e86acd3 100644\n--- a/src/checker.hpp\n+++ b/src/checker.hpp\n@@ -147,7 +147,7 @@ class Checker : public StatTracer {\n \n public:\n   Checker (Internal *);\n-  ~Checker ();\n+  virtual ~Checker ();\n \n   void connect_internal (Internal *i) override;\n \ndiff --git a/src/clause.cpp b/src/clause.cpp\nindex 0d90dbfbb..c8a5820c6 100644\n--- a/src/clause.cpp\n+++ b/src/clause.cpp\n@@ -94,6 +94,7 @@ Clause *Internal::new_clause (bool red, int glue) {\n \n   size_t bytes = Clause::bytes (size);\n   Clause *c = (Clause *) new char[bytes];\n+  DeferDeleteArray<char> clause_delete ((char *) c);\n \n   c->id = ++clause_id;\n \n@@ -140,6 +141,7 @@ Clause *Internal::new_clause (bool red, int glue) {\n   }\n \n   clauses.push_back (c);\n+  clause_delete.release ();\n   LOG (c, \"new pointer %p\", (void *) c);\n \n   if (likely_to_be_kept_clause (c))\n@@ -579,10 +581,10 @@ Clause *Internal::new_clause_as (const Clause *orig) {\n //\n Clause *Internal::new_resolved_irredundant_clause () {\n   external->check_learned_clause ();\n-  Clause *res = new_clause (false);\n   if (proof) {\n-    proof->add_derived_clause (res, lrat_chain);\n+    proof->add_derived_clause (clause_id + 1, false, clause, lrat_chain);\n   }\n+  Clause *res = new_clause (false);\n   assert (!watching ());\n   return res;\n }\ndiff --git a/src/compact.cpp b/src/compact.cpp\nindex 522bca8ae..7d6cb2ec3 100644\n--- a/src/compact.cpp\n+++ b/src/compact.cpp\n@@ -411,6 +411,7 @@ void Internal::compact () {\n     vals -= vsize;\n     delete[] vals;\n     vals = new_vals;\n+    vsize = mapper.new_vsize;\n   }\n \n   // 'constrain' uses 'val', so this code has to be after remapping that\n@@ -516,7 +517,6 @@ void Internal::compact () {\n   /*----------------------------------------------------------------------*/\n \n   max_var = mapper.new_max_var;\n-  vsize = mapper.new_vsize;\n \n   stats.unused = 0;\n   stats.inactive = stats.now.fixed = mapper.first_fixed ? 1 : 0;\ndiff --git a/src/decompose.cpp b/src/decompose.cpp\nindex e48215d62..65cbe2487 100644\n--- a/src/decompose.cpp\n+++ b/src/decompose.cpp\n@@ -167,7 +167,9 @@ bool Internal::decompose_round () {\n \n   const size_t size_dfs = 2 * (1 + (size_t) max_var);\n   DFS *dfs = new DFS[size_dfs];\n+  DeferDeleteArray<DFS> dfs_delete (dfs);\n   int *reprs = new int[size_dfs];\n+  DeferDeleteArray<int> reprs_delete (reprs);\n   clear_n (reprs, size_dfs);\n   vector<vector<Clause *>> dfs_chains;\n   dfs_chains.resize (size_dfs);\n@@ -725,8 +727,8 @@ bool Internal::decompose_round () {\n       mark_substituted (idx);\n   }\n \n-  delete[] reprs;\n-  delete[] dfs;\n+  reprs_delete.free ();\n+  dfs_delete.free ();\n   erase_vector (dfs_chains);\n \n   flush_all_occs_and_watches (); // particularly the 'blit's\ndiff --git a/src/external.cpp b/src/external.cpp\nindex 8d98261fc..fa3c0e1ee 100644\n--- a/src/external.cpp\n+++ b/src/external.cpp\n@@ -747,6 +747,7 @@ void External::check_constraint_satisfied () {\n \n void External::check_failing () {\n   Solver *checker = new Solver ();\n+  DeferDeletePtr<Solver> delete_checker (checker);\n   checker->prefix (\"checker \");\n #ifdef LOGGING\n   if (internal->opts.log)\n@@ -789,7 +790,7 @@ void External::check_failing () {\n   int res = checker->solve ();\n   if (res != 20)\n     FATAL (\"failed assumptions do not form a core\");\n-  delete checker;\n+  delete_checker.free ();\n   VERBOSE (1, \"checked that %zd failing assumptions form a core\",\n            assumptions.size ());\n }\ndiff --git a/src/internal.cpp b/src/internal.cpp\nindex 43ea213a1..f9f8666f2 100644\n--- a/src/internal.cpp\n+++ b/src/internal.cpp\n@@ -48,6 +48,11 @@ Internal::Internal ()\n }\n \n Internal::~Internal () {\n+  // If a memory exception ocurred a profile might still be active.\n+#define PROFILE(NAME, LEVEL) \\\n+  if (PROFILE_ACTIVE(NAME)) STOP(NAME);\n+  PROFILES\n+#undef PROFILE\n   delete[](char *) dummy_binary;\n   for (const auto &c : clauses)\n     delete_clause (c);\n@@ -142,6 +147,7 @@ void Internal::enlarge (int new_max_var) {\n   enlarge_init (ptab, 2 * new_vsize, -1);\n   enlarge_only (ftab, new_vsize);\n   enlarge_vals (new_vsize);\n+  vsize = new_vsize;\n   enlarge_zero (frozentab, new_vsize);\n   enlarge_zero (relevanttab, new_vsize);\n   const signed char val = opts.phase ? 1 : -1;\n@@ -152,7 +158,6 @@ void Internal::enlarge (int new_max_var) {\n   enlarge_zero (phases.prev, new_vsize);\n   enlarge_zero (phases.min, new_vsize);\n   enlarge_zero (marks, new_vsize);\n-  vsize = new_vsize;\n }\n \n void Internal::init_vars (int new_max_var) {\ndiff --git a/src/lratbuilder.cpp b/src/lratbuilder.cpp\nindex b79cba0e3..a1e3d4889 100644\n--- a/src/lratbuilder.cpp\n+++ b/src/lratbuilder.cpp\n@@ -54,6 +54,7 @@ LratBuilderClause *LratBuilder::new_clause () {\n   const size_t bytes =\n       sizeof (LratBuilderClause) + (size - off) * sizeof (int);\n   LratBuilderClause *res = (LratBuilderClause *) new char[bytes];\n+  DeferDeleteArray<char> delete_res ((char *) res);\n   res->garbage = false;\n   res->next = 0;\n   res->hash = last_hash;\n@@ -65,10 +66,12 @@ LratBuilderClause *LratBuilder::new_clause () {\n     *p++ = lit;\n \n   if (size == 0) {\n+    delete_res.release ();\n     return res;\n   }\n   if (size == 1) {\n     unit_clauses.push_back (res);\n+    delete_res.release ();\n     return res;\n   }\n \n@@ -96,6 +99,7 @@ LratBuilderClause *LratBuilder::new_clause () {\n   } else {\n     LOG (\"LRAT BUILDER clause not added to watchers\");\n   }\n+  delete_res.release ();\n   return res;\n }\n \n@@ -270,6 +274,7 @@ void LratBuilder::enlarge_vars (int64_t idx) {\n   vals -= size_vars;\n   delete[] vals;\n   vals = new_vals;\n+  size_vars = new_size_vars;\n \n   reasons.resize (new_size_vars);\n   unit_reasons.resize (new_size_vars);\n@@ -287,7 +292,6 @@ void LratBuilder::enlarge_vars (int64_t idx) {\n   checked_lits.resize (2 * new_size_vars);\n \n   assert (idx < new_size_vars);\n-  size_vars = new_size_vars;\n }\n \n inline void LratBuilder::import_literal (int lit) {\n@@ -695,6 +699,10 @@ void LratBuilder::add_clause (const char *type) {\n   (void) type;\n #endif\n \n+  // If there are enough garbage clauses collect them.\n+  if (num_garbage > 0.5 * max ((size_t) size_clauses, (size_t) size_vars))\n+    collect_garbage_clauses ();\n+\n   LratBuilderClause *c = insert ();\n   if (inconsistent) {\n     LOG (\"LRAT BUILDER state already inconsistent so nothing more to do\");\n@@ -900,10 +908,6 @@ void LratBuilder::delete_clause (uint64_t id, const vector<int> &c) {\n              d->id);\n       }\n     }\n-\n-    // If there are enough garbage clauses collect them.\n-    if (num_garbage > 0.5 * max ((size_t) size_clauses, (size_t) size_vars))\n-      collect_garbage_clauses ();\n   } else {\n     fatal_message_start ();\n     fputs (\"deleted clause not in proof:\\n\", stderr);\ndiff --git a/src/lratchecker.hpp b/src/lratchecker.hpp\nindex 3d450892b..4646029e2 100644\n--- a/src/lratchecker.hpp\n+++ b/src/lratchecker.hpp\n@@ -117,7 +117,7 @@ class LratChecker : public StatTracer {\n \n public:\n   LratChecker (Internal *);\n-  ~LratChecker ();\n+  virtual ~LratChecker ();\n \n   void connect_internal (Internal *i) override;\n   void begin_proof (uint64_t) override;\ndiff --git a/src/profile.hpp b/src/profile.hpp\nindex ebe3ad963..bbd492d52 100644\n--- a/src/profile.hpp\n+++ b/src/profile.hpp\n@@ -133,6 +133,10 @@ struct Profiles {\n                                       internal->time ());) \\\n   } while (0)\n \n+#define PROFILE_ACTIVE(P) \\\n+  ((internal->profiles.P.level <= internal->opts.profile) \\\n+    && (internal->profiles.P.active))\n+\n /*------------------------------------------------------------------------*/\n \n #define START_SIMPLIFIER(S, M) \\\ndiff --git a/src/proof.cpp b/src/proof.cpp\nindex ed75234a5..b2b21acbb 100644\n--- a/src/proof.cpp\n+++ b/src/proof.cpp\n@@ -155,17 +155,21 @@ void Internal::check () {\n   new_proof_on_demand ();\n   if (opts.checkproof > 1) {\n     StatTracer *lratchecker = new LratChecker (this);\n+    DeferDeletePtr<LratChecker> delete_lratchecker ((LratChecker *) lratchecker);\n     LOG (\"PROOF connecting LRAT proof checker\");\n     force_lrat ();\n     frat = true;\n     proof->connect (lratchecker);\n     stat_tracers.push_back (lratchecker);\n+    delete_lratchecker.release ();\n   }\n   if (opts.checkproof == 1 || opts.checkproof == 3) {\n     StatTracer *checker = new Checker (this);\n+    DeferDeletePtr<Checker> delete_checker ((Checker *) checker);\n     LOG (\"PROOF connecting proof checker\");\n     proof->connect (checker);\n     stat_tracers.push_back (checker);\n+    delete_checker.release ();\n   }\n }\n \n@@ -338,7 +342,7 @@ void Proof::add_assumption_clause (uint64_t id, int lit,\n \n void Proof::delete_clause (Clause *c) {\n   LOG (c, \"PROOF deleting from proof\");\n-  assert (clause.empty ());\n+  clause.clear(); // Can be non-empty if an allocation fails during adding.\n   add_literals (c);\n   clause_id = c->id;\n   redundant = c->redundant;\ndiff --git a/src/solver.cpp b/src/solver.cpp\nindex 043af550c..40922efe7 100644\n--- a/src/solver.cpp\n+++ b/src/solver.cpp\n@@ -344,8 +344,10 @@ Solver::Solver () {\n   adding_constraint = false;\n   _state = INITIALIZING;\n   internal = new Internal ();\n+  DeferDeletePtr<Internal> delete_internal (internal);\n   TRACE (\"init\");\n   external = new External (internal);\n+  DeferDeletePtr<External> delete_external (external);\n   STATE (CONFIGURING);\n #ifndef NTRACING\n   if (tracing_api_calls_through_environment_variable_method)\n@@ -370,6 +372,9 @@ Solver::Solver () {\n   } else {\n     tracing_nb_lidrup_env_var_method = false;\n   }\n+\n+  delete_internal.release ();\n+  delete_external.release ();\n }\n \n Solver::~Solver () {\ndiff --git a/src/util.hpp b/src/util.hpp\nindex 2ef01940a..ae3c98ce1 100644\n--- a/src/util.hpp\n+++ b/src/util.hpp\n@@ -101,6 +101,26 @@ template <class T> void shrink_vector (std::vector<T> &v) {\n   assert (v.capacity () == v.size ()); // not guaranteed though\n }\n \n+// Clean-up class for bad_alloc error safety.\n+\n+template<typename T>\n+struct DeferDeleteArray {\n+  T* data;\n+  DeferDeleteArray(T* t): data(t) {}\n+  ~DeferDeleteArray() { delete[] data; }\n+  void release() { data = nullptr; }\n+  void free() { delete[] data; data = nullptr; }\n+};\n+\n+template<typename T>\n+struct DeferDeletePtr {\n+  T* data;\n+  DeferDeletePtr(T* t): data(t) {}\n+  ~DeferDeletePtr() { delete data; }\n+  void release() { data = nullptr; }\n+  void free() { delete data; data = nullptr; }\n+};\n+\n /*------------------------------------------------------------------------*/\n \n template <class T> inline void clear_n (T *base, size_t n) {\n\"\"\""
  },
  {
    "pr_number": 118,
    "title": "Add a github action",
    "author": "eric-wieser",
    "head_sha": "5d483ff68d0d9096e54b8da567eafe9d4eceefac",
    "base_sha": "31f9aae44947c673dc6190c9beb399acb9ffec6a",
    "head_ref": "ci",
    "base_ref": "master",
    "merge_commit_sha": "4367675099087e609d2d66375511aa36ef081d45",
    "state": "open",
    "created_at": "2024-10-17T13:27:31Z",
    "updated_at": "2024-10-31T12:23:06Z",
    "merged_at": null,
    "pr_body": "This verifies that tests pass on master and in PRs.",
    "diff": "\"\"\"diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml\nnew file mode 100644\nindex 000000000..01061fb93\n--- /dev/null\n+++ b/.github/workflows/build.yml\n@@ -0,0 +1,22 @@\n+name: Build C++\n+\n+# Controls when the action will run. Triggers the workflow on push\n+on: \n+  push:\n+  pull_request:\n+\n+jobs:\n+  build:\n+    runs-on: \"ubuntu-latest\"\n+    steps:\n+    - name: \"Check out\"\n+      uses: actions/checkout@v4\n+    - name: \"Configure\"\n+      run: |\n+        ./configure\n+    - name: \"Build\"\n+      run: |\n+        make\n+    - name: \"Test\"\n+      run: |\n+        make test\n\"\"\""
  },
  {
    "pr_number": 116,
    "title": "Typographical Fixes",
    "author": "THE-Spellchecker",
    "head_sha": "79e5ec8c0e0b0ab6e76b4abd73781a706f790c6c",
    "base_sha": "edad56f5b71ff7502a09786cb00df09c3b889317",
    "head_ref": "master",
    "base_ref": "master",
    "merge_commit_sha": "3d2aa4ca3f3af5c775abcde41a52c22d90316724",
    "state": "closed",
    "created_at": "2024-10-04T06:52:44Z",
    "updated_at": "2024-10-09T13:39:38Z",
    "merged_at": null,
    "pr_body": "Fixes various typos throughout the code\r\n![image](https://github.com/user-attachments/assets/58c2fea5-5e9f-43a5-a7f4-a7ce66f39afc)\r\n",
    "diff": "\"\"\"diff --git a/NEWS.md b/NEWS.md\nindex 462c19046..6d01d4669 100644\n--- a/NEWS.md\n+++ b/NEWS.md\n@@ -110,7 +110,7 @@ Version 1.7.3\n   on the trail.  Also works for assumptions (`--ilbassumptions`).\n \n - Reimplication (`--reimply`) fixes assignment levels of literals by\n-  \"elevating\" them (assigning a lower decision level and propating them\n+  \"elevating\" them (assigning a lower decision level and propagating them\n   out-of-order on this lower decision level).  Out-of-order assignments\n   are introduced by chronological backtracking, adding external clauses\n   during solving (e.g., by a user propagation) or simply by ILB.\n@@ -121,7 +121,7 @@ Version 1.7.3\n   API (via `connect_proof_tracer`). This feature allows to use custom\n   proof tracers to process clausal proofs on-the-fly while solving.  Both\n   proofs steps with proof antecedents (needed for instance for\n-  interpolation) as well as without (working direclty on DRAT level) are\n+  interpolation) as well as without (working directly on DRAT level) are\n   supported.\n  \n - Reworked options for proof tracing to be less confusing.  Support for\ndiff --git a/contrib/craigtracer.cpp b/contrib/craigtracer.cpp\nindex 9ff4d160a..6ded3b09e 100644\n--- a/contrib/craigtracer.cpp\n+++ b/contrib/craigtracer.cpp\n@@ -778,7 +778,7 @@ CraigTracer::create_craig_interpolant (CraigInterpolant interpolant,\n     break;\n \n   default:\n-    assert (false); // Seleted craig interpolation type not supported!\n+    assert (false); // Selected craig interpolation type not supported!\n     __builtin_unreachable ();\n   }\n \n@@ -954,7 +954,7 @@ CraigTracer::create_craig_interpolant (CraigInterpolant interpolant,\n     cnf = std::move (*std::get<0> (*maximum));\n     return std::get<1> (*maximum);\n   } else {\n-    assert (false); // Seleted craig interpolation type not supported!\n+    assert (false); // Selected craig interpolation type not supported!\n     __builtin_unreachable ();\n   }\n }\ndiff --git a/contrib/craigtracer.md b/contrib/craigtracer.md\nindex 10f1f601d..94800279f 100644\n--- a/contrib/craigtracer.md\n+++ b/contrib/craigtracer.md\n@@ -12,7 +12,7 @@ and a Tseitin transformation converts them into a Conjunctive Normal Form (CNF).\n Attach / detach the `CraigTracer` to the CaDiCaL solver via the\n `connect_proof_tracer` and `disconnect_proof_tracer` methods.\n The tracer requires antecedents. Therefore it has to be attached with `true`\n-as second argument. The partial Craig interpolant construcion has to be\n+as second argument. The partial Craig interpolant construction has to be\n configured before any clauses are added to the solver.\n \n ```cpp\ndiff --git a/src/analyze.cpp b/src/analyze.cpp\nindex 21d2a43b7..8e3402bb9 100644\n--- a/src/analyze.cpp\n+++ b/src/analyze.cpp\n@@ -1078,7 +1078,7 @@ void Internal::analyze () {\n   // up to this point lrat_chain contains the proof for current clause in\n   // reversed order. in minimize and shrink the clause is changed and\n   // therefore lrat_chain has to be extended. Unfortunately we cannot create\n-  // the chain directly during minimazation (or shrinking) but afterwards we\n+  // the chain directly during minimization (or shrinking) but afterwards we\n   // can calculate it pretty easily and even better the same algorithm works\n   // for both shrinking and minimization.\n \ndiff --git a/src/block.cpp b/src/block.cpp\nindex 00a4c76c8..6d7702f0b 100644\n--- a/src/block.cpp\n+++ b/src/block.cpp\n@@ -717,7 +717,7 @@ void Internal::block_literal (Blocker &blocker, int lit) {\n   else if (!noccs (lit)) {\n     // Rare situation, where the clause length limit was hit for 'lit' and\n     // '-lit' is skipped and then it becomes pure.  Can be ignored.  We also\n-    // so it once happing for a 'elimboundmin=-1' and zero positive and one\n+    // so it once happening for a 'elimboundmin=-1' and zero positive and one\n     // negative occurrence.\n   } else if (noccs (-lit) == 1)\n     block_literal_with_one_negative_occ (blocker, lit);\ndiff --git a/src/cadical.hpp b/src/cadical.hpp\nindex a803292b6..940bb923f 100644\n--- a/src/cadical.hpp\n+++ b/src/cadical.hpp\n@@ -377,8 +377,8 @@ class Solver {\n \n   // Mark as 'observed' those variables that are relevant to the external\n   // propagator. External propagation, clause addition during search and\n-  // notifications are all over these observed variabes.\n-  // A variable can not be observed witouth having an external propagator\n+  // notifications are all over these observed variables.\n+  // A variable can not be observed without having an external propagator\n   // connected. Observed variables are \"frozen\" internally, and so\n   // inprocessing will not consider them as candidates for elimination.\n   // An observed variable is allowed to be a fresh variable and it can be\n@@ -421,7 +421,7 @@ class Solver {\n   // Adds a literal to the constraint clause. Same functionality as 'add'\n   // but the clause only exists for the next call to solve (same lifetime as\n   // assumptions). Only one constraint may exists at a time. A new\n-  // constraint replaces the old. The main application of this functonality\n+  // constraint replaces the old. The main application of this functionality\n   // is the model checking algorithm IC3. See our FMCAD'21 paper\n   // [FroleyksBiere-FMCAD'19] for more details.\n   //\n@@ -468,7 +468,7 @@ class Solver {\n   //\n   const State &state () const { return _state; }\n \n-  // Similar to 'state ()' but using the staddard competition exit codes of\n+  // Similar to 'state ()' but using the standard competition exit codes of\n   // '10' for 'SATISFIABLE', '20' for 'UNSATISFIABLE' and '0' otherwise.\n   //\n   int status () const {\n@@ -790,7 +790,7 @@ class Solver {\n   // which will learn new clauses as explained below:\n   // In case of failed assumptions will provide a core negated\n   // as a clause through the proof tracer interface.\n-  // With a failing contraint these can be multiple clauses.\n+  // With a failing constraint these can be multiple clauses.\n   // Then it will trigger a conclude_unsat event with the id(s)\n   // of the newly learnt clauses or the id of the global conflict.\n   //\ndiff --git a/src/external.cpp b/src/external.cpp\nindex 6b9d49106..4ccc9dbe8 100644\n--- a/src/external.cpp\n+++ b/src/external.cpp\n@@ -779,7 +779,7 @@ bool External::traverse_all_non_frozen_units_as_witnesses (\n       continue;\n     int unit = tmp < 0 ? -idx : idx;\n     const int ilit = e2i[idx] * (tmp < 0 ? -1 : 1);\n-    // heurstically add + max_var to the id to avoid reusing ids\n+    // heuristically add + max_var to the id to avoid reusing ids\n     const uint64_t id = internal->opts.lrat\n                             ? internal->unit_clauses[internal->vlit (ilit)]\n                             : 1;\ndiff --git a/src/external.hpp b/src/external.hpp\nindex ff412f2e6..466273913 100644\n--- a/src/external.hpp\n+++ b/src/external.hpp\n@@ -260,7 +260,7 @@ struct External {\n \n   void reset_assumptions ();\n \n-  // similarily to 'failed', 'conclude' needs to know about failing\n+  // similarly to 'failed', 'conclude' needs to know about failing\n   // assumptions and therefore needs to be reset when leaving the\n   // 'UNSATISFIED' state.\n   //\ndiff --git a/src/external_propagate.cpp b/src/external_propagate.cpp\nindex 57ace71d3..6251f8267 100644\n--- a/src/external_propagate.cpp\n+++ b/src/external_propagate.cpp\n@@ -169,7 +169,7 @@ bool Internal::external_propagate () {\n           break;\n         notify_assignments ();\n       } else if (tmp < 0) {\n-        LOG (\"External propgation of %d is falsified under current trail\",\n+        LOG (\"External propagation of %d is falsified under current trail\",\n              ilit);\n         stats.ext_prop.eprop_conf++;\n         int level_before = level;\n@@ -308,13 +308,13 @@ void Internal::move_literal_to_watch (bool other_watch) {\n \n /*----------------------------------------------------------------------------*/\n //\n-// Reads out from the external propagator the lemma/proapgation reason\n+// Reads out from the external propagator the lemma/propagation reason\n // clause literal by literal. In case propagated_elit is 0, it is about an\n // external clause via 'cb_add_external_clause_lit'. Otherwise, it is about\n // learning the reason of 'propagated_elit' via 'cb_add_reason_clause_lit'.\n // The learned clause is simplified by the current root-level assignment\n // (i.e. root-level falsified literals are removed, root satisfied clauses\n-// are skipped). Duplicate literals are removed, tauotologies are detected\n+// are skipped). Duplicate literals are removed, tautologies are detected\n // and skipped. It always adds the original (un-simplified) external clause\n // to the proof as an input clause and\n // the simplified version of it (except exceptions below) as a derived\n@@ -413,7 +413,7 @@ void Internal::explain_reason (int ilit, Clause *reason, int &open) {\n // clause learning must check every clause on every level that is backward\n // reachable from the conflicting clause to guarantee that the assignment\n // levels of the variables are accurate. So this explanation round is\n-// separated from the conflict analysis, thereby guranteeing that the flags\n+// separated from the conflict analysis, thereby guaranteeing that the flags\n // and datastructures can be properly used later.\n //\n // This function must be called before the conflict analysis, in order to\n@@ -538,7 +538,7 @@ Clause *Internal::wrapped_learn_external_reason_clause (int ilit) {\n     clause.clear ();\n     res = learn_external_reason_clause (ilit, 0, true);\n     // The learn_external_reason clause can leave a literal in clause when\n-    // there there is a falsified elit arg. Here it is not allowed to\n+    // there is a falsified elit arg. Here it is not allowed to\n     // happen.\n     assert (clause.empty ());\n \ndiff --git a/src/file.cpp b/src/file.cpp\nindex 2726e6343..c6ff4bb89 100644\n--- a/src/file.cpp\n+++ b/src/file.cpp\n@@ -288,7 +288,7 @@ FILE *File::write_pipe (Internal *internal, const char *command,\n     ::close (pipe_fds[1]);\n     ::close (0);\n     ::close (1);\n-    if (command[0] == '7') // Surpress '7z' verbose output on 'stderr'.\n+    if (command[0] == '7') // Suppress '7z' verbose output on 'stderr'.\n       ::close (2);\n     int in = dup (pipe_fds[0]);\n     assert (in == 0), (void) in;\ndiff --git a/src/gates.cpp b/src/gates.cpp\nindex 74cd20996..e39b1d817 100644\n--- a/src/gates.cpp\n+++ b/src/gates.cpp\n@@ -80,7 +80,7 @@ int Internal::second_literal_in_binary_clause_lrat (Clause *c, int first) {\n   return second;\n }\n \n-// I needed to find the second clause for hyper unary resultion to build\n+// I needed to find the second clause for hyper unary resolution to build\n // LRAT this is not efficient but I could not find a better way then just\n // finding the corresponding clause in all possible clauses\n //\ndiff --git a/src/instantiate.cpp b/src/instantiate.cpp\nindex 05371d23c..1f1b09005 100644\n--- a/src/instantiate.cpp\n+++ b/src/instantiate.cpp\n@@ -72,7 +72,7 @@ inline void Internal::inst_assign (int lit) {\n \n // Conflict analysis is only needed to do valid resolution proofs.\n // We remember propagated clauses in order of assignment (in inst_chain)\n-// which allows us to do a variant of conflict analysis if the instatiation\n+// which allows us to do a variant of conflict analysis if the instantiation\n // attempt succeeds.\n //\n bool Internal::inst_propagate () { // Adapted from 'propagate'.\ndiff --git a/src/internal.hpp b/src/internal.hpp\nindex 357632ccb..753e694c7 100644\n--- a/src/internal.hpp\n+++ b/src/internal.hpp\n@@ -258,7 +258,7 @@ struct Internal {\n   Proof *proof;             // abstraction layer between solver and tracers\n   LratBuilder *lratbuilder; // special proof tracer\n   vector<Tracer *>\n-      tracers; // proof tracing objects (ie interpolant calulator)\n+      tracers; // proof tracing objects (ie interpolant calculator)\n   vector<FileTracer *>\n       file_tracers; // file proof tracers (ie DRAT, LRAT...)\n   vector<StatTracer *> stat_tracers; // checkers\n@@ -426,7 +426,7 @@ struct Internal {\n   }\n \n   // Use only bits 6 and 7 to store the sign or zero.  The remaining\n-  // bits can be use as additional flags.\n+  // bits can be used as additional flags.\n   //\n   signed char marked67 (int lit) const {\n     signed char res = marks[vidx (lit)] >> 6;\n@@ -1116,7 +1116,7 @@ struct Internal {\n   //\n   void constrain (int); // Add literal to constraint.\n   bool\n-  failed_constraint ();     // Was constraint used to proof unsatisfiablity?\n+  failed_constraint ();     // Was constraint used to proof unsatisfiability?\n   void reset_constraint (); // Reset after 'solve' call.\n \n   // Forcing decision variables to a certain phase.\n@@ -1190,7 +1190,7 @@ struct Internal {\n   // local search and searching for lucky phases, which in full solving\n   // mode except for the last are usually optional and then followed by\n   // the main CDCL search loop with inprocessing.  If only preprocessing\n-  // is requested from 'External::simplifiy' only preprocessing is called\n+  // is requested from 'External::simplify' only preprocessing is called\n   // though. This is all orchestrated by the 'solve' function.\n   //\n   int already_solved ();\ndiff --git a/src/lratbuilder.cpp b/src/lratbuilder.cpp\nindex f2c8319c3..5eca22ebc 100644\n--- a/src/lratbuilder.cpp\n+++ b/src/lratbuilder.cpp\n@@ -352,7 +352,7 @@ uint64_t LratBuilder::reduce_hash (uint64_t hash, uint64_t size) {\n uint64_t LratBuilder::compute_hash (const uint64_t id) {\n   assert (id > 0);\n   unsigned j = id % num_nonces;             // dont know if this is a good\n-  uint64_t tmp = nonces[j] * (uint64_t) id; // hash funktion or if it is\n+  uint64_t tmp = nonces[j] * (uint64_t) id; // hash function or if it is\n   return last_hash = tmp; // even better than just using id\n }\n \ndiff --git a/src/lratchecker.cpp b/src/lratchecker.cpp\nindex 7702bf8f1..ed7e6cba8 100644\n--- a/src/lratchecker.cpp\n+++ b/src/lratchecker.cpp\n@@ -200,7 +200,7 @@ uint64_t LratChecker::reduce_hash (uint64_t hash, uint64_t size) {\n uint64_t LratChecker::compute_hash (const uint64_t id) {\n   assert (id > 0);\n   unsigned j = id % num_nonces;             // dont know if this is a good\n-  uint64_t tmp = nonces[j] * (uint64_t) id; // hash funktion or if it is\n+  uint64_t tmp = nonces[j] * (uint64_t) id; // hash function or if it is\n   return last_hash = tmp; // even better than just using id\n }\n \n@@ -349,7 +349,7 @@ bool LratChecker::check (vector<uint64_t> proof_chain) {\n       break;\n     }\n     if (!unit) {\n-      LOG (\"LRAT CHECKER check succeded, clause falsified %\" PRIu64, id);\n+      LOG (\"LRAT CHECKER check succeeded, clause falsified %\" PRIu64, id);\n       checking = true;\n       break;\n     }\ndiff --git a/src/mobical.cpp b/src/mobical.cpp\nindex 386f67eee..377141c46 100644\n--- a/src/mobical.cpp\n+++ b/src/mobical.cpp\n@@ -506,7 +506,7 @@ class MockPropagator : public ExternalPropagator {\n \n     if (added_lemma_count > lemma_per_cb) {\n       added_lemma_count = 0;\n-      MLOGC (\"false (lemma per CB treshold reached).\" << std::endl);\n+      MLOGC (\"false (lemma per CB threshold reached).\" << std::endl);\n       return false;\n     }\n \n@@ -870,7 +870,7 @@ class Mobical : public Handler {\n   /*----------------------------------------------------------------------*/\n \n   MockPropagator\n-      *mock_pointer; // to be able to clean up withouth disconnect\n+      *mock_pointer; // to be able to clean up without disconnect\n \n public:\n   Mobical ();\n@@ -3380,7 +3380,7 @@ static bool is_valid_char (int ch) {\n     return true;\n \n   // For now proof file paths can only have these additional characters.\n-  // We should probably have an escape mechamism (quotes) for paths.\n+  // We should probably have an escape mechanism (quotes) for paths.\n \n   if (ch == '_' || ch == '/' || ch == '.' || ('A' <= ch && ch <= 'Z'))\n     return true;\ndiff --git a/src/options.hpp b/src/options.hpp\nindex 1b2f156a9..daff2c44e 100644\n--- a/src/options.hpp\n+++ b/src/options.hpp\n@@ -297,7 +297,7 @@ class Options {\n #undef OPTION\n \n   // It would be more elegant to use an anonymous 'struct' of the actual\n-  // option values overlayed with an 'int values[number_of_options]' array\n+  // option values overlaid with an 'int values[number_of_options]' array\n   // but that is not proper ISO C++ and produces a warning.  Instead we use\n   // the following construction which relies on '__start_of_options__' and\n   // that the following options are really allocated directly after it.\ndiff --git a/src/probe.cpp b/src/probe.cpp\nindex 855bef46f..22d8f85b6 100644\n--- a/src/probe.cpp\n+++ b/src/probe.cpp\n@@ -4,7 +4,7 @@ namespace CaDiCaL {\n \n /*------------------------------------------------------------------------*/\n \n-// Failed literal probing uses it's own propagation and assignment\n+// Failed literal probing uses its own propagation and assignment\n // functions.  It further provides on-the-fly generation of hyper binary\n // resolvents but only probes on roots of the binary implication graph.  The\n // search for failed literals is limited, but untried roots are kept until\ndiff --git a/src/propagate.cpp b/src/propagate.cpp\nindex 8d1b35523..780fd7b16 100644\n--- a/src/propagate.cpp\n+++ b/src/propagate.cpp\n@@ -492,7 +492,7 @@ void Internal::propergate () {\n   while (propergated != trail.size ()) {\n \n     const int lit = -trail[propergated++];\n-    LOG (\"propergating %d\", -lit);\n+    LOG (\"propagating %d\", -lit);\n     Watches &ws = watches (lit);\n \n     const const_watch_iterator eow = ws.end ();\ndiff --git a/src/shrink.cpp b/src/shrink.cpp\nindex 2e7c0274b..df2b90bc8 100644\n--- a/src/shrink.cpp\n+++ b/src/shrink.cpp\n@@ -362,7 +362,7 @@ std::vector<int>::reverse_iterator Internal::minimize_and_shrink_block (\n   unsigned open = 0;\n   unsigned max_trail;\n \n-  // find begining of block;\n+  // find beginning of block;\n   std::vector<int>::reverse_iterator rend_block;\n   {\n     assert (rbegin_block <= clause.rend ());\ndiff --git a/src/subsume.cpp b/src/subsume.cpp\nindex c1d5286ae..e12b4560b 100644\n--- a/src/subsume.cpp\n+++ b/src/subsume.cpp\n@@ -216,7 +216,7 @@ inline int Internal::try_to_subsume_clause (Clause *c,\n \n     // Only clauses which have a variable which has recently been added are\n     // checked for being subsumed.  The idea is that all these newly added\n-    // clauses are candidates for subsubming the clause.  Then we also only\n+    // clauses are candidates for subsuming the clause.  Then we also only\n     // need to check occurrences of these variables.  The occurrence lists\n     // of other literal do not have to be checked.\n     //\ndiff --git a/src/tracer.hpp b/src/tracer.hpp\nindex 68ac58f15..2aa343f5f 100644\n--- a/src/tracer.hpp\n+++ b/src/tracer.hpp\n@@ -27,7 +27,7 @@ class Tracer {\n   /*------------------------------------------------------------------------*/\n \n   // Notify the tracer that a original clause has been added.\n-  // Includes ID and wether the clause is redundant or irredundant\n+  // Includes ID and whether the clause is redundant or irredundant\n   // Arguments: ID, redundant, clause, restored\n   //\n   virtual void add_original_clause (uint64_t, bool,\n@@ -35,7 +35,7 @@ class Tracer {\n                                     bool = false) {}\n \n   // Notify the observer that a new clause has been derived.\n-  // Includes ID and wether the clause is redundant or irredundant\n+  // Includes ID and whether the clause is redundant or irredundant\n   // If antecedents are derived they will be included here.\n   // Arguments: ID, redundant, clause, antecedents\n   //\ndiff --git a/src/veripbtracer.cpp b/src/veripbtracer.cpp\nindex 0a43d8bc9..91b62b3b9 100644\n--- a/src/veripbtracer.cpp\n+++ b/src/veripbtracer.cpp\n@@ -102,7 +102,7 @@ uint64_t VeripbTracer::reduce_hash (uint64_t hash, uint64_t size) {\n uint64_t VeripbTracer::compute_hash (const uint64_t id) {\n   assert (id > 0);\n   unsigned j = id % num_nonces;             // dont know if this is a good\n-  uint64_t tmp = nonces[j] * (uint64_t) id; // hash funktion or if it is\n+  uint64_t tmp = nonces[j] * (uint64_t) id; // hash function or if it is\n   return last_hash = tmp; // even better than just using id\n }\n \ndiff --git a/src/vivify.cpp b/src/vivify.cpp\nindex e9843d142..e47e33456 100644\n--- a/src/vivify.cpp\n+++ b/src/vivify.cpp\n@@ -1067,7 +1067,7 @@ void Internal::vivify_build_lrat (\n       Var &v = var (other);\n       Flags &f = flags (other);\n       if (f.seen)\n-        continue; // we would lik // assert (val (other) < 0);e to assert\n+        continue; // we would like // assert (val (other) < 0);e to assert\n                   // this:\n       // analyzed.push_back (other); // assert (val (other) < 0);\n       // f.seen = true;              // but we cannot because we have\ndiff --git a/test/cnf/drat-trim.c b/test/cnf/drat-trim.c\nindex 8949a2585..b17e43adf 100644\n--- a/test/cnf/drat-trim.c\n+++ b/test/cnf/drat-trim.c\n@@ -1271,7 +1271,7 @@ int verify (struct solver *S, int begin, int end) {\n           (lemmas - S->DB)) {         // what is this check?\n         if (S->mode != FORWARD_SAT) { // ignore pseudo unit clause deletion\n           if (S->verb) {\n-            printf (\"c ignoring deletion intruction %li: \",\n+            printf (\"c ignoring deletion instruction %li: \",\n                     (lemmas - S->DB));\n             printClause (lemmas);\n           }\n@@ -1643,7 +1643,7 @@ int parse (struct solver *S) {\n     if (tmp > 0 && tmp != EOF)\n       break;\n     tmp = fscanf (S->inputFile, \"%*s\\n\");\n-  }                               // In case a commment line was found\n+  }                               // In case a comment line was found\n   while (tmp != 2 && tmp != EOF); // Skip it and read next line\n   int nZeros = S->nClauses;\n \n@@ -2065,7 +2065,7 @@ void printHelp () {\n   printf (\"  -r TRACE    resolution graph in the TRACE file (TRACECHECK \"\n           \"format)\\n\\n\");\n   printf (\"  -t <lim>    time limit in seconds (default %i)\\n\", TIMEOUT);\n-  printf (\"  -u          default unit propatation (i.e., no core-first)\\n\");\n+  printf (\"  -u          default unit propagation (i.e., no core-first)\\n\");\n   printf (\"  -f          forward mode for UNSAT\\n\");\n   printf (\"  -v          more verbose output\\n\");\n   printf (\"  -b          show progress bar\\n\");\ndiff --git a/test/cnf/lrat-trim.c b/test/cnf/lrat-trim.c\nindex be1f5bec0..44fb7ce4e 100644\n--- a/test/cnf/lrat-trim.c\n+++ b/test/cnf/lrat-trim.c\n@@ -525,7 +525,7 @@ static size_t fill_buffer () {\n \n // These three functions were not inlined with gcc-11 but should be despite\n // having declared them as 'inline' and thus we use this 'always_inline'\n-// attribute which seems to succeed to force inlining.  Havin them inlined\n+// attribute which seems to succeed to force inlining.  Having them inlined\n // really gives a performance boost.\n \n static inline int read_buffer (void) __attribute__ ((always_inline));\n\"\"\""
  },
  {
    "pr_number": 115,
    "title": "Add missing #include <netinet/in.h>",
    "author": "yurivict",
    "head_sha": "27ffbd01f401831a0e0b2c84b7b1477cb4b5c15d",
    "base_sha": "edad56f5b71ff7502a09786cb00df09c3b889317",
    "head_ref": "fixes",
    "base_ref": "master",
    "merge_commit_sha": "bea974c0545a13b4113f4602539992f556594540",
    "state": "closed",
    "created_at": "2024-10-03T00:44:18Z",
    "updated_at": "2024-10-03T15:06:40Z",
    "merged_at": null,
    "pr_body": "This fixes this build failure:\r\n```\r\nsrc/random.cpp:112:48: error: invalid application of 'sizeof' to an incomplete type 'struct sockaddr_in'\r\n  112 |         const int size = (family == AF_INET) ? sizeof (struct sockaddr_in)\r\n      |                                                ^      ~~~~~~~~~~~~~~~~~~~~\r\n```\r\n\r\nFreeBSD 14.1\r\n",
    "diff": "\"\"\"diff --git a/src/random.cpp b/src/random.cpp\nindex c87170bcc..d8a6684f7 100644\n--- a/src/random.cpp\n+++ b/src/random.cpp\n@@ -86,6 +86,7 @@ extern \"C\" {\n #include <stdio.h>\n #include <stdlib.h>\n #include <sys/socket.h>\n+#include <netinet/in.h>\n }\n \n #endif\n\"\"\""
  },
  {
    "pr_number": 114,
    "title": "Add CMake configuration",
    "author": "uulm-janbaudisch",
    "head_sha": "510e0410b1a1434d53ed0769f3ecd88534791ba8",
    "base_sha": "edad56f5b71ff7502a09786cb00df09c3b889317",
    "head_ref": "cmake",
    "base_ref": "master",
    "merge_commit_sha": "c3dd32d8943b57cb6bbae3cd11f5ed0c9556ad19",
    "state": "closed",
    "created_at": "2024-09-29T10:03:43Z",
    "updated_at": "2024-10-09T06:40:19Z",
    "merged_at": null,
    "pr_body": "I saw that you thought about adding CMake support but wanted to support all features from the current configuration script.\r\n\r\nThis could be used as a starting point for that. Some options like release/debug build or compiler flags are possible with CMake without any further customization.\r\n\r\nIn case you do not want to merge this in the current state, what should be added at a minimum?",
    "diff": "\"\"\"diff --git a/CMakeLists.txt b/CMakeLists.txt\nnew file mode 100644\nindex 000000000..72a37b2b6\n--- /dev/null\n+++ b/CMakeLists.txt\n@@ -0,0 +1,106 @@\n+cmake_minimum_required(VERSION 3.27)\n+\n+project(CaDiCaL VERSION 2.0.0 LANGUAGES CXX)\n+\n+add_compile_definitions(NBUILD)\n+\n+add_library(libcadical\n+    src/analyze.cpp\n+    src/arena.cpp\n+    src/assume.cpp\n+    src/averages.cpp\n+    src/backtrack.cpp\n+    src/backward.cpp\n+    src/bins.cpp\n+    src/block.cpp\n+    src/ccadical.cpp\n+    src/checker.cpp\n+    src/clause.cpp\n+    src/collect.cpp\n+    src/compact.cpp\n+    src/condition.cpp\n+    src/config.cpp\n+    src/constrain.cpp\n+    src/contract.cpp\n+    src/cover.cpp\n+    src/decide.cpp\n+    src/decompose.cpp\n+    src/deduplicate.cpp\n+    src/drattracer.cpp\n+    src/elim.cpp\n+    src/ema.cpp\n+    src/extend.cpp\n+    src/external.cpp\n+    src/external_propagate.cpp\n+    src/file.cpp\n+    src/flags.cpp\n+    src/flip.cpp\n+    src/format.cpp\n+    src/frattracer.cpp\n+    src/gates.cpp\n+    src/idruptracer.cpp\n+    src/instantiate.cpp\n+    src/internal.cpp\n+    src/ipasir.cpp\n+    src/lidruptracer.cpp\n+    src/limit.cpp\n+    src/logging.cpp\n+    src/lookahead.cpp\n+    src/lratbuilder.cpp\n+    src/lratchecker.cpp\n+    src/lrattracer.cpp\n+    src/lucky.cpp\n+    src/message.cpp\n+    src/minimize.cpp\n+    src/occs.cpp\n+    src/options.cpp\n+    src/parse.cpp\n+    src/phases.cpp\n+    src/probe.cpp\n+    src/profile.cpp\n+    src/proof.cpp\n+    src/propagate.cpp\n+    src/queue.cpp\n+    src/random.cpp\n+    src/reap.cpp\n+    src/reduce.cpp\n+    src/rephase.cpp\n+    src/report.cpp\n+    src/resources.cpp\n+    src/restart.cpp\n+    src/restore.cpp\n+    src/score.cpp\n+    src/shrink.cpp\n+    src/signal.cpp\n+    src/solution.cpp\n+    src/solver.cpp\n+    src/stats.cpp\n+    src/subsume.cpp\n+    src/terminal.cpp\n+    src/ternary.cpp\n+    src/transred.cpp\n+    src/util.cpp\n+    src/var.cpp\n+    src/veripbtracer.cpp\n+    src/version.cpp\n+    src/vivify.cpp\n+    src/walk.cpp\n+    src/watch.cpp\n+)\n+\n+set_target_properties(libcadical PROPERTIES\n+    OUTPUT_NAME \"cadical\"\n+    PUBLIC_HEADER src/cadical.hpp\n+)\n+\n+add_library(cadicraig contrib/craigtracer.cpp)\n+target_include_directories(cadicraig PRIVATE src)\n+set_target_properties(cadicraig PROPERTIES PUBLIC_HEADER contrib/craigtracer.hpp)\n+\n+add_executable(cadical src/cadical.cpp)\n+add_executable(mobical src/mobical.cpp)\n+\n+target_link_libraries(cadical libcadical)\n+target_link_libraries(mobical libcadical)\n+\n+install(TARGETS libcadical cadicraig cadical mobical)\n\"\"\""
  },
  {
    "pr_number": 113,
    "title": "Add missing `#include` to radix.hpp",
    "author": "eric-wieser",
    "head_sha": "c355a7dd012b6be4080d9e64ce73e8d74822bb71",
    "base_sha": "edad56f5b71ff7502a09786cb00df09c3b889317",
    "head_ref": "patch-2",
    "base_ref": "master",
    "merge_commit_sha": "cd9713d9dba97fbabb86f82a98964a8e9066adae",
    "state": "closed",
    "created_at": "2024-09-27T12:40:20Z",
    "updated_at": "2024-11-12T15:24:42Z",
    "merged_at": null,
    "pr_body": "`std::vector` is used in this header, but `<vector>` is never imported.",
    "diff": "\"\"\"diff --git a/src/radix.hpp b/src/radix.hpp\nindex 4f1c263f6..a12c94231 100644\n--- a/src/radix.hpp\n+++ b/src/radix.hpp\n@@ -4,6 +4,7 @@\n #include <cassert>\n #include <cstring>\n #include <iterator>\n+#include <vector>\n \n namespace CaDiCaL {\n \n\"\"\""
  },
  {
    "pr_number": 111,
    "title": "modify the `LC_TIME` from `en_US` to `C`",
    "author": "Neutron3529",
    "head_sha": "2540923a613ce46c884f8224a57ab3e5c531e9b4",
    "base_sha": "edad56f5b71ff7502a09786cb00df09c3b889317",
    "head_ref": "patch-1",
    "base_ref": "master",
    "merge_commit_sha": "01be43250dfb96aa6eefc7adce9dd9fa4ed59a2c",
    "state": "closed",
    "created_at": "2024-08-06T03:33:16Z",
    "updated_at": "2024-11-13T06:30:10Z",
    "merged_at": null,
    "pr_body": "Modify the `LC_TIME` from `en_US` (which might not exists, since it is `en_US.UTF8` that exists.) to `C`.\r\n\r\nAccording to [GNU's documents](https://www.gnu.org/software/gettext/manual/html_node/The-LANGUAGE-variable.html#The-LANGUAGE-variable), `LC_TIME=C` should always work, which seems better than `en_US`.",
    "diff": "\"\"\"diff --git a/scripts/make-build-header.sh b/scripts/make-build-header.sh\nindex 4ff7a9d04..be223c58f 100755\n--- a/scripts/make-build-header.sh\n+++ b/scripts/make-build-header.sh\n@@ -81,7 +81,7 @@ fi\n #--------------------------------------------------------------------------#\n # Use time of executing this script at build time.\n #\n-LC_TIME=\"en_US\" # Avoid umlaut in 'DATE'.\n+LC_TIME=\"C\" # Avoid umlaut in 'DATE'.\n export LC_TIME\n # The time and date we compiled the CaDiCaL library.\n DATE=\"`date 2>/dev/null|sed -e 's,  *, ,g'`\"\n\"\"\""
  },
  {
    "pr_number": 104,
    "title": "Update internal.cpp",
    "author": "xtrm0",
    "head_sha": "96bdf4348d764c7bbb61935c6c365f7fdab60c97",
    "base_sha": "2df7b7fed0f9c522fd4cdf6e88cecad4cac8a2df",
    "head_ref": "patch-1",
    "base_ref": "master",
    "merge_commit_sha": "045df3e76766c69d7b72d38b3f3ce77f9ecaf68b",
    "state": "closed",
    "created_at": "2024-06-27T18:11:52Z",
    "updated_at": "2024-10-09T07:56:02Z",
    "merged_at": null,
    "pr_body": "Fix missing parentesis in if statement.\r\n(I think this wasn't being triggered because this function was only being called when vsize=0)",
    "diff": "\"\"\"diff --git a/src/internal.cpp b/src/internal.cpp\nindex d524edd47..9b4a5fedc 100644\n--- a/src/internal.cpp\n+++ b/src/internal.cpp\n@@ -94,10 +94,11 @@ void Internal::enlarge_vals (size_t new_vsize) {\n   ignore_clang_analyze_memory_leak_warning = new_vals;\n   new_vals += new_vsize;\n \n-  if (vals)\n+  if (vals) {\n     memcpy (new_vals - max_var, vals - max_var, 2u * max_var + 1u);\n-  vals -= vsize;\n-  delete[] vals;\n+    vals -= vsize;\n+    delete[] vals;\n+  }\n   vals = new_vals;\n }\n \n\"\"\""
  },
  {
    "pr_number": 100,
    "title": "Also add a dynamic library",
    "author": "msoos",
    "head_sha": "fcb865786b524917aa9d3df8745aca66716794bf",
    "base_sha": "2df7b7fed0f9c522fd4cdf6e88cecad4cac8a2df",
    "head_ref": "add_dynamic_lib",
    "base_ref": "master",
    "merge_commit_sha": "4ee96fb15976dcc9086c50afdd09fcf6c4d81f37",
    "state": "closed",
    "created_at": "2024-06-03T01:51:28Z",
    "updated_at": "2024-10-10T07:23:22Z",
    "merged_at": null,
    "pr_body": "This also builds a dynamic library, besides a static one. I have  a feeling it may have been purposefully left out, but I need it, and I think it may not be too harmful to do it? Just a suggestion.\r\n\r\nMate",
    "diff": "\"\"\"diff --git a/makefile.in b/makefile.in\nindex 291cb3e34..d179f5914 100644\n--- a/makefile.in\n+++ b/makefile.in\n@@ -34,7 +34,7 @@ COMPILE=$(CXX) $(CXXFLAGS) -I$(DIR) -I$(ROOT)/src\n \n #--------------------------------------------------------------------------#\n \n-all: libcadical.a cadical mobical\n+all: libcadical.so libcadical.a cadical mobical\n \n #--------------------------------------------------------------------------#\n \n@@ -62,6 +62,9 @@ mobical: src/mobical.o libcadical.a makefile $(LIBS)\n libcadical.a: $(OBJ_SOLVER) $(OBJ_CONTRIB) makefile\n \tar rc $@ $(OBJ_SOLVER) $(OBJ_CONTRIB)\n \n+libcadical.so: $(OBJ_SOLVER) $(OBJ_CONTRIB) $(LIBS) makefile\n+\t$(COMPILE) -shared -o $@ $(OBJ_SOLVER) $(OBJ_CONTRIB) $(LIBS)\n+\n #--------------------------------------------------------------------------#\n \n # Note that 'build.hpp' is generated and resides in the build directory.\n\"\"\""
  },
  {
    "pr_number": 99,
    "title": "Added documentation of incremental Craig tracer use",
    "author": "TobiasFaller",
    "head_sha": "1739b5964519dc2030725651fd16823543f2ef7d",
    "base_sha": "266c004b006f8d93f06f42989a063722c790d1a2",
    "head_ref": "feature-craig-tracer-doc-incremental",
    "base_ref": "development",
    "merge_commit_sha": "37f6ddda0bcb1324ae2a44a4a70d34009140c2a2",
    "state": "closed",
    "created_at": "2024-05-17T10:59:46Z",
    "updated_at": "2024-06-18T16:41:27Z",
    "merged_at": "2024-06-18T16:41:27Z",
    "pr_body": null,
    "diff": "\"\"\"diff --git a/contrib/craigtracer.md b/contrib/craigtracer.md\nindex 10f1f601d..060f0792d 100644\n--- a/contrib/craigtracer.md\n+++ b/contrib/craigtracer.md\n@@ -175,3 +175,39 @@ if (solver.solve () == CaDiCaL::Status::UNSATISFIABLE) {\n \n solver.disconnect_proof_tracer (&tracer);\n ```\n+\n+## Incremental solving with interpolation\n+\n+The Craig tracer supports handling assumptions and constraints.\n+Assumptions are treated like equivalent temporary unit clauses with a\n+clause label according to the variable label (`label_variable`).\n+Global variables are handled like a B_CLAUSE.\n+\n+- Assuming a `A_LOCAL` variable is equivalent to a temporary `A_CLAUSE` clause.\n+- Assuming a `B_LOCAL` variable is equivalent to a temporary `B_CLAUSE` clause.\n+- Assuming a `GLOBAL` variable is equivalent to a temporary `B_CLAUSE` clause.\n+\n+The constraint is treated as a temporary clause.\n+It has to be explicitly labeled by calling `label_constraint`.\n+\n+```cpp\n+CaDiCaL::Solver solver;\n+CaDiCraig::CraigTracer tracer;\n+solver.connect_proof_tracer (&tracer, true);\n+tracer.set_craig_construction (...);\n+\n+tracer.label_variable (1, CaDiCraig::CraigVarType::A_LOCAL);\n+tracer.label_variable (2, CaDiCraig::CraigVarType::GLOBAL);\n+solver.assume (-1);\n+solver.assume (2);\n+\n+tracer.label_constraint (CaDiCraig::CraigClauseType::A_CLAUSE);\n+solver.constrain (1);\n+solver.constrain (-2);\n+solver.constrain (0);\n+\n+assert (solver.solve () == CaDiCaL::Status::UNSATISFIABLE);\n+tracer.create_craig_interpolant (...);\n+\n+solver.disconnect_proof_tracer (&tracer);\n+```\n\\ No newline at end of file\n\"\"\""
  },
  {
    "pr_number": 98,
    "title": "Fixed issue where Craig tracer handled restored clauses incorrectly",
    "author": "TobiasFaller",
    "head_sha": "ae97b2f166b0c1fa05f38ea599fe1571c15a60ec",
    "base_sha": "81d6cf7184b3dcecd3f34d2a53ed19521285153b",
    "head_ref": "fix-craig-tracer-fix-restore",
    "base_ref": "development",
    "merge_commit_sha": "c506340476ae51075ebdf6dc8081e27de96e4c13",
    "state": "closed",
    "created_at": "2024-05-03T16:23:10Z",
    "updated_at": "2024-05-07T14:28:11Z",
    "merged_at": "2024-05-07T14:28:11Z",
    "pr_body": "- Fixed code where previously restored clauses where assumed to be originally added clauses",
    "diff": "\"\"\"diff --git a/contrib/craigtracer.cpp b/contrib/craigtracer.cpp\nindex 9ff4d160a..821bbcee3 100644\n--- a/contrib/craigtracer.cpp\n+++ b/contrib/craigtracer.cpp\n@@ -34,7 +34,9 @@ class AigEdge {\n   bool operator== (const AigEdge &other) const {\n     return index == other.index;\n   }\n-  bool operator<(const AigEdge &other) const { return index < other.index; }\n+  bool operator< (const AigEdge &other) const {\n+    return index < other.index;\n+  }\n   bool operator> (const AigEdge &other) const {\n     return index > other.index;\n   }\n@@ -332,7 +334,7 @@ struct CraigData {\n \n CraigTracer::CraigTracer ()\n     : CaDiCaL::Tracer (), marked_history (), marked_lits (),\n-      craig_clause_current_id (1), craig_clause_ids (), craig_var_labels (),\n+      craig_clause_current_id (1), craig_var_labels (),\n       craig_clause_labels (),\n       craig_constraint_label (CraigClauseType::L_CLAUSE), craig_clauses (),\n       craig_interpolants (), craig_construction (CraigConstruction::NONE),\n@@ -341,8 +343,9 @@ CraigTracer::CraigTracer ()\n       craig_aig_dual_asym (new Aig ()) {}\n \n CraigTracer::~CraigTracer () {\n-  for (auto it : craig_interpolants)\n-    delete it.second;\n+  for (auto *partial_interpolant : craig_interpolants)\n+    if (partial_interpolant)\n+      delete partial_interpolant;\n   if (craig_interpolant)\n     delete craig_interpolant;\n \n@@ -366,13 +369,13 @@ bool CraigTracer::has_craig_interpolant () {\n \n void CraigTracer::label_variable (int id, CraigVarType variable_type) {\n   assert (id > 0);\n-  craig_var_labels[id] = variable_type;\n-  marked_lits[id] = 0;\n+  craig_var_labels.insert_or_assign (id, variable_type);\n+  marked_lits.insert_or_assign (id, 0);\n }\n \n void CraigTracer::label_clause (int id, CraigClauseType clause_type) {\n   assert (id > 0);\n-  craig_clause_labels[id] = clause_type;\n+  craig_clause_labels.insert_or_assign (id, clause_type);\n }\n \n void CraigTracer::label_constraint (CraigClauseType clause_type) {\n@@ -385,26 +388,25 @@ void CraigTracer::add_original_clause (uint64_t id, bool redundant,\n   assert (id > 0);\n   (void) redundant;\n \n-  if (!restore) {\n-    craig_clause_ids[id] = craig_clause_current_id++;\n+  if (restore) {\n+    craig_clauses[id - 1] = c;\n+    return;\n   }\n \n-  int original_id = craig_clause_ids[id];\n-\n-#ifndef NDEBUG\n+  int original_id = craig_clause_current_id++;\n   assert (craig_clause_labels.find (original_id) !=\n           craig_clause_labels.end ());\n   for (auto &l : c) {\n     assert (craig_var_labels.find (std::abs (l)) !=\n             craig_var_labels.end ());\n   }\n-#endif\n \n-  auto clause_label = craig_clause_labels[original_id];\n+  auto clause_label = craig_clause_labels.find (original_id)->second;\n   auto *interpolant = create_interpolant_for_clause (c, clause_label);\n \n-  craig_clauses[id] = c;\n-  craig_interpolants[id] = interpolant;\n+  assert (craig_clauses.size () == id - 1);\n+  craig_clauses.push_back (c);\n+  craig_interpolants.push_back (interpolant);\n }\n \n void CraigTracer::add_derived_clause (\n@@ -413,21 +415,19 @@ void CraigTracer::add_derived_clause (\n   assert (proof_chain.size () >= 1);\n   (void) redundant;\n \n-#ifndef NDEBUG\n   for (auto &clause : proof_chain)\n-    assert (craig_interpolants.find (clause) != craig_interpolants.end ());\n-#endif\n+    assert (craig_interpolants[clause - 1] != nullptr);\n \n   // Mark literals of conflicting clause.\n-  for (auto &l : craig_clauses[proof_chain.back ()])\n+  for (auto &l : craig_clauses[proof_chain.back () - 1])\n     mark_literal (l);\n \n   // Find pivot literal of each clause that was resolved with\n   // and extend Craig interpolant for it.\n   auto *interpolant =\n-      new CraigData (*craig_interpolants[proof_chain.back ()]);\n+      new CraigData (*craig_interpolants[proof_chain.back () - 1]);\n   for (int i = proof_chain.size () - 2; i >= 0; i--) {\n-    for (auto &l : craig_clauses[proof_chain[i]]) {\n+    for (auto &l : craig_clauses[proof_chain[i] - 1]) {\n       // Function mark_literal returns true if inverse literal was marked\n       // before and marks literal l for the following resolvent literal\n       // checks.\n@@ -435,13 +435,14 @@ void CraigTracer::add_derived_clause (\n         continue;\n \n       extend_interpolant_with_resolution (\n-          *interpolant, -l, *craig_interpolants[proof_chain[i]]);\n+          *interpolant, -l, *craig_interpolants[proof_chain[i] - 1]);\n     }\n   }\n   unmark_all ();\n \n-  craig_clauses[id] = c;\n-  craig_interpolants[id] = interpolant;\n+  assert (craig_clauses.size () == id - 1);\n+  craig_clauses.push_back (c);\n+  craig_interpolants.push_back (interpolant);\n }\n \n void CraigTracer::add_assumption_clause (\n@@ -453,7 +454,7 @@ void CraigTracer::add_assumption_clause (\n     // We have a resolution of multiple clauses and therefore reuse\n     // the existing code to build our Craig interpolant.\n     add_derived_clause (id, true, c, proof_chain);\n-    interpolant = craig_interpolants[id];\n+    interpolant = craig_interpolants[id - 1];\n   } else {\n     assert (c.size () == 2);\n     bool c0_is_assumption =\n@@ -463,9 +464,9 @@ void CraigTracer::add_assumption_clause (\n \n     if (!c0_is_assumption || !c1_is_assumption) {\n       int l = c0_is_assumption ? -c[1] : -c[0];\n-      craig_clauses[id] = {l};\n-      craig_interpolants[id] = create_interpolant_for_assumption (-l);\n-\n+      assert (craig_clauses.size () == id - 1);\n+      craig_clauses.push_back ({l});\n+      craig_interpolants.push_back (create_interpolant_for_assumption (-l));\n       assumption_clauses.push_back (id);\n       return;\n     }\n@@ -486,9 +487,11 @@ void CraigTracer::add_assumption_clause (\n     }\n   }\n \n-  craig_clauses[id] = c;\n-  craig_interpolants[id] = interpolant;\n-\n+  if (proof_chain.size () == 0) {\n+    assert (craig_clauses.size () == id - 1);\n+    craig_clauses.push_back (c);\n+    craig_interpolants.push_back (interpolant);\n+  }\n   assumption_clauses.push_back (id);\n }\n \n@@ -497,14 +500,8 @@ void CraigTracer::delete_clause (uint64_t id, bool redundant,\n   (void) redundant;\n   (void) c;\n \n-  auto it1 = craig_clauses.find (id);\n-  assert (it1 != craig_clauses.end ());\n-  craig_clauses.erase (it1);\n-\n-  auto it2 = craig_interpolants.find (id);\n-  assert (it2 != craig_interpolants.end ());\n-  delete it2->second;\n-  craig_interpolants.erase (it2);\n+  assert (craig_clauses.size () >= id - 1);\n+  craig_clauses[id - 1].resize (0);\n }\n \n void CraigTracer::add_assumption (int lit) { assumptions.insert (lit); }\n@@ -515,7 +512,7 @@ void CraigTracer::add_constraint (const std::vector<int> &c) {\n \n void CraigTracer::reset_assumptions () {\n   for (auto &id : assumption_clauses) {\n-    delete_clause (id, true, craig_clauses[id]);\n+    delete_clause (id, true, craig_clauses[id - 1]);\n   }\n   assumptions.clear ();\n   constraint.clear ();\n@@ -536,16 +533,16 @@ void CraigTracer::conclude_unsat (\n     // The proof_chain contains a single empty clause.\n     // chain = (c1), c1 = {}\n     assert (proof_chain.size () == 1);\n-    assert (craig_clauses[proof_chain[0]].empty ());\n-    interpolant = new CraigData (*craig_interpolants[proof_chain[0]]);\n+    assert (craig_clauses[proof_chain[0] - 1].empty ());\n+    interpolant = new CraigData (*craig_interpolants[proof_chain[0] - 1]);\n   } else if (conclusion == CaDiCaL::ConclusionType::ASSUMPTIONS) {\n     // One or more constraints are responsible for the conflict.\n     // The proof_chain contains a single clause with failing assumptions.\n     // The interpolant of that clause already has been resolved with\n     // assumption interpolants. chain = (c1), c1 = { -a1, -a2, -a3, ... }\n     assert (proof_chain.size () == 1);\n-    assert (craig_clauses[proof_chain[0]].size () > 0);\n-    interpolant = new CraigData (*craig_interpolants[proof_chain[0]]);\n+    assert (craig_clauses[proof_chain[0] - 1].size () > 0);\n+    interpolant = new CraigData (*craig_interpolants[proof_chain[0] - 1]);\n   } else if (conclusion == CaDiCaL::ConclusionType::CONSTRAINT) {\n     // The constraint clause is responsible for the conflict.\n \n@@ -558,7 +555,7 @@ void CraigTracer::conclude_unsat (\n     interpolant =\n         create_interpolant_for_clause (constraint, craig_constraint_label);\n     for (int i = proof_chain.size () - 1; i >= 0; i--) {\n-      for (auto &l : craig_clauses[proof_chain[i]]) {\n+      for (auto &l : craig_clauses[proof_chain[i] - 1]) {\n         // Function mark_literal returns true if inverse literal was marked\n         // before and marks literal l for the following resolvent literal\n         // checks.\n@@ -566,7 +563,7 @@ void CraigTracer::conclude_unsat (\n           continue;\n \n         extend_interpolant_with_resolution (\n-            *interpolant, -l, *craig_interpolants[proof_chain[i]]);\n+            *interpolant, -l, *craig_interpolants[proof_chain[i] - 1]);\n       }\n     }\n \ndiff --git a/contrib/craigtracer.hpp b/contrib/craigtracer.hpp\nindex 271e0fef8..1370ce0a0 100644\n--- a/contrib/craigtracer.hpp\n+++ b/contrib/craigtracer.hpp\n@@ -10,9 +10,9 @@\n #include \"tracer.hpp\"\n \n #include <iostream>\n-#include <map>\n #include <set>\n #include <string>\n+#include <unordered_map>\n #include <vector>\n \n namespace CaDiCraig {\n@@ -174,16 +174,15 @@ class CraigTracer : public CaDiCaL::Tracer {\n   std::vector<uint64_t> assumption_clauses;\n \n   std::vector<int> marked_history;\n-  std::map<int, uint8_t> marked_lits;\n+  std::unordered_map<int, uint8_t> marked_lits;\n \n   int craig_clause_current_id;\n-  std::map<int, uint64_t> craig_clause_ids;\n-  std::map<int, CraigVarType> craig_var_labels;\n-  std::map<int, CraigClauseType> craig_clause_labels;\n+  std::unordered_map<int, CraigVarType> craig_var_labels;\n+  std::unordered_map<int, CraigClauseType> craig_clause_labels;\n   CraigClauseType craig_constraint_label;\n \n-  std::map<uint64_t, std::vector<int>> craig_clauses;\n-  std::map<uint64_t, CraigData *> craig_interpolants;\n+  std::vector<std::vector<int>> craig_clauses;\n+  std::vector<CraigData *> craig_interpolants;\n \n   CraigConstruction craig_construction;\n   size_t craig_id;\n\"\"\""
  },
  {
    "pr_number": 97,
    "title": "Added option to disable IPASIR interface",
    "author": "TobiasFaller",
    "head_sha": "1baee298cb2fe12f12f11a8e27b249f310f7096f",
    "base_sha": "81074b5404553b88b6931f2fb592d22cbd36b85a",
    "head_ref": "feature-no-ipasir",
    "base_ref": "development",
    "merge_commit_sha": "41f7e2d7fc7e2ae4245d5eed72bd886e396f0891",
    "state": "closed",
    "created_at": "2024-04-30T22:00:56Z",
    "updated_at": "2024-06-18T16:44:50Z",
    "merged_at": "2024-06-18T16:44:50Z",
    "pr_body": "Allows preventing accidentally linking against the CaDiCaL IPASIR interface when using together with other solvers.\r\n\r\nExample:\r\n```bash\r\n(cd mysolver && ./configure.sh && make -j)\r\n(cd cadical && ./configure.sh && make -j)\r\n(cd bmc-prover && ./configure.sh --cadical=../cadical --ipasir=../mysolver/libipasirmysolver.a && make -j)\r\n```\r\n\r\nIf mysolver defines only a few of the IPASIR functions, the linker could pick some implementations from CaDiCaL's IPASIR API.\r\nThis potentially results in crashes during runtime.",
    "diff": "\"\"\"diff --git a/configure b/configure\nindex 87ca8cd28..ce690b2f9 100755\n--- a/configure\n+++ b/configure\n@@ -31,6 +31,7 @@ options=\"\"\n quiet=no\n m32=no\n contrib=yes\n+ipasir=yes\n \n #--------------------------------------------------------------------------#\n \n@@ -98,6 +99,7 @@ where '<option>' is one of the following\n --no-contracts     compile without API contract checking code\n --no-tracing       compile without API call tracing code\n --no-contrib       compile without contributed code\n+--no-ipasir        compile without ipasir interface\n \n --competition      configure for the competition\n                    ('--quiet', '--no-contracts', '--no-tracing')\n@@ -155,6 +157,7 @@ do\n     --no-contracts | --no-contract) contracts=no;;\n     --no-tracing | --no-trace) tracing=no;;\n     --no-contrib) contrib=no;;\n+    --no-ipasir) ipasir=no;;\n \n     --coverage) coverage=yes;;\n     --profile) profile=yes;;\n@@ -313,6 +316,7 @@ fi\n [ $contracts = no ] && CXXFLAGS=\"$CXXFLAGS -DNCONTRACTS\"\n [ $tracing = no ] && CXXFLAGS=\"$CXXFLAGS -DNTRACING\"\n [ $contrib = no ] && CXXFLAGS=\"$CXXFLAGS -DNCONTRIB\"\n+[ $ipasir = no ] && CXXFLAGS=\"$CXXFLAGS -DNIPASIR\"\n \n CXXFLAGS=\"$CXXFLAGS$options\"\n \n@@ -499,6 +503,7 @@ sed \\\n -e \"s#@CXXFLAGS@#$CXXFLAGS#\" \\\n -e \"s#@LIBS@#$libs#\" \\\n -e \"s#@CONTRIB@#$contrib#\" \\\n+-e \"s#@IPASIR@#$ipasir#\" \\\n -e \"s#@ROOT@#$root#\" \\\n ../makefile.in > makefile\n \ndiff --git a/makefile.in b/makefile.in\nindex 0d1177437..8f5c88cfb 100644\n--- a/makefile.in\n+++ b/makefile.in\n@@ -12,16 +12,20 @@ CXXFLAGS=@CXXFLAGS@\n \n LIBS=@LIBS@\n CONTRIB=@CONTRIB@\n+IPASIR=@IPASIR@\n \n ############################################################################\n #    It is usually not necessary to change anything below this line!       #\n ############################################################################\n \n SRC_APP=src/cadical.cpp src/mobical.cpp\n+\n+SRC_IPASIR=src/ipasir.cpp\n SRC_SOLVER=$(subst ../src/,,$(sort $(wildcard ../src/*.cpp)))\n SRC_CONTRIB=$(subst ../contrib/,,$(sort $(wildcard ../contrib/*.cpp)))\n \n FILT_SOLVER=$(filter-out $(SRC_APP),$(SRC_SOLVER))\n+FILT_SOLVER:=$(if $(filter-out no,$(IPASIR)),$(FILT_SOLVER),$(filter-out $(SRC_IPASIR), $(FILT_SOLVER)))\n FILT_CONTRIB=$(if $(filter-out no,$(CONTRIB)),$(SRC_CONTRIB),)\n OBJ_SOLVER=$(FILT_SOLVER:.cpp=.o)\n OBJ_CONTRIB=$(FILT_CONTRIB:.cpp=.o)\n\"\"\""
  },
  {
    "pr_number": 95,
    "title": "Converted CraigTracer from C++ 17 to C++ 11",
    "author": "TobiasFaller",
    "head_sha": "fbf668f40b88a6ecf4a3831e5ea95d5462946545",
    "base_sha": "4e7e9bbae961b073522f7f7f5654f9be11b38c02",
    "head_ref": "feature-craig-tracer-cpp11",
    "base_ref": "development",
    "merge_commit_sha": "20c0ac44c6f13b3c5be69c26951e2c146eb5e8fc",
    "state": "closed",
    "created_at": "2024-03-27T18:18:11Z",
    "updated_at": "2024-03-27T20:13:43Z",
    "merged_at": "2024-03-27T20:13:43Z",
    "pr_body": null,
    "diff": "\"\"\"diff --git a/contrib/craigtracer.cpp b/contrib/craigtracer.cpp\nindex d24f14694..2ac4788d3 100644\n--- a/contrib/craigtracer.cpp\n+++ b/contrib/craigtracer.cpp\n@@ -115,7 +115,8 @@ class Aig {\n \n AigEdge Aig::create_var (int variable) {\n   // Try to check if there is a node for the literal already\n-  if (auto it = varHashMap.find (variable); it != varHashMap.end ()) {\n+  auto it = varHashMap.find (variable);\n+  if (it != varHashMap.end ()) {\n     return AigEdge (it->second);\n   }\n \n@@ -146,7 +147,8 @@ AigEdge Aig::create_and (const AigEdge &edge1, const AigEdge &edge2) {\n   // Order edge indices to increase hit rate\n   auto pair = (edge1 > edge2) ? std::make_tuple (edge2, edge1)\n                               : std::make_tuple (edge1, edge2);\n-  if (auto it = andHashMap.find (pair); it != andHashMap.end ()) {\n+  auto it = andHashMap.find (pair);\n+  if (it != andHashMap.end ()) {\n     return AigEdge (it->second);\n   }\n \n@@ -205,7 +207,8 @@ CraigCnfType Aig::create_cnf (const AigEdge &root,\n \n   // A fixed single literal => No Tseitin variables are required\n   // and we can take a fast path without building an index.\n-  if (auto node = nodes[root.get_node_index ()]; node.isVariable ()) {\n+  auto node = nodes[root.get_node_index ()];\n+  if (node.isVariable ()) {\n     auto rootLiteral = node.get_variable () * (root.is_negated () ? -1 : 1);\n     cnf.push_back ({rootLiteral});\n     return CraigCnfType::NORMAL;\n@@ -226,7 +229,8 @@ CraigCnfType Aig::create_cnf (const AigEdge &root,\n     const auto &node = nodes[nodeIndex];\n \n     // Check if node was already converted to Tseitin variable.\n-    if (auto it = node_to_var.find (nodeIndex); it != node_to_var.end ()) {\n+    auto it = node_to_var.find (nodeIndex);\n+    if (it != node_to_var.end ()) {\n       pending.pop ();\n       continue;\n     }\n@@ -236,11 +240,11 @@ CraigCnfType Aig::create_cnf (const AigEdge &root,\n     const auto &edge2 = node.get_edge2 ();\n     const size_t node1Index = edge1.get_node_index ();\n     const size_t node2Index = edge2.get_node_index ();\n-    if (auto itNode1 = node_to_var.find (node1Index);\n-        itNode1 == node_to_var.end ()) {\n+    auto itNode1 = node_to_var.find (node1Index);\n+    auto itNode2 = node_to_var.find (node2Index);\n+    if (itNode1 == node_to_var.end ()) {\n       pending.push (node1Index);\n-    } else if (auto itNode2 = node_to_var.find (node2Index);\n-               itNode2 == node_to_var.end ()) {\n+    } else if (itNode2 == node_to_var.end ()) {\n       pending.push (node2Index);\n     } else {\n       // Edges have been processed, now do Tseiting transformation.\n@@ -337,8 +341,8 @@ CraigTracer::CraigTracer ()\n       craig_aig_dual_asym (new Aig ()) {}\n \n CraigTracer::~CraigTracer () {\n-  for (auto &[id, interpolant] : craig_interpolants)\n-    delete interpolant;\n+  for (auto it : craig_interpolants)\n+    delete it.second;\n   if (craig_interpolant)\n     delete craig_interpolant;\n \n@@ -580,28 +584,20 @@ CraigData *CraigTracer::create_interpolant_for_assumption (int literal) {\n   CraigVarType varType = craig_var_labels[abs (literal)];\n   if (varType == CraigVarType::A_LOCAL) {\n     return new CraigData (\n-        {.partial_interpolant_sym = craig_aig_sym->get_false (),\n-         .partial_interpolant_asym = craig_aig_asym->get_false (),\n-         .partial_interpolant_dual_sym = craig_aig_dual_sym->get_true (),\n-         .partial_interpolant_dual_asym = craig_aig_dual_asym->get_false (),\n-         .clause_type = CraigClauseType::A_CLAUSE,\n-         .craig_id = craig_id++});\n+        {craig_aig_sym->get_false (), craig_aig_asym->get_false (),\n+         craig_aig_dual_sym->get_true (), craig_aig_dual_asym->get_false (),\n+         CraigClauseType::A_CLAUSE, craig_id++});\n   } else if (varType == CraigVarType::B_LOCAL) {\n     return new CraigData (\n-        {.partial_interpolant_sym = craig_aig_sym->get_true (),\n-         .partial_interpolant_asym = craig_aig_asym->get_true (),\n-         .partial_interpolant_dual_sym = craig_aig_dual_sym->get_false (),\n-         .partial_interpolant_dual_asym = craig_aig_dual_asym->get_true (),\n-         .clause_type = CraigClauseType::B_CLAUSE,\n-         .craig_id = craig_id++});\n+        {craig_aig_sym->get_true (), craig_aig_asym->get_true (),\n+         craig_aig_dual_sym->get_false (), craig_aig_dual_asym->get_true (),\n+         CraigClauseType::B_CLAUSE, craig_id++});\n   } else if (varType == CraigVarType::GLOBAL) {\n-    return new CraigData (\n-        {.partial_interpolant_sym = craig_aig_sym->get_true (),\n-         .partial_interpolant_asym = craig_aig_asym->get_true (),\n-         .partial_interpolant_dual_sym = craig_aig_dual_sym->get_false (),\n-         .partial_interpolant_dual_asym = craig_aig_dual_asym->get_false (),\n-         .clause_type = CraigClauseType::L_CLAUSE,\n-         .craig_id = craig_id++});\n+    return new CraigData ({craig_aig_sym->get_true (),\n+                           craig_aig_asym->get_true (),\n+                           craig_aig_dual_sym->get_false (),\n+                           craig_aig_dual_asym->get_false (),\n+                           CraigClauseType::L_CLAUSE, craig_id++});\n   } else {\n     assert (false); // Encountered invalid variable type!\n     __builtin_unreachable ();\n@@ -612,12 +608,9 @@ CraigData *\n CraigTracer::create_interpolant_for_clause (const std::vector<int> &clause,\n                                             CraigClauseType clause_type) {\n   auto result = new CraigData (\n-      {.partial_interpolant_sym = craig_aig_sym->get_true (),\n-       .partial_interpolant_asym = craig_aig_asym->get_true (),\n-       .partial_interpolant_dual_sym = craig_aig_dual_sym->get_true (),\n-       .partial_interpolant_dual_asym = craig_aig_dual_asym->get_true (),\n-       .clause_type = clause_type,\n-       .craig_id = craig_id++});\n+      {craig_aig_sym->get_true (), craig_aig_asym->get_true (),\n+       craig_aig_dual_sym->get_true (), craig_aig_dual_asym->get_true (),\n+       clause_type, craig_id++});\n \n   if (is_construction_enabled (CraigConstruction::SYMMETRIC)) {\n     if (clause_type == CraigClauseType::A_CLAUSE) {\n@@ -867,12 +860,12 @@ CraigTracer::create_craig_interpolant (CraigInterpolant interpolant,\n   // We have at least two Craig interpolants for the following computations.\n   if (interpolant == CraigInterpolant::UNION) {\n     bool allConstantOne = true;\n-    for (auto [craigCnf, craigCnfType] : craig_cnfs) {\n-      if (craigCnfType == CraigCnfType::CONSTANT0) {\n-        cnf = std::move (*craigCnf);\n+    for (auto &it : craig_cnfs) {\n+      if (std::get<1> (it) == CraigCnfType::CONSTANT0) {\n+        cnf = std::move (*std::get<0> (it));\n         return CraigCnfType::CONSTANT0;\n       }\n-      allConstantOne &= (craigCnfType == CraigCnfType::CONSTANT1);\n+      allConstantOne &= (std::get<1> (it) == CraigCnfType::CONSTANT1);\n     }\n     if (allConstantOne) {\n       cnf = {};\n@@ -882,19 +875,19 @@ CraigTracer::create_craig_interpolant (CraigInterpolant interpolant,\n     // Create trigger (t) that enforces all CNF parts.\n     int craig_trigger = nextFreeVariable++;\n     std::vector<int> craig_trigger_clause{craig_trigger};\n-    for (auto [craigCnf, craigCnfType] : craig_cnfs) {\n-      if (craigCnfType == CraigCnfType::NORMAL) {\n+    for (auto &it : craig_cnfs) {\n+      if (std::get<1> (it) == CraigCnfType::NORMAL) {\n         size_t i = 0, j = cnf.size ();\n-        cnf.resize (cnf.size () + craigCnf->size ());\n-        for (; i < craigCnf->size () - 1u; i++, j++)\n-          cnf[j] = std::move ((*craigCnf)[i]);\n+        cnf.resize (cnf.size () + std::get<0> (it)->size ());\n+        for (; i < std::get<0> (it)->size () - 1u; i++, j++)\n+          cnf[j] = std::move ((*std::get<0> (it))[i]);\n         // The positive trigger implies that all CNF parts are enabled: (t\n         // -> t_1) = (-t v t_1)\n-        cnf[j] = {-craig_trigger, (*craigCnf)[i][0]};\n+        cnf[j] = {-craig_trigger, (*std::get<0> (it))[i][0]};\n         // The negative trigger implies that at least one of the CNF parts\n         // is not enabled: (-t -> (-t_1 v ... v -t_n)) = (t v -t_1 v ...\n         // -t_n)\n-        craig_trigger_clause.push_back (-(*craigCnf)[i][0]);\n+        craig_trigger_clause.push_back (-(*std::get<0> (it))[i][0]);\n       }\n     }\n \n@@ -904,12 +897,12 @@ CraigTracer::create_craig_interpolant (CraigInterpolant interpolant,\n     return CraigCnfType::NORMAL;\n   } else if (interpolant == CraigInterpolant::INTERSECTION) {\n     bool allConstantZero = true;\n-    for (auto [craigCnf, craigCnfType] : craig_cnfs) {\n-      if (craigCnfType == CraigCnfType::CONSTANT1) {\n-        cnf = std::move (*craigCnf);\n+    for (auto &it : craig_cnfs) {\n+      if (std::get<1> (it) == CraigCnfType::CONSTANT1) {\n+        cnf = std::move (*std::get<0> (it));\n         return CraigCnfType::CONSTANT1;\n       }\n-      allConstantZero &= (craigCnfType == CraigCnfType::CONSTANT0);\n+      allConstantZero &= (std::get<1> (it) == CraigCnfType::CONSTANT0);\n     }\n     if (allConstantZero) {\n       cnf = {{}};\n@@ -919,18 +912,18 @@ CraigTracer::create_craig_interpolant (CraigInterpolant interpolant,\n     // Create trigger (t) that enforces all CNF parts.\n     int craig_trigger = nextFreeVariable++;\n     std::vector<int> craig_trigger_clause{-craig_trigger};\n-    for (auto [craigCnf, craigCnfType] : craig_cnfs) {\n-      if (craigCnfType == CraigCnfType::NORMAL) {\n+    for (auto &it : craig_cnfs) {\n+      if (std::get<1> (it) == CraigCnfType::NORMAL) {\n         size_t i = 0, j = cnf.size ();\n-        cnf.resize (cnf.size () + craigCnf->size ());\n-        for (; i < craigCnf->size () - 1u; i++, j++)\n-          cnf[j] = std::move ((*craigCnf)[i]);\n+        cnf.resize (cnf.size () + std::get<0> (it)->size ());\n+        for (; i < std::get<0> (it)->size () - 1u; i++, j++)\n+          cnf[j] = std::move ((*std::get<0> (it))[i]);\n         // The positive trigger implies that one of the CNF parts is\n         // enabled: (t -> (t_1 v ... v t_n)) = (-t v t_1 v ... t_n)\n-        craig_trigger_clause.push_back ((*craigCnf)[i][0]);\n+        craig_trigger_clause.push_back ((*std::get<0> (it))[i][0]);\n         // The negative trigger implies that at all CNF parts are not\n         // enabled: (-t -> -t_1) = (t v -t_1)\n-        cnf[j] = {craig_trigger, -(*craigCnf)[i][0]};\n+        cnf[j] = {craig_trigger, -(*std::get<0> (it))[i][0]};\n       }\n     }\n \n@@ -939,27 +932,27 @@ CraigTracer::create_craig_interpolant (CraigInterpolant interpolant,\n \n     return CraigCnfType::NORMAL;\n   } else if (interpolant == CraigInterpolant::SMALLEST) {\n-    auto compare = [] (auto const &elem1, auto const &elem2) {\n-      auto const &[elem1Cnf, elem1CnfType] = elem1;\n-      auto const &[elem2Cnf, elem2CnfType] = elem2;\n-      return (elem1Cnf->size () < elem2Cnf->size ());\n+    auto compare = [] (const std::tuple<std::vector<std::vector<int>> *,\n+                                        CraigCnfType> &elem1,\n+                       const std::tuple<std::vector<std::vector<int>> *,\n+                                        CraigCnfType> &elem2) {\n+      return (std::get<0> (elem1)->size () < std::get<0> (elem2)->size ());\n     };\n     auto minimum =\n         std::min_element (craig_cnfs.begin (), craig_cnfs.end (), compare);\n-    auto [minCnf, minCnfType] = *minimum;\n-    cnf = std::move (*minCnf);\n-    return minCnfType;\n+    cnf = std::move (*std::get<0> (*minimum));\n+    return std::get<1> (*minimum);\n   } else if (interpolant == CraigInterpolant::LARGEST) {\n-    auto compare = [] (auto const &elem1, auto const &elem2) {\n-      auto const &[elem1Cnf, elem1CnfType] = elem1;\n-      auto const &[elem2Cnf, elem2CnfType] = elem2;\n-      return (elem1Cnf->size () < elem2Cnf->size ());\n+    auto compare = [] (const std::tuple<std::vector<std::vector<int>> *,\n+                                        CraigCnfType> &elem1,\n+                       const std::tuple<std::vector<std::vector<int>> *,\n+                                        CraigCnfType> &elem2) {\n+      return (std::get<0> (elem1)->size () < std::get<0> (elem2)->size ());\n     };\n     auto maximum =\n         std::max_element (craig_cnfs.begin (), craig_cnfs.end (), compare);\n-    auto [maxCnf, maxCnfType] = *maximum;\n-    cnf = std::move (*maxCnf);\n-    return maxCnfType;\n+    cnf = std::move (*std::get<0> (*maximum));\n+    return std::get<1> (*maximum);\n   } else {\n     assert (false); // Seleted craig interpolation type not supported!\n     __builtin_unreachable ();\n\"\"\""
  },
  {
    "pr_number": 94,
    "title": "Fixed missing labels in CraigTracer test case",
    "author": "TobiasFaller",
    "head_sha": "1915dd13caf5eb521960236c13a11cfc89b02b40",
    "base_sha": "1b686c048d9361db28ac232585737755f1d19538",
    "head_ref": "fix-craigtracer-test",
    "base_ref": "development",
    "merge_commit_sha": "f21f01f4dfc21456d93ae134e45eca589aef7c17",
    "state": "closed",
    "created_at": "2024-03-27T12:31:12Z",
    "updated_at": "2024-03-27T14:49:04Z",
    "merged_at": "2024-03-27T14:49:04Z",
    "pr_body": "Test case is fixed now:\r\n\r\n```bash\r\nmake -C .. contrib\r\nmake[1]: Entering directory '/home/fallert/Source/cadical/test'\r\n---------------------------------------------------------\r\nContributions testing in '../build'\r\n---------------------------------------------------------\r\nmake[2]: Entering directory '/home/fallert/Source/cadical/build'\r\n/home/fallert/Source/cadical/scripts/make-build-header.sh > build.hpp\r\ng++ -Wall -Wextra -g -I../build -I/home/fallert/Source/cadical/src -c /home/fallert/Source/cadical/src/version.cpp -o src/version.o\r\nar rc libcadical.a src/analyze.o src/arena.o src/assume.o src/averages.o src/backtrack.o src/backward.o src/bins.o src/block.o src/ccadical.o src/checker.o src/clause.o src/collect.o src/compact.o src/condition.o src/config.o src/constrain.o src/contract.o src/cover.o src/decide.o src/decompose.o src/deduplicate.o src/drattracer.o src/elim.o src/ema.o src/extend.o src/external.o src/external_propagate.o src/file.o src/flags.o src/flip.o src/format.o src/frattracer.o src/gates.o src/idruptracer.o src/instantiate.o src/internal.o src/ipasir.o src/lidruptracer.o src/limit.o src/logging.o src/lookahead.o src/lratbuilder.o src/lratchecker.o src/lrattracer.o src/lucky.o src/message.o src/minimize.o src/occs.o src/options.o src/parse.o src/phases.o src/probe.o src/profile.o src/proof.o src/propagate.o src/queue.o src/random.o src/reap.o src/reduce.o src/rephase.o src/report.o src/resources.o src/restart.o src/restore.o src/score.o src/shrink.o src/signal.o src/solution.o src/solver.o src/stats.o src/subsume.o src/terminal.o src/ternary.o src/transred.o src/util.o src/var.o src/veripbtracer.o src/version.o src/vivify.o src/walk.o src/watch.o contrib/craigtracer.o\r\ng++ -Wall -Wextra -g -I../build -I/home/fallert/Source/cadical/src -o cadical src/cadical.o -L. -lcadical \r\ng++ -Wall -Wextra -g -I../build -I/home/fallert/Source/cadical/src -o mobical src/mobical.o -L. -lcadical\r\nmake[2]: Leaving directory '/home/fallert/Source/cadical/build'\r\ntest/contrib/run.sh: using CXX=g++\r\ntest/contrib/run.sh: using CXXFLAGS=-Wall -Wextra -g\r\ntest/contrib/run.sh: running contrib test 'craigtracer'\r\ng++ -Wall -Wextra -g -I../src -I../contrib -o ../build/test-contrib-craigtracer.o -c ../test/contrib/craigtracer.cpp\r\ng++ -Wall -Wextra -g -o ../build/test-contrib-craigtracer ../build/test-contrib-craigtracer.o -L../build -lcadical\r\n../build/test-contrib-craigtracer\r\n# 0 ... ok (zero exit code)\r\ntest/contrib/run.sh: running contrib test 'craigtracer_incremental'\r\ng++ -Wall -Wextra -g -I../src -I../contrib -o ../build/test-contrib-craigtracer_incremental.o -c ../test/contrib/craigtracer_incremental.cpp\r\ng++ -Wall -Wextra -g -o ../build/test-contrib-craigtracer_incremental ../build/test-contrib-craigtracer_incremental.o -L../build -lcadical\r\n../build/test-contrib-craigtracer_incremental\r\n# 0 ... ok (zero exit code)\r\ntest/contrib/run.sh: contrib testing results: 2 ok, 0 failed\r\nmake[1]: Leaving directory '/home/fallert/Source/cadical/test'\r\n```",
    "diff": "\"\"\"diff --git a/test/contrib/craigtracer_incremental.cpp b/test/contrib/craigtracer_incremental.cpp\nindex 42eedfbb4..a04fda32f 100644\n--- a/test/contrib/craigtracer_incremental.cpp\n+++ b/test/contrib/craigtracer_incremental.cpp\n@@ -47,6 +47,8 @@ int main () {\n   assert (next_var == 2);\n \n   // ------------------------------------------------\n+  tracer->label_clause (3, CaDiCraig::CraigClauseType::A_CLAUSE);\n+  tracer->label_constraint (CaDiCraig::CraigClauseType::B_CLAUSE);\n   solver->add (-1); solver->add (3); solver->add (0);\n   solver->constrain (-2); solver->constrain (-3); solver->constrain (0);\n   assert (solver->solve () == CaDiCaL::Status::UNSATISFIABLE);\n\"\"\""
  },
  {
    "pr_number": 89,
    "title": "Added Craig interpolant creating tracer",
    "author": "TobiasFaller",
    "head_sha": "081ebfcc903da244584d05450d4b1a275e121ea8",
    "base_sha": "771756d7c0f90ce3bdc2d8cd7f486a51b3abe1a0",
    "head_ref": "feature-craig-interpolation",
    "base_ref": "development",
    "merge_commit_sha": "8eff844324c4a0591f1ffc44f12daa105e900605",
    "state": "closed",
    "created_at": "2024-02-17T22:17:08Z",
    "updated_at": "2025-07-12T02:11:56Z",
    "merged_at": "2024-03-27T10:44:28Z",
    "pr_body": "- Added support for contributed code\r\n- Added CraigTracer contributed code\r\n- Added documentation for CraigTracer\r\n- Added tests for CraigTracer",
    "diff": "\"\"\"diff --git a/configure b/configure\nindex a578cf449..87ca8cd28 100755\n--- a/configure\n+++ b/configure\n@@ -30,6 +30,7 @@ pedantic=no\n options=\"\"\n quiet=no\n m32=no\n+contrib=yes\n \n #--------------------------------------------------------------------------#\n \n@@ -96,6 +97,7 @@ where '<option>' is one of the following\n \n --no-contracts     compile without API contract checking code\n --no-tracing       compile without API call tracing code\n+--no-contrib       compile without contributed code\n \n --competition      configure for the competition\n                    ('--quiet', '--no-contracts', '--no-tracing')\n@@ -152,6 +154,7 @@ do\n \n     --no-contracts | --no-contract) contracts=no;;\n     --no-tracing | --no-trace) tracing=no;;\n+    --no-contrib) contrib=no;;\n \n     --coverage) coverage=yes;;\n     --profile) profile=yes;;\n@@ -291,6 +294,7 @@ then\n   quiet=yes\n   contracts=no\n   tracing=no\n+  contrib=no\n fi\n \n [ $check = no ] && CXXFLAGS=\"$CXXFLAGS -DNDEBUG\"\n@@ -308,6 +312,7 @@ then\n fi\n [ $contracts = no ] && CXXFLAGS=\"$CXXFLAGS -DNCONTRACTS\"\n [ $tracing = no ] && CXXFLAGS=\"$CXXFLAGS -DNTRACING\"\n+[ $contrib = no ] && CXXFLAGS=\"$CXXFLAGS -DNCONTRIB\"\n \n CXXFLAGS=\"$CXXFLAGS$options\"\n \n@@ -493,6 +498,8 @@ sed \\\n -e \"s,@CXX@,$CXX,\" \\\n -e \"s#@CXXFLAGS@#$CXXFLAGS#\" \\\n -e \"s#@LIBS@#$libs#\" \\\n+-e \"s#@CONTRIB@#$contrib#\" \\\n+-e \"s#@ROOT@#$root#\" \\\n ../makefile.in > makefile\n \n msg \"generated '$build/makefile' from '../makefile.in'\"\ndiff --git a/contrib/craigtracer.LICENSE.APACHE b/contrib/craigtracer.LICENSE.APACHE\nnew file mode 100644\nindex 000000000..171a7efd9\n--- /dev/null\n+++ b/contrib/craigtracer.LICENSE.APACHE\n@@ -0,0 +1,15 @@\n+Copyright 2013 Stefan Kupferschmid\n+Copyright 2023 Florian Pollitt\n+Copyright 2023 Tobias Faller\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\ndiff --git a/contrib/craigtracer.LICENSE.MIT b/contrib/craigtracer.LICENSE.MIT\nnew file mode 100644\nindex 000000000..1132ccda6\n--- /dev/null\n+++ b/contrib/craigtracer.LICENSE.MIT\n@@ -0,0 +1,9 @@\n+Copyright 2013 Stefan Kupferschmid\n+Copyright 2023 Florian Pollitt\n+Copyright 2023 Tobias Faller\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\ndiff --git a/contrib/craigtracer.cpp b/contrib/craigtracer.cpp\nnew file mode 100644\nindex 000000000..b589c1dbe\n--- /dev/null\n+++ b/contrib/craigtracer.cpp\n@@ -0,0 +1,989 @@\n+// SPDX-License-Identifier: MIT OR Apache-2.0\n+// Copyright 2013 Stefan Kupferschmid\n+// Copyright 2023 Florian Pollitt\n+// Copyright 2023 Tobias Faller\n+\n+#include \"craigtracer.hpp\"\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <iostream>\n+#include <limits>\n+#include <map>\n+#include <stack>\n+#include <tuple>\n+#include <unordered_map>\n+\n+namespace CaDiCraig {\n+\n+// ----------------------------------------------------------------------------\n+// Minimal AIG implementation used for building Craig interpolants\n+// ----------------------------------------------------------------------------\n+\n+class AigEdge {\n+public:\n+  AigEdge () : index (0) {}\n+  AigEdge (const AigEdge &other) : index (other.index) {}\n+\n+  AigEdge &operator= (const AigEdge &other) {\n+    index = other.index;\n+    return *this;\n+  }\n+  AigEdge operator!() const { return AigEdge (index ^ 1); }\n+\n+  bool operator== (const AigEdge &other) const {\n+    return index == other.index;\n+  }\n+  bool operator< (const AigEdge &other) const {\n+    return index < other.index;\n+  }\n+  bool operator> (const AigEdge &other) const {\n+    return index > other.index;\n+  }\n+\n+  bool is_negated () const { return index & 1; }\n+  bool is_constant () const { return (index >> 1u) == 0; }\n+\n+  friend class AigNode;\n+  friend class Aig;\n+\n+private:\n+  explicit AigEdge (int index) : index (index) {}\n+  size_t get_node_index () const { return (index >> 1u) - 1; }\n+\n+  int index;\n+};\n+\n+class AigNode {\n+public:\n+  bool isAnd () const { return edge2.index != 0; }\n+  bool isVariable () const { return edge2.index == 0; }\n+\n+  int get_variable () const { return edge1.index; }\n+  const AigEdge &get_edge1 () const { return edge1; }\n+  const AigEdge &get_edge2 () const { return edge2; }\n+\n+  friend class Aig;\n+\n+private:\n+  explicit AigNode (int _variable) : edge1 (_variable), edge2 (0) {}\n+  explicit AigNode (AigEdge _edge1, AigEdge _edge2)\n+      : edge1 (_edge1), edge2 (_edge2) {}\n+\n+  AigEdge edge1;\n+  AigEdge edge2;\n+};\n+\n+class Aig {\n+public:\n+  Aig () : nodes (), varHashMap (), andHashMap () {}\n+\n+  static AigEdge get_true () { return AigEdge (0); }\n+  static AigEdge get_false () { return AigEdge (1); }\n+\n+  void clear () {\n+    nodes.clear ();\n+    varHashMap.clear ();\n+    andHashMap.clear ();\n+  }\n+  AigEdge create_literal (int literal);\n+  AigEdge create_and (const AigEdge &edge1, const AigEdge &edge2);\n+  AigEdge create_or (const AigEdge &edge1, const AigEdge &edge2);\n+  AigEdge create_and (std::vector<AigEdge> edges);\n+  AigEdge create_or (std::vector<AigEdge> edges);\n+\n+  CraigCnfType create_cnf (const AigEdge &root,\n+                           std::vector<std::vector<int>> &cnf,\n+                           int &nextFreeIndex) const;\n+\n+private:\n+  AigEdge create_var (int variable);\n+\n+  struct EdgePairHash {\n+    int operator() (const std::tuple<AigEdge, AigEdge> &edges) const {\n+      return (std::get<0> (edges).index << 16u) | std::get<1> (edges).index\n+                                                      << 0u;\n+    }\n+  };\n+  struct VarHash {\n+    int operator() (const int &variable) const { return variable; }\n+  };\n+\n+  std::vector<AigNode> nodes;\n+  std::unordered_map<int, int, VarHash> varHashMap;\n+  std::unordered_map<std::tuple<AigEdge, AigEdge>, int, EdgePairHash>\n+      andHashMap;\n+};\n+\n+AigEdge Aig::create_var (int variable) {\n+  // Try to check if there is a node for the literal already\n+  if (auto it = varHashMap.find (variable); it != varHashMap.end ()) {\n+    return AigEdge (it->second);\n+  }\n+\n+  // Nodes 0 and 1 are constant nodes and reserved\n+  // and already factored into the index.\n+  nodes.emplace_back (AigNode (variable));\n+  varHashMap[variable] = (nodes.size () << 1u);\n+  return AigEdge (nodes.size () << 1u);\n+}\n+\n+AigEdge Aig::create_literal (int literal) {\n+  auto edge = create_var (abs (literal));\n+  return (literal < 0) ? !edge : edge;\n+}\n+\n+AigEdge Aig::create_and (const AigEdge &edge1, const AigEdge &edge2) {\n+  if (edge1 == get_false () || edge2 == get_false ())\n+    return get_false ();\n+  if (edge1 == get_true ())\n+    return edge2;\n+  if (edge2 == get_true ())\n+    return edge1;\n+  if (edge1 == edge2)\n+    return edge1;\n+  if (edge1 == !edge2)\n+    return get_false ();\n+\n+  // Order edge indices to increase hit rate\n+  auto pair = (edge1 > edge2) ? std::make_tuple (edge2, edge1)\n+                              : std::make_tuple (edge1, edge2);\n+  if (auto it = andHashMap.find (pair); it != andHashMap.end ()) {\n+    return AigEdge (it->second);\n+  }\n+\n+  // Lookup failed, create new node.\n+  // Nodes 0 and 1 are constant nodes and reserved\n+  // and already factored into the index.\n+  nodes.emplace_back (AigNode (edge1, edge2));\n+  andHashMap[pair] = (nodes.size () << 1u);\n+  return AigEdge (nodes.size () << 1u);\n+}\n+\n+AigEdge Aig::create_and (std::vector<AigEdge> edges) {\n+  if (edges.empty ())\n+    return get_true ();\n+  if (edges.size () == 1u)\n+    return edges[0u];\n+\n+  // Tree reduction of edges\n+  std::vector<AigEdge> tempEdges;\n+  while (edges.size () > 1u) {\n+    tempEdges.reserve ((edges.size () / 2u) + 1u);\n+    for (size_t index{0u}; index + 1u < edges.size (); index += 2u) {\n+      tempEdges.emplace_back (create_and (edges[index], edges[index + 1u]));\n+    }\n+    if (edges.size () & 1)\n+      tempEdges.emplace_back (edges.back ());\n+\n+    edges = std::move (tempEdges);\n+    tempEdges.clear ();\n+  }\n+\n+  return edges[0u];\n+}\n+\n+AigEdge Aig::create_or (const AigEdge &edge1, const AigEdge &edge2) {\n+  return !create_and (!edge1, !edge2);\n+}\n+\n+AigEdge Aig::create_or (std::vector<AigEdge> edges) {\n+  for (auto &edge : edges)\n+    edge = !edge;\n+  return !create_and (edges);\n+}\n+\n+CraigCnfType Aig::create_cnf (const AigEdge &root,\n+                              std::vector<std::vector<int>> &cnf,\n+                              int &nextFreeIndex) const {\n+  // The AIG is constant => Handle this simple case.\n+  if (root.is_constant ()) {\n+    if (root == get_false ()) {\n+      cnf.push_back ({});\n+      return CraigCnfType::CONSTANT0;\n+    }\n+    return CraigCnfType::CONSTANT1;\n+  }\n+\n+  // A fixed single literal => No Tseitin variables are required\n+  // and we can take a fast path without building an index.\n+  if (auto node = nodes[root.get_node_index ()]; node.isVariable ()) {\n+    auto rootLiteral = node.get_variable () * (root.is_negated () ? -1 : 1);\n+    cnf.push_back ({rootLiteral});\n+    return CraigCnfType::NORMAL;\n+  }\n+\n+  // Create index of pre-existing (external) variables.\n+  // This index is extended with Tseitin variables are required.\n+  std::map<size_t, int> node_to_var;\n+  for (size_t nodeIndex{0u}; nodeIndex < nodes.size (); nodeIndex++) {\n+    auto const &node = nodes[nodeIndex];\n+    if (node.isVariable ())\n+      node_to_var[nodeIndex] = node.get_variable ();\n+  }\n+\n+  std::stack<size_t> pending{{root.get_node_index ()}};\n+  while (!pending.empty ()) {\n+    const auto nodeIndex = pending.top ();\n+    const auto &node = nodes[nodeIndex];\n+\n+    // Check if node was already converted to Tseitin variable.\n+    if (auto it = node_to_var.find (nodeIndex); it != node_to_var.end ()) {\n+      pending.pop ();\n+      continue;\n+    }\n+\n+    // Both edges have to be processed first.\n+    const auto &edge1 = node.get_edge1 ();\n+    const auto &edge2 = node.get_edge2 ();\n+    const size_t node1Index = edge1.get_node_index ();\n+    const size_t node2Index = edge2.get_node_index ();\n+    if (auto itNode1 = node_to_var.find (node1Index);\n+        itNode1 == node_to_var.end ()) {\n+      pending.push (node1Index);\n+    } else if (auto itNode2 = node_to_var.find (node2Index);\n+               itNode2 == node_to_var.end ()) {\n+      pending.push (node2Index);\n+    } else {\n+      // Edges have been processed, now do Tseiting transformation.\n+      // This node is guaranteed to not be a variable as they have been\n+      // inserted into the mapping at the start of this method.\n+      pending.pop ();\n+\n+      const auto tseitinVar = nextFreeIndex++;\n+      node_to_var[nodeIndex] = tseitinVar;\n+\n+      const auto litEdge1 =\n+          itNode1->second * (edge1.is_negated () ? -1 : 1);\n+      const auto litEdge2 =\n+          itNode2->second * (edge2.is_negated () ? -1 : 1);\n+\n+      //  x = y * z <-> ( !x + y ) * ( !x + z ) * ( x + !y + !z )\n+      cnf.push_back ({-tseitinVar, litEdge1});\n+      cnf.push_back ({-tseitinVar, litEdge2});\n+      cnf.push_back ({tseitinVar, -litEdge1, -litEdge2});\n+    }\n+  }\n+\n+  // Finally add the root literal to the CNF since the required tree\n+  // now has been built and the root Tseitin variable is accessible.\n+  cnf.push_back ({node_to_var[root.get_node_index ()] *\n+                  (root.is_negated () ? -1 : 1)});\n+  return CraigCnfType::NORMAL;\n+}\n+\n+std::string to_string (const CraigVarType &var_type) {\n+  if (var_type == CraigVarType::A_LOCAL)\n+    return \"A\";\n+  if (var_type == CraigVarType::B_LOCAL)\n+    return \"B\";\n+  if (var_type == CraigVarType::GLOBAL)\n+    return \"G\";\n+  __builtin_unreachable ();\n+}\n+\n+std::ostream &operator<< (std::ostream &out, const CraigVarType &var_type) {\n+  if (var_type == CraigVarType::A_LOCAL)\n+    out << \"A\";\n+  if (var_type == CraigVarType::B_LOCAL)\n+    out << \"B\";\n+  if (var_type == CraigVarType::GLOBAL)\n+    out << \"G\";\n+  return out;\n+}\n+\n+std::string to_string (const CraigClauseType &clause_type) {\n+  if (clause_type == CraigClauseType::A_CLAUSE)\n+    return \"A\";\n+  if (clause_type == CraigClauseType::B_CLAUSE)\n+    return \"B\";\n+  if (clause_type == CraigClauseType::L_CLAUSE)\n+    return \"L\";\n+  __builtin_unreachable ();\n+}\n+\n+std::ostream &operator<< (std::ostream &out,\n+                          const CraigClauseType &clause_type) {\n+  if (clause_type == CraigClauseType::A_CLAUSE)\n+    out << \"A\";\n+  if (clause_type == CraigClauseType::B_CLAUSE)\n+    out << \"B\";\n+  if (clause_type == CraigClauseType::L_CLAUSE)\n+    out << \"L\";\n+  return out;\n+}\n+\n+struct CraigData {\n+  AigEdge partial_interpolant_sym;\n+  AigEdge partial_interpolant_asym;\n+  AigEdge partial_interpolant_dual_sym;\n+  AigEdge partial_interpolant_dual_asym;\n+  CraigClauseType clause_type;\n+  size_t craig_id;\n+\n+  bool isPure () const { return clause_type != CraigClauseType::L_CLAUSE; }\n+};\n+\n+// ----------------------------------------------------------------------------\n+// Computation of Craig interpolants\n+// ----------------------------------------------------------------------------\n+\n+CraigTracer::CraigTracer ()\n+    : CaDiCaL::Tracer (), marked_history (), marked_lits (),\n+      craig_clause_current_id (1), craig_clause_ids (), craig_var_labels (),\n+      craig_clause_labels (),\n+      craig_constraint_label (CraigClauseType::L_CLAUSE), craig_clauses (),\n+      craig_interpolants (), craig_construction (CraigConstruction::NONE),\n+      craig_id (0), craig_interpolant (0), craig_aig_sym (new Aig ()),\n+      craig_aig_asym (new Aig ()), craig_aig_dual_sym (new Aig ()),\n+      craig_aig_dual_asym (new Aig ()) {}\n+\n+CraigTracer::~CraigTracer () {\n+  for (auto &[id, interpolant] : craig_interpolants)\n+    delete interpolant;\n+  if (craig_interpolant)\n+    delete craig_interpolant;\n+\n+  delete craig_aig_sym;\n+  delete craig_aig_asym;\n+  delete craig_aig_dual_sym;\n+  delete craig_aig_dual_asym;\n+};\n+\n+void CraigTracer::set_craig_construction (\n+    CraigConstruction craig_construction) {\n+  assert (craig_clauses.empty ());\n+  this->craig_construction = craig_construction;\n+}\n+\n+void CraigTracer::clear_craig_interpolant () { craig_interpolant = 0; }\n+\n+bool CraigTracer::has_craig_interpolant () {\n+  return craig_interpolant != 0;\n+}\n+\n+void CraigTracer::label_variable (int id, CraigVarType variable_type) {\n+  assert (id > 0);\n+  craig_var_labels[id] = variable_type;\n+  marked_lits[id] = 0;\n+}\n+\n+void CraigTracer::label_clause (int id, CraigClauseType clause_type) {\n+  assert (id > 0);\n+  craig_clause_labels[id] = clause_type;\n+}\n+\n+void CraigTracer::label_constraint (CraigClauseType clause_type) {\n+  craig_constraint_label = clause_type;\n+}\n+\n+void CraigTracer::add_original_clause (uint64_t id, bool redundant,\n+                                       const std::vector<int> &c,\n+                                       bool restore) {\n+  assert (id > 0);\n+  (void) redundant;\n+\n+  if (!restore) {\n+    craig_clause_ids[id] = craig_clause_current_id++;\n+  }\n+\n+  int original_id = craig_clause_ids[id];\n+\n+#ifndef NDEBUG\n+  assert (craig_clause_labels.find (original_id) !=\n+          craig_clause_labels.end ());\n+  for (auto &l : c) {\n+    assert (craig_var_labels.find (std::abs (l)) !=\n+            craig_var_labels.end ());\n+  }\n+#endif\n+\n+  auto clause_label = craig_clause_labels[original_id];\n+  auto *interpolant = create_interpolant_for_clause (c, clause_label);\n+\n+  craig_clauses[id] = c;\n+  craig_interpolants[id] = interpolant;\n+}\n+\n+void CraigTracer::add_derived_clause (\n+    uint64_t id, bool redundant, const std::vector<int> &c,\n+    const std::vector<uint64_t> &proof_chain) {\n+  assert (proof_chain.size () >= 1);\n+  (void) redundant;\n+\n+#ifndef NDEBUG\n+  for (auto &clause : proof_chain)\n+    assert (craig_interpolants.find (clause) != craig_interpolants.end ());\n+#endif\n+\n+  // Mark literals of conflicting clause.\n+  for (auto &l : craig_clauses[proof_chain.back ()])\n+    mark_literal (l);\n+\n+  // Find pivot literal of each clause that was resolved with\n+  // and extend Craig interpolant for it.\n+  auto *interpolant =\n+      new CraigData (*craig_interpolants[proof_chain.back ()]);\n+  for (int i = proof_chain.size () - 2; i >= 0; i--) {\n+    for (auto &l : craig_clauses[proof_chain[i]]) {\n+      // Function mark_literal returns true if inverse literal was marked\n+      // before and marks literal l for the following resolvent literal\n+      // checks.\n+      if (!mark_literal (l))\n+        continue;\n+\n+      extend_interpolant_with_resolution (\n+          *interpolant, -l, *craig_interpolants[proof_chain[i]]);\n+    }\n+  }\n+  unmark_all ();\n+\n+  craig_clauses[id] = c;\n+  craig_interpolants[id] = interpolant;\n+}\n+\n+void CraigTracer::add_assumption_clause (\n+    uint64_t id, const std::vector<int> &c,\n+    const std::vector<uint64_t> &proof_chain) {\n+  CraigData *interpolant = 0;\n+\n+  if (proof_chain.size () > 0) {\n+    // We have a resolution of multiple clauses and therefore reuse\n+    // the existing code to build our Craig interpolant.\n+    add_derived_clause (id, true, c, proof_chain);\n+    interpolant = craig_interpolants[id];\n+  } else {\n+    assert (c.size () == 2);\n+    bool c0_is_assumption =\n+        (assumptions.find (-c[0]) != assumptions.end ());\n+    bool c1_is_assumption =\n+        (assumptions.find (-c[1]) != assumptions.end ());\n+\n+    if (!c0_is_assumption || !c1_is_assumption) {\n+      int l = c0_is_assumption ? -c[1] : -c[0];\n+      craig_clauses[id] = {l};\n+      craig_interpolants[id] = create_interpolant_for_assumption (-l);\n+\n+      assumption_clauses.push_back (id);\n+      return;\n+    }\n+  }\n+\n+  for (auto &lit : c) {\n+    bool is_assumption = (assumptions.find (-lit) != assumptions.end ());\n+    if (!is_assumption) {\n+      continue;\n+    }\n+\n+    auto *other = create_interpolant_for_assumption (-lit);\n+    if (interpolant) {\n+      extend_interpolant_with_resolution (*interpolant, lit, *other);\n+      delete other;\n+    } else {\n+      interpolant = other;\n+    }\n+  }\n+\n+  craig_clauses[id] = c;\n+  craig_interpolants[id] = interpolant;\n+\n+  assumption_clauses.push_back (id);\n+}\n+\n+void CraigTracer::delete_clause (uint64_t id, bool redundant,\n+                                 const std::vector<int> &c) {\n+  (void) redundant;\n+  (void) c;\n+\n+  auto it1 = craig_clauses.find (id);\n+  assert (it1 != craig_clauses.end ());\n+  craig_clauses.erase (it1);\n+\n+  auto it2 = craig_interpolants.find (id);\n+  assert (it2 != craig_interpolants.end ());\n+  delete it2->second;\n+  craig_interpolants.erase (it2);\n+}\n+\n+void CraigTracer::add_assumption (int lit) { assumptions.insert (lit); }\n+\n+void CraigTracer::add_constraint (const std::vector<int> &c) {\n+  constraint = c;\n+}\n+\n+void CraigTracer::reset_assumptions () {\n+  for (auto &id : assumption_clauses) {\n+    delete_clause (id, true, craig_clauses[id]);\n+  }\n+  assumptions.clear ();\n+  constraint.clear ();\n+  assumption_clauses.clear ();\n+}\n+\n+void CraigTracer::conclude_unsat (\n+    CaDiCaL::ConclusionType conclusion,\n+    const std::vector<uint64_t> &proof_chain) {\n+  if (craig_interpolant) {\n+    delete craig_interpolant;\n+    craig_interpolant = 0;\n+  }\n+\n+  CraigData *interpolant = 0;\n+  if (conclusion == CaDiCaL::ConclusionType::CONFLICT) {\n+    // There is a single global conflict.\n+    // The proof_chain contains a single empty clause.\n+    // chain = (c1), c1 = {}\n+    assert (proof_chain.size () == 1);\n+    assert (craig_clauses[proof_chain[0]].empty ());\n+    interpolant = new CraigData (*craig_interpolants[proof_chain[0]]);\n+  } else if (conclusion == CaDiCaL::ConclusionType::ASSUMPTIONS) {\n+    // One or more constraints are responsible for the conflict.\n+    // The proof_chain contains a single clause with failing assumptions.\n+    // The interpolant of that clause already has been resolved with\n+    // assumption interpolants. chain = (c1), c1 = { -a1, -a2, -a3, ... }\n+    assert (proof_chain.size () == 1);\n+    assert (craig_clauses[proof_chain[0]].size () > 0);\n+    interpolant = new CraigData (*craig_interpolants[proof_chain[0]]);\n+  } else if (conclusion == CaDiCaL::ConclusionType::CONSTRAINT) {\n+    // The constraint clause is responsible for the conflict.\n+\n+    // Mark literals of conflicting clause.\n+    for (auto &l : constraint)\n+      mark_literal (l);\n+\n+    // Find pivot literal of each clause that was resolved with\n+    // and extend Craig interpolant for it.\n+    interpolant =\n+        create_interpolant_for_clause (constraint, craig_constraint_label);\n+    for (int i = proof_chain.size () - 1; i >= 0; i--) {\n+      for (auto &l : craig_clauses[proof_chain[i]]) {\n+        // Function mark_literal returns true if inverse literal was marked\n+        // before and marks literal l for the following resolvent literal\n+        // checks.\n+        if (!mark_literal (l))\n+          continue;\n+\n+        extend_interpolant_with_resolution (\n+            *interpolant, -l, *craig_interpolants[proof_chain[i]]);\n+      }\n+    }\n+\n+    unmark_all ();\n+  } else {\n+    assert (false); // No conclusion given!\n+  }\n+\n+  craig_interpolant = interpolant;\n+}\n+\n+CraigData *CraigTracer::create_interpolant_for_assumption (int literal) {\n+  assert (craig_var_labels.find (abs (literal)) != craig_var_labels.end ());\n+\n+  CraigVarType varType = craig_var_labels[abs (literal)];\n+  if (varType == CraigVarType::A_LOCAL) {\n+    return new CraigData (\n+        {.partial_interpolant_sym = craig_aig_sym->get_false (),\n+         .partial_interpolant_asym = craig_aig_asym->get_false (),\n+         .partial_interpolant_dual_sym = craig_aig_dual_sym->get_true (),\n+         .partial_interpolant_dual_asym = craig_aig_dual_asym->get_false (),\n+         .clause_type = CraigClauseType::A_CLAUSE,\n+         .craig_id = craig_id++});\n+  } else if (varType == CraigVarType::B_LOCAL) {\n+    return new CraigData (\n+        {.partial_interpolant_sym = craig_aig_sym->get_true (),\n+         .partial_interpolant_asym = craig_aig_asym->get_true (),\n+         .partial_interpolant_dual_sym = craig_aig_dual_sym->get_false (),\n+         .partial_interpolant_dual_asym = craig_aig_dual_asym->get_true (),\n+         .clause_type = CraigClauseType::B_CLAUSE,\n+         .craig_id = craig_id++});\n+  } else if (varType == CraigVarType::GLOBAL) {\n+    return new CraigData (\n+        {.partial_interpolant_sym = craig_aig_sym->get_true (),\n+         .partial_interpolant_asym = craig_aig_asym->get_true (),\n+         .partial_interpolant_dual_sym = craig_aig_dual_sym->get_false (),\n+         .partial_interpolant_dual_asym = craig_aig_dual_asym->get_false (),\n+         .clause_type = CraigClauseType::L_CLAUSE,\n+         .craig_id = craig_id++});\n+  } else {\n+    assert (false); // Encountered invalid variable type!\n+    __builtin_unreachable ();\n+  }\n+}\n+\n+CraigData *\n+CraigTracer::create_interpolant_for_clause (const std::vector<int> &clause,\n+                                            CraigClauseType clause_type) {\n+  auto result = new CraigData (\n+      {.partial_interpolant_sym = craig_aig_sym->get_true (),\n+       .partial_interpolant_asym = craig_aig_asym->get_true (),\n+       .partial_interpolant_dual_sym = craig_aig_dual_sym->get_true (),\n+       .partial_interpolant_dual_asym = craig_aig_dual_asym->get_true (),\n+       .clause_type = clause_type,\n+       .craig_id = craig_id++});\n+\n+  if (is_construction_enabled (CraigConstruction::SYMMETRIC)) {\n+    if (clause_type == CraigClauseType::A_CLAUSE) {\n+      result->partial_interpolant_sym = craig_aig_sym->get_false ();\n+    } else if (clause_type == CraigClauseType::B_CLAUSE) {\n+      result->partial_interpolant_sym = craig_aig_sym->get_true ();\n+    }\n+  }\n+  if (is_construction_enabled (CraigConstruction::ASYMMETRIC)) {\n+    if (clause_type == CraigClauseType::A_CLAUSE) {\n+      std::vector<AigEdge> literals;\n+      for (size_t i = 0; i < clause.size (); ++i) {\n+        if (craig_var_labels[abs (clause[i])] == CraigVarType::GLOBAL) {\n+          literals.push_back (craig_aig_asym->create_literal (clause[i]));\n+        }\n+      }\n+      result->partial_interpolant_asym =\n+          craig_aig_asym->create_or (literals);\n+    } else if (clause_type == CraigClauseType::B_CLAUSE) {\n+      result->partial_interpolant_asym = craig_aig_asym->get_true ();\n+    }\n+  }\n+  if (is_construction_enabled (CraigConstruction::DUAL_SYMMETRIC)) {\n+    if (clause_type == CraigClauseType::A_CLAUSE) {\n+      result->partial_interpolant_dual_sym =\n+          craig_aig_dual_sym->get_true ();\n+    } else if (clause_type == CraigClauseType::B_CLAUSE) {\n+      result->partial_interpolant_dual_sym =\n+          craig_aig_dual_sym->get_false ();\n+    }\n+  }\n+  if (is_construction_enabled (CraigConstruction::DUAL_ASYMMETRIC)) {\n+    if (clause_type == CraigClauseType::A_CLAUSE) {\n+      result->partial_interpolant_dual_asym =\n+          craig_aig_dual_asym->get_false ();\n+    } else if (clause_type == CraigClauseType::B_CLAUSE) {\n+      std::vector<AigEdge> literals;\n+      for (size_t i = 0; i < clause.size (); ++i) {\n+        if (craig_var_labels[abs (clause[i])] == CraigVarType::GLOBAL) {\n+          literals.push_back (\n+              craig_aig_dual_asym->create_literal (-clause[i]));\n+        }\n+      }\n+      result->partial_interpolant_dual_asym =\n+          craig_aig_dual_asym->create_and (literals);\n+    }\n+  }\n+\n+  return result;\n+}\n+\n+void CraigTracer::extend_interpolant_with_resolution (\n+    CraigData &result, int literal, const CraigData &craig_data) {\n+  if (result.clause_type != craig_data.clause_type) {\n+    result.clause_type = CraigClauseType::L_CLAUSE;\n+  }\n+\n+  if (is_construction_enabled (CraigConstruction::SYMMETRIC)) {\n+    if (craig_var_labels[abs (literal)] == CraigVarType::A_LOCAL) {\n+      result.partial_interpolant_sym =\n+          craig_aig_sym->create_or (result.partial_interpolant_sym,\n+                                    craig_data.partial_interpolant_sym);\n+    } else if (craig_var_labels[abs (literal)] == CraigVarType::B_LOCAL) {\n+      result.partial_interpolant_sym =\n+          craig_aig_sym->create_and (result.partial_interpolant_sym,\n+                                     craig_data.partial_interpolant_sym);\n+    } else {\n+      result.partial_interpolant_sym = craig_aig_sym->create_and (\n+          craig_aig_sym->create_or (\n+              result.partial_interpolant_sym,\n+              craig_aig_sym->create_literal (literal)),\n+          craig_aig_sym->create_or (\n+              craig_data.partial_interpolant_sym,\n+              craig_aig_sym->create_literal (-literal)));\n+    }\n+  }\n+  if (is_construction_enabled (CraigConstruction::ASYMMETRIC)) {\n+    if (craig_var_labels[abs (literal)] == CraigVarType::A_LOCAL) {\n+      result.partial_interpolant_asym =\n+          craig_aig_asym->create_or (result.partial_interpolant_asym,\n+                                     craig_data.partial_interpolant_asym);\n+    } else {\n+      result.partial_interpolant_asym =\n+          craig_aig_asym->create_and (result.partial_interpolant_asym,\n+                                      craig_data.partial_interpolant_asym);\n+    }\n+  }\n+  if (is_construction_enabled (CraigConstruction::DUAL_SYMMETRIC)) {\n+    if (craig_var_labels[abs (literal)] == CraigVarType::A_LOCAL) {\n+      result.partial_interpolant_dual_sym = craig_aig_dual_sym->create_and (\n+          result.partial_interpolant_dual_sym,\n+          craig_data.partial_interpolant_dual_sym);\n+    } else if (craig_var_labels[abs (literal)] == CraigVarType::B_LOCAL) {\n+      result.partial_interpolant_dual_sym = craig_aig_dual_sym->create_or (\n+          result.partial_interpolant_dual_sym,\n+          craig_data.partial_interpolant_dual_sym);\n+    } else {\n+      result.partial_interpolant_dual_sym = craig_aig_dual_sym->create_or (\n+          craig_aig_dual_sym->create_and (\n+              result.partial_interpolant_dual_sym,\n+              craig_aig_dual_sym->create_literal (-literal)),\n+          craig_aig_dual_sym->create_and (\n+              craig_data.partial_interpolant_dual_sym,\n+              craig_aig_dual_sym->create_literal (literal)));\n+    }\n+  }\n+  if (is_construction_enabled (CraigConstruction::DUAL_ASYMMETRIC)) {\n+    if (craig_var_labels[abs (literal)] == CraigVarType::B_LOCAL) {\n+      result.partial_interpolant_dual_asym =\n+          craig_aig_dual_asym->create_and (\n+              result.partial_interpolant_dual_asym,\n+              craig_data.partial_interpolant_dual_asym);\n+    } else {\n+      result.partial_interpolant_dual_asym =\n+          craig_aig_dual_asym->create_or (\n+              result.partial_interpolant_dual_asym,\n+              craig_data.partial_interpolant_dual_asym);\n+    }\n+  }\n+}\n+\n+CraigCnfType\n+CraigTracer::create_craig_interpolant (CraigInterpolant interpolant,\n+                                       std::vector<std::vector<int>> &cnf,\n+                                       int &nextFreeVariable) {\n+  cnf.clear ();\n+\n+  if (!has_craig_interpolant ()) {\n+    return CraigCnfType::NONE;\n+  }\n+\n+  bool build_cnf_sym = false;\n+  bool build_cnf_asym = false;\n+  bool build_cnf_dual_sym = false;\n+  bool build_cnf_dual_asym = false;\n+  switch (interpolant) {\n+  case CraigInterpolant::NONE:\n+    break;\n+  case CraigInterpolant::SYMMETRIC:\n+    build_cnf_sym = is_construction_enabled (CraigConstruction::SYMMETRIC);\n+    break;\n+  case CraigInterpolant::ASYMMETRIC:\n+    build_cnf_asym = is_construction_enabled (CraigConstruction::ASYMMETRIC);\n+    break;\n+  case CraigInterpolant::DUAL_SYMMETRIC:\n+    build_cnf_dual_sym = is_construction_enabled (CraigConstruction::DUAL_SYMMETRIC);\n+    break;\n+  case CraigInterpolant::DUAL_ASYMMETRIC:\n+    build_cnf_dual_asym = is_construction_enabled (CraigConstruction::DUAL_ASYMMETRIC);\n+    break;\n+  case CraigInterpolant::INTERSECTION:\n+  case CraigInterpolant::UNION:\n+  case CraigInterpolant::SMALLEST:\n+  case CraigInterpolant::LARGEST:\n+    build_cnf_sym = is_construction_enabled (CraigConstruction::SYMMETRIC);\n+    build_cnf_asym = is_construction_enabled (CraigConstruction::ASYMMETRIC);\n+    build_cnf_dual_sym = is_construction_enabled (CraigConstruction::DUAL_SYMMETRIC);\n+    build_cnf_dual_asym = is_construction_enabled (CraigConstruction::DUAL_ASYMMETRIC);\n+    break;\n+\n+  default:\n+    assert (false); // Seleted craig interpolation type not supported!\n+    __builtin_unreachable ();\n+  }\n+\n+  std::vector<std::vector<int>> craig_cnf_sym;\n+  std::vector<std::vector<int>> craig_cnf_asym;\n+  std::vector<std::vector<int>> craig_cnf_dual_sym;\n+  std::vector<std::vector<int>> craig_cnf_dual_asym;\n+  CraigCnfType craig_cnf_type_sym = CraigCnfType::NONE;\n+  CraigCnfType craig_cnf_type_asym = CraigCnfType::NONE;\n+  CraigCnfType craig_cnf_type_dual_sym = CraigCnfType::NONE;\n+  CraigCnfType craig_cnf_type_dual_asym = CraigCnfType::NONE;\n+\n+  if (build_cnf_sym)\n+    craig_cnf_type_sym = craig_aig_sym->create_cnf (\n+        craig_interpolant->partial_interpolant_sym,\n+        craig_cnf_sym, nextFreeVariable);\n+  if (build_cnf_asym)\n+    craig_cnf_type_asym = craig_aig_asym->create_cnf (\n+        craig_interpolant->partial_interpolant_asym,\n+        craig_cnf_asym, nextFreeVariable);\n+  if (build_cnf_dual_sym)\n+    craig_cnf_type_dual_sym = craig_aig_dual_sym->create_cnf (\n+        craig_interpolant->partial_interpolant_dual_sym,\n+        craig_cnf_dual_sym, nextFreeVariable);\n+  if (build_cnf_dual_asym)\n+    craig_cnf_type_dual_asym = craig_aig_dual_asym->create_cnf (\n+        craig_interpolant->partial_interpolant_dual_asym,\n+        craig_cnf_dual_asym, nextFreeVariable);\n+\n+  // Dual Craig interpolants have to be inverted.\n+  // However, the construction rules for the dual asymmetric interpolant\n+  // already incorporates the negation. So only the dual symmetric\n+  // interpolant needs to be negated.\n+  if (craig_cnf_type_dual_sym == CraigCnfType::CONSTANT1) {\n+    craig_cnf_dual_sym = {{}};\n+    craig_cnf_type_dual_sym = CraigCnfType::CONSTANT0;\n+  } else if (craig_cnf_type_dual_sym == CraigCnfType::CONSTANT0) {\n+    craig_cnf_dual_sym = {};\n+    craig_cnf_type_dual_sym = CraigCnfType::CONSTANT1;\n+  } else if (craig_cnf_type_dual_sym == CraigCnfType::NORMAL) {\n+    craig_cnf_dual_sym.back ()[0] = -craig_cnf_dual_sym.back ()[0];\n+  }\n+\n+  if (interpolant == CraigInterpolant::NONE) {\n+    cnf = {};\n+    return CraigCnfType::NONE;\n+  } else if (interpolant == CraigInterpolant::SYMMETRIC) {\n+    cnf = std::move (craig_cnf_sym);\n+    return craig_cnf_type_sym;\n+  } else if (interpolant == CraigInterpolant::ASYMMETRIC) {\n+    cnf = std::move (craig_cnf_asym);\n+    return craig_cnf_type_asym;\n+  } else if (interpolant == CraigInterpolant::DUAL_SYMMETRIC) {\n+    cnf = std::move (craig_cnf_dual_sym);\n+    return craig_cnf_type_dual_sym;\n+  } else if (interpolant == CraigInterpolant::DUAL_ASYMMETRIC) {\n+    cnf = std::move (craig_cnf_dual_asym);\n+    return craig_cnf_type_dual_asym;\n+  }\n+\n+  std::vector<std::tuple<std::vector<std::vector<int>> *, CraigCnfType>>\n+      craig_cnfs{};\n+  if (craig_cnf_type_sym != CraigCnfType::NONE)\n+    craig_cnfs.push_back ({&craig_cnf_sym, craig_cnf_type_sym});\n+  if (craig_cnf_type_asym != CraigCnfType::NONE)\n+    craig_cnfs.push_back ({&craig_cnf_asym, craig_cnf_type_asym});\n+  if (craig_cnf_type_dual_sym != CraigCnfType::NONE)\n+    craig_cnfs.push_back ({&craig_cnf_dual_sym, craig_cnf_type_dual_sym});\n+  if (craig_cnf_type_dual_asym != CraigCnfType::NONE)\n+    craig_cnfs.push_back ({&craig_cnf_dual_asym, craig_cnf_type_dual_asym});\n+\n+  if (craig_cnfs.size () == 0) {\n+    return CraigCnfType::NONE;\n+  } else if (craig_cnfs.size () == 1) {\n+    cnf = std::move (*std::get<0> (craig_cnfs[0]));\n+    return std::get<1> (craig_cnfs[0]);\n+  }\n+\n+  // We have at least two Craig interpolants for the following computations.\n+  if (interpolant == CraigInterpolant::UNION) {\n+    bool allConstantOne = true;\n+    for (auto [craigCnf, craigCnfType] : craig_cnfs) {\n+      if (craigCnfType == CraigCnfType::CONSTANT0) {\n+        cnf = std::move (*craigCnf);\n+        return CraigCnfType::CONSTANT0;\n+      }\n+      allConstantOne &= (craigCnfType == CraigCnfType::CONSTANT1);\n+    }\n+    if (allConstantOne) {\n+      cnf = {};\n+      return CraigCnfType::CONSTANT1;\n+    }\n+\n+    // Create trigger (t) that enforces all CNF parts.\n+    int craig_trigger = nextFreeVariable++;\n+    std::vector<int> craig_trigger_clause{craig_trigger};\n+    for (auto [craigCnf, craigCnfType] : craig_cnfs) {\n+      if (craigCnfType == CraigCnfType::NORMAL) {\n+        size_t i = 0, j = cnf.size ();\n+        cnf.resize (cnf.size () + craigCnf->size ());\n+        for (; i < craigCnf->size () - 1u; i++, j++)\n+          cnf[j] = std::move ((*craigCnf)[i]);\n+        // The positive trigger implies that all CNF parts are enabled: (t\n+        // -> t_1) = (-t v t_1)\n+        cnf[j] = {-craig_trigger, (*craigCnf)[i][0]};\n+        // The negative trigger implies that at least one of the CNF parts\n+        // is not enabled: (-t -> (-t_1 v ... v -t_n)) = (t v -t_1 v ...\n+        // -t_n)\n+        craig_trigger_clause.push_back (-(*craigCnf)[i][0]);\n+      }\n+    }\n+\n+    cnf.push_back (craig_trigger_clause);\n+    cnf.push_back ({craig_trigger});\n+\n+    return CraigCnfType::NORMAL;\n+  } else if (interpolant == CraigInterpolant::INTERSECTION) {\n+    bool allConstantZero = true;\n+    for (auto [craigCnf, craigCnfType] : craig_cnfs) {\n+      if (craigCnfType == CraigCnfType::CONSTANT1) {\n+        cnf = std::move (*craigCnf);\n+        return CraigCnfType::CONSTANT1;\n+      }\n+      allConstantZero &= (craigCnfType == CraigCnfType::CONSTANT0);\n+    }\n+    if (allConstantZero) {\n+      cnf = {{}};\n+      return CraigCnfType::CONSTANT0;\n+    }\n+\n+    // Create trigger (t) that enforces all CNF parts.\n+    int craig_trigger = nextFreeVariable++;\n+    std::vector<int> craig_trigger_clause{-craig_trigger};\n+    for (auto [craigCnf, craigCnfType] : craig_cnfs) {\n+      if (craigCnfType == CraigCnfType::NORMAL) {\n+        size_t i = 0, j = cnf.size ();\n+        cnf.resize (cnf.size () + craigCnf->size ());\n+        for (; i < craigCnf->size () - 1u; i++, j++)\n+          cnf[j] = std::move ((*craigCnf)[i]);\n+        // The positive trigger implies that one of the CNF parts is\n+        // enabled: (t -> (t_1 v ... v t_n)) = (-t v t_1 v ... t_n)\n+        craig_trigger_clause.push_back ((*craigCnf)[i][0]);\n+        // The negative trigger implies that at all CNF parts are not\n+        // enabled: (-t -> -t_1) = (t v -t_1)\n+        cnf[j] = {craig_trigger, -(*craigCnf)[i][0]};\n+      }\n+    }\n+\n+    cnf.push_back (craig_trigger_clause);\n+    cnf.push_back ({craig_trigger});\n+\n+    return CraigCnfType::NORMAL;\n+  } else if (interpolant == CraigInterpolant::SMALLEST) {\n+    auto compare = [] (auto const &elem1, auto const &elem2) {\n+      auto const &[elem1Cnf, elem1CnfType] = elem1;\n+      auto const &[elem2Cnf, elem2CnfType] = elem2;\n+      return (elem1Cnf->size () < elem2Cnf->size ());\n+    };\n+    auto minimum =\n+        std::min_element (craig_cnfs.begin (), craig_cnfs.end (), compare);\n+    auto [minCnf, minCnfType] = *minimum;\n+    cnf = std::move (*minCnf);\n+    return minCnfType;\n+  } else if (interpolant == CraigInterpolant::LARGEST) {\n+    auto compare = [] (auto const &elem1, auto const &elem2) {\n+      auto const &[elem1Cnf, elem1CnfType] = elem1;\n+      auto const &[elem2Cnf, elem2CnfType] = elem2;\n+      return (elem1Cnf->size () < elem2Cnf->size ());\n+    };\n+    auto maximum =\n+        std::max_element (craig_cnfs.begin (), craig_cnfs.end (), compare);\n+    auto [maxCnf, maxCnfType] = *maximum;\n+    cnf = std::move (*maxCnf);\n+    return maxCnfType;\n+  } else {\n+    assert (false); // Seleted craig interpolation type not supported!\n+    __builtin_unreachable ();\n+  }\n+}\n+\n+bool CraigTracer::is_construction_enabled (CraigConstruction construction) {\n+  return static_cast<uint8_t> (construction) &\n+         static_cast<uint8_t> (craig_construction);\n+}\n+\n+uint8_t CraigTracer::mark_literal (int literal) {\n+  int index = std::abs (literal);\n+  uint8_t mask = (literal < 0) ? 2 : 1;\n+\n+  uint8_t was_marked = marked_lits[index];\n+  if (!was_marked)\n+    marked_history.push_back (index);\n+  if (!(was_marked & mask))\n+    marked_lits[index] |= mask;\n+  return was_marked & ~mask;\n+}\n+\n+void CraigTracer::unmark_all () {\n+  for (auto &index : marked_history) {\n+    marked_lits[index] = 0;\n+  }\n+  marked_history.clear ();\n+}\n+\n+} // namespace CaDiCraig\ndiff --git a/contrib/craigtracer.hpp b/contrib/craigtracer.hpp\nnew file mode 100644\nindex 000000000..4f07e7c26\n--- /dev/null\n+++ b/contrib/craigtracer.hpp\n@@ -0,0 +1,200 @@\n+// SPDX-License-Identifier: MIT OR Apache-2.0\n+// Copyright 2013 Stefan Kupferschmid\n+// Copyright 2023 Florian Pollitt\n+// Copyright 2023 Tobias Faller\n+\n+#ifndef _craigtracer_hpp_INCLUDED\n+#define _craigtracer_hpp_INCLUDED\n+\n+#include \"cadical.hpp\"\n+#include \"tracer.hpp\"\n+\n+#include <iostream>\n+#include <map>\n+#include <set>\n+#include <string>\n+#include <vector>\n+\n+namespace CaDiCraig {\n+\n+class Aig;\n+class CraigData;\n+\n+enum class CraigCnfType : uint8_t { NONE, CONSTANT0, CONSTANT1, NORMAL };\n+\n+enum class CraigConstruction : uint8_t {\n+  NONE = 0,\n+  SYMMETRIC = 1,\n+  ASYMMETRIC = 2,\n+  DUAL_SYMMETRIC = 4,\n+  DUAL_ASYMMETRIC = 8,\n+  ALL = 15\n+};\n+\n+enum class CraigInterpolant : uint8_t {\n+  NONE,\n+  SYMMETRIC,\n+  ASYMMETRIC,\n+  DUAL_SYMMETRIC,\n+  DUAL_ASYMMETRIC,\n+  INTERSECTION,\n+  UNION,\n+  SMALLEST,\n+  LARGEST\n+};\n+\n+CraigConstruction operator| (const CraigConstruction &first,\n+                             const CraigConstruction &second);\n+\n+enum class CraigVarType : uint8_t { A_LOCAL, B_LOCAL, GLOBAL };\n+\n+std::string to_string (const CraigVarType &var_type);\n+std::ostream &operator<< (std::ostream &out, const CraigVarType &var_type);\n+\n+enum class CraigClauseType : uint8_t { A_CLAUSE, B_CLAUSE, L_CLAUSE };\n+\n+std::string to_string (const CraigClauseType &clause_type);\n+std::ostream &operator<< (std::ostream &,\n+                          const CraigClauseType &clause_type);\n+\n+class CraigTracer : public CaDiCaL::Tracer {\n+public:\n+  CraigTracer ();\n+  virtual ~CraigTracer ();\n+\n+  // ====== BEGIN CRAIG INTERFACE ==========================================\n+\n+  // Add variable of A, B or G type. This has to be called before\n+  // adding clauses using the variables when Craig interpolation is enabled.\n+  // - A_LOCAL\n+  // - B_LOCAL\n+  // - GLOBAL\n+  //\n+  //   require (VALID)\n+  //\n+  void label_variable (int id, CraigVarType variable_type);\n+\n+  // Add clause type of A or B. This has to be called right\n+  // before adding the respective clause that this type applies to.\n+  // - A_CLAUSE\n+  // - B_CLAUSE\n+  //\n+  //   require (VALID)\n+  //\n+  void label_clause (int id, CraigClauseType clause_type);\n+\n+  // Set constraint type to A or B. This has to be done before calling\n+  // solve.\n+  // - A_CLAUSE\n+  // - B_CLAUSE\n+  //\n+  //   require (VALID)\n+  //\n+  void label_constraint (CraigClauseType clause_type);\n+\n+  // A bit field that configures the Craig interpolant bases to be built.\n+  // The following interpolant bases can be built:\n+  // - SYMMETRIC\n+  // - ASYMMETRIC\n+  // - DUAL_SYMMETRIC\n+  // - DUAL_ASYMMETRIC\n+  //\n+  //   require (CONFIGURING)\n+  //   ensure (CONFIGURING)\n+  //\n+  void set_craig_construction (CraigConstruction craig_construction);\n+\n+  // Builds the Craig interpolant specified and writes the result\n+  // to the output vector. Required Tseitin variables for CNF creation\n+  // will start from the tseitin_offset provided.\n+  // The following interpolants are available:\n+  // - NONE\n+  // - SYMMETRIC (requires base SYMMETRIC)\n+  // - ASYMMETRIC (requires base ASYMMETRIC)\n+  // - DUAL_SYMMETRIC (requires base DUAL_SYMMETRIC)\n+  // - DUAL_ASYMMETRIC (requires base DUAL_ASYMMETRIC)\n+  // - INTERSECTION (of selected interpolant bases)\n+  // - UNION (of selected interpolant bases)\n+  // - SMALLEST (of selected interpolant bases)\n+  // - LARGEST (of selected interpolant bases)\n+  //\n+  // Returns the resulting CNF type.\n+  // The result can be NONE when either no Interpolant was requested\n+  // or if the construction of the craig interpolant is not enabled.\n+  // The NORMAL type CNF contains a unit clause with the trigger\n+  // for the Craig interpolant as the last clause.\n+  // The following CNF types can be returned by the function:\n+  // - NONE\n+  // - CONSTANT0 (CNF is constant false)\n+  // - CONSTANT1 (CNF is constant true)\n+  // - NORMAL (CNF is not constant)\n+  //\n+  //   require (UNSATISFIED)\n+  //\n+  CraigCnfType create_craig_interpolant (CraigInterpolant interpolant,\n+                                         std::vector<std::vector<int>> &cnf,\n+                                         int &tseitin_offset);\n+\n+  // ====== END CRAIG INTERFACE ============================================\n+\n+  void add_original_clause (uint64_t id, bool redundant,\n+                            const std::vector<int> &c,\n+                            bool restore) override;\n+  void\n+  add_derived_clause (uint64_t id, bool redundant,\n+                      const std::vector<int> &c,\n+                      const std::vector<uint64_t> &proof_chain) override;\n+  void\n+  add_assumption_clause (uint64_t id, const std::vector<int> &c,\n+                         const std::vector<uint64_t> &proof_chain) override;\n+  void delete_clause (uint64_t id, bool redundant,\n+                      const std::vector<int> &c) override;\n+\n+  void add_assumption (int lit) override;\n+  void add_constraint (const std::vector<int> &c) override;\n+  void reset_assumptions () override;\n+  void conclude_unsat (CaDiCaL::ConclusionType conclusion,\n+                       const std::vector<uint64_t> &proof_chain) override;\n+\n+private:\n+  CraigData *create_interpolant_for_assumption (int literal);\n+  CraigData *create_interpolant_for_clause (const std::vector<int> &c,\n+                                            CraigClauseType t);\n+  void extend_interpolant_with_resolution (CraigData &result, int literal,\n+                                           const CraigData &craig_data);\n+  bool is_construction_enabled (CraigConstruction construction);\n+  void clear_craig_interpolant ();\n+  bool has_craig_interpolant ();\n+\n+  uint8_t mark_literal (int literal);\n+  void unmark_all ();\n+\n+  std::set<int> assumptions;\n+  std::vector<int> constraint;\n+  std::vector<uint64_t> assumption_clauses;\n+\n+  std::vector<int> marked_history;\n+  std::map<int, uint8_t> marked_lits;\n+\n+  int craig_clause_current_id;\n+  std::map<int, uint64_t> craig_clause_ids;\n+  std::map<int, CraigVarType> craig_var_labels;\n+  std::map<int, CraigClauseType> craig_clause_labels;\n+  CraigClauseType craig_constraint_label;\n+\n+  std::map<uint64_t, std::vector<int>> craig_clauses;\n+  std::map<uint64_t, CraigData *> craig_interpolants;\n+\n+  CraigConstruction craig_construction;\n+  size_t craig_id;\n+  CraigData *craig_interpolant;\n+\n+  Aig *craig_aig_sym;\n+  Aig *craig_aig_asym;\n+  Aig *craig_aig_dual_sym;\n+  Aig *craig_aig_dual_asym;\n+};\n+\n+} // namespace CaDiCraig\n+\n+#endif\ndiff --git a/contrib/craigtracer.md b/contrib/craigtracer.md\nnew file mode 100644\nindex 000000000..10f1f601d\n--- /dev/null\n+++ b/contrib/craigtracer.md\n@@ -0,0 +1,177 @@\n+# Introduction\n+\n+The `CraigTracer` builds Craig interpolants via the CaDiCaL tracer interface.\n+The tracer interface notifies about proof resolution steps which the tracer\n+uses to build partial interpolants based on predefined construction rules.\n+Construction of symmetric and asymmetric Craig interpolants is supported.\n+Internally the interpolants are constructed as And-Inverter-Graph (AIG)\n+and a Tseitin transformation converts them into a Conjunctive Normal Form (CNF).\n+\n+## Attaching the Tracer\n+\n+Attach / detach the `CraigTracer` to the CaDiCaL solver via the\n+`connect_proof_tracer` and `disconnect_proof_tracer` methods.\n+The tracer requires antecedents. Therefore it has to be attached with `true`\n+as second argument. The partial Craig interpolant construcion has to be\n+configured before any clauses are added to the solver.\n+\n+```cpp\n+CaDiCaL::Solver solver;\n+CaDiCraig::CraigTracer tracer;\n+solver.connect_proof_tracer (&tracer, true);\n+tracer.set_craig_construction (CaDiCraig::CraigConstruction::ASYMMETRIC);\n+\n+solver.add (...);\n+solver.solve ();\n+\n+solver.disconnect_proof_tracer (&tracer);\n+```\n+\n+## Labelling Variables and Clauses\n+\n+Clauses and variables have to be labelled before they are added to the solver.\n+The methods `label_variable` and `label_clause` provide that and use indices\n+starting from 1 to assign variables / clauses.\n+\n+Label variables via `label_variable` and the following types:\n+- `CaDiCraig::A_LOCAL`\n+- `CaDiCraig::B_LOCAL`\n+- `CaDiCraig::GLOBAL`\n+\n+Label clauses via `label_clause` and the following types:\n+- `CaDiCraig::A_CLAUSE`\n+- `CaDiCraig::B_CLAUSE`\n+\n+```cpp\n+CaDiCaL::Solver solver;\n+CaDiCraig::CraigTracer tracer;\n+solver.connect_proof_tracer (&tracer, true);\n+tracer.set_craig_construction (CaDiCraig::CraigConstruction::ASYMMETRIC);\n+\n+tracer.label_variable (1, CaDiCraig::CraigVarType::GLOBAL);\n+tracer.label_clause (1, CaDiCraig::CraigClauseType::A_CLAUSE);\n+tracer.label_clause (2, CaDiCraig::CraigClauseType::B_CLAUSE);\n+solver.add (-1); solver.add (0);\n+solver.add (1); solver.add (0);\n+solver.solve ();\n+\n+solver.disconnect_proof_tracer (&tracer);\n+```\n+\n+## Getting Craig Interpolants\n+\n+After CaDiCaL returns UNSATISFIABLE from its solve method a Craig interpolant\n+can be built via the `create_craig_interpolant` method. This method converts\n+the AIG containing partial interpolants into a final Craig interpolant in CNF\n+form using the Tseitin transformation.\n+\n+Multiple partial interpolants can be built during solving to later be used\n+for building a final interpolant.\n+- `CaDiCraig::SYMMETRIC`\n+- `CaDiCraig::ASYMMETRIC`\n+- `CaDiCraig::DUAL_SYMMETRIC`\n+- `CaDiCraig::DUAL_ASYMMETRIC`\n+\n+The following final interpolants are implemented. The INTERSECTION, UNION,\n+SMALLEST and LARGEST interpolants are based on all the enabled partial\n+interpolants.\n+\n+- `CaDiCraig::NONE`\n+- `CaDiCraig::SYMMETRIC` (requires partial interpolant SYMMETRIC)\n+- `CaDiCraig::ASYMMETRIC` (requires partial interpolant ASYMMETRIC)\n+- `CaDiCraig::DUAL_SYMMETRIC` (requires partial interpolant DUAL_SYMMETRIC)\n+- `CaDiCraig::DUAL_ASYMMETRIC` (requires partial interpolant DUAL_ASYMMETRIC)\n+- `CaDiCraig::INTERSECTION` (of selected partial interpolants)\n+- `CaDiCraig::UNION` (of selected partial interpolants)\n+- `CaDiCraig::SMALLEST` (of selected partial interpolants)\n+- `CaDiCraig::LARGEST` (of selected partial interpolants)\n+\n+The `create_craig_interpolant` method returns the CNF that has been created.\n+A CNF of type NORMAL denotes that a Tseitin transformation has been applied.\n+CONST0 and CONST1 are returned if the AIG is constant. The NONE type\n+is returned when CaDiCaL provided a result different than UNSATISFIABLE\n+or when the required partial interpolants are not enabled.\n+\n+- `CaDiCraig::NONE`\n+- `CaDiCraig::CONSTANT0` (CNF is constant false)\n+- `CaDiCraig::CONSTANT1` (CNF is constant true)\n+- `CaDiCraig::NORMAL` (CNF is not constant)\n+\n+```cpp\n+CaDiCaL::Solver solver;\n+CaDiCraig::CraigTracer tracer;\n+solver.connect_proof_tracer (&tracer, true);\n+tracer.set_craig_construction (CaDiCraig::CraigConstruction::ASYMMETRIC);\n+\n+tracer.label_variable (...);\n+tracer.label_clause (...);\n+solver.add (...);\n+\n+if (solver.solve () == CaDiCaL::Status::UNSATISFIABLE) {\n+  // Indices of Tseitin variables that are used when converting the\n+  // Craig interpolant AIG to a CNF. The end_variable parameter\n+  // is updated by the create_craig_interpolant method.\n+  int first_variable = solver.vars () + 1;\n+  int end_variable = first_variable;\n+  std::vector<std::vector<int>> interpolant;\n+  CaDiCraig::CraigCnfType result = tracer.create_craig_interpolant (\n+    CaDiCraig::CraigInterpolant::ASYMMETRIC, interpolant, end_variable);\n+\n+  // Printing created Tseitin variables:\n+  for (int i = first_variable; i < end_variable; i++) {\n+    printf(\"Tseiting variable %d\\n\", i);\n+  }\n+\n+  // Printing created Craig interpolant clauses:\n+  printf(\"Interpolant CNF type is %s\", to_string(result));\n+  for (int i = 0; i < clauses.size(); i+++) {\n+    printf(\"Interpolant clause (\");\n+    for (int j = 0; j < clauses[i].size(); j++) {\n+      if (j != 0) printf(\", \");\n+      printf(\"%d\", clauses[i][j]);\n+    }\n+    printf(\")\");\n+  }\n+}\n+\n+solver.disconnect_proof_tracer (&tracer);\n+```\n+\n+## Building multiple Interpolants\n+\n+Multiple partial interpolant AIGs can be built automatically. These partial\n+interpolants can be transformed into CNFs independently depending on\n+the present use-case.\n+\n+```cpp\n+CaDiCaL::Solver solver;\n+CaDiCraig::CraigTracer tracer;\n+solver.connect_proof_tracer (&tracer, true);\n+tracer.set_craig_construction (\n+  CaDiCraig::CraigConstruction::ASYMMETRIC\n+  | CaDiCraig::CraigConstruction::DUAL_ASYMMETRIC);\n+\n+tracer.label_variable (...);\n+tracer.label_clause (...);\n+solver.add (...);\n+\n+if (solver.solve () == CaDiCaL::Status::UNSATISFIABLE) {\n+  std::vector<std::vector<int>> cnf_asym;\n+  tracer.create_craig_interpolant (\n+    CaDiCraig::CraigInterpolant::ASYMMETRIC, cnf_asym, ...);\n+\n+  std::vector<std::vector<int>> cnf_dual;\n+  tracer.create_craig_interpolant (\n+    CaDiCraig::CraigInterpolant::DUAL_ASYMMETRIC, cnf_dual, ...);\n+\n+  std::vector<std::vector<int>> cnf_union;\n+  tracer.create_craig_interpolant (\n+    CaDiCraig::CraigInterpolant::UNION, cnf_union, ...);\n+\n+  std::vector<std::vector<int>> cnf_interst;\n+  tracer.create_craig_interpolant (\n+    CaDiCraig::CraigInterpolant::INTERSECTION, cnf_interst, ...);\n+}\n+\n+solver.disconnect_proof_tracer (&tracer);\n+```\ndiff --git a/makefile.in b/makefile.in\nindex 1a21bffca..291cb3e34 100644\n--- a/makefile.in\n+++ b/makefile.in\n@@ -11,18 +11,26 @@ CXX=@CXX@\n CXXFLAGS=@CXXFLAGS@\n \n LIBS=@LIBS@\n+ROOT=@ROOT@\n+CONTRIB=@CONTRIB@\n \n ############################################################################\n #    It is usually not necessary to change anything below this line!       #\n ############################################################################\n \n-APP=cadical.cpp mobical.cpp\n-SRC=$(sort $(wildcard ../src/*.cpp))\n-SUB=$(subst ../src/,,$(SRC))\n-LIB=$(filter-out $(APP),$(SUB))\n-OBJ=$(LIB:.cpp=.o)\n+SRC_APP=src/cadical.cpp src/mobical.cpp\n+SRC_SOLVER=$(subst $(ROOT)/,,$(sort $(wildcard $(ROOT)/src/*.cpp)))\n+SRC_CONTRIB=$(subst $(ROOT)/,,$(sort $(wildcard $(ROOT)/contrib/*.cpp)))\n+\n+FILT_SOLVER=$(filter-out $(SRC_APP),$(SRC_SOLVER))\n+FILT_CONTRIB=$(if $(filter-out no,$(CONTRIB)),$(SRC_CONTRIB),)\n+OBJ_SOLVER=$(FILT_SOLVER:.cpp=.o)\n+OBJ_CONTRIB=$(FILT_CONTRIB:.cpp=.o)\n+\n+# Include for current build directory is required for including the\n+# generated build header build.hpp.\n DIR=../$(shell pwd|sed -e 's,.*/,,')\n-COMPILE=$(CXX) $(CXXFLAGS) -I$(DIR)\n+COMPILE=$(CXX) $(CXXFLAGS) -I$(DIR) -I$(ROOT)/src\n \n #--------------------------------------------------------------------------#\n \n@@ -32,60 +40,66 @@ all: libcadical.a cadical mobical\n \n .SUFFIXES: .cpp .o\n \n-%.o: ../src/%.cpp ../src/*.hpp makefile\n-\t$(COMPILE) -c $<\n+src/%.o: $(ROOT)/src/%.cpp $(ROOT)/src/*.hpp makefile\n+\t@mkdir -p $(dir $@)\n+\t$(COMPILE) -c $< -o $@\n+\n+contrib/%.o: $(ROOT)/contrib/%.cpp $(ROOT)/contrib/%.hpp $(ROOT)/src/*.hpp makefile\n+\t@mkdir -p $(dir $@)\n+\t$(COMPILE) -c $< -o $@\n \n #--------------------------------------------------------------------------#\n \n # Application binaries (the stand alone solver 'cadical' and the model based\n # tester 'mobical') and the library are the main build targets.\n \n-cadical: cadical.o libcadical.a makefile\n+cadical: src/cadical.o libcadical.a makefile\n \t$(COMPILE) -o $@ $< -L. -lcadical $(LIBS)\n \n-mobical: mobical.o libcadical.a makefile $(LIBS)\n+mobical: src/mobical.o libcadical.a makefile $(LIBS)\n \t$(COMPILE) -o $@ $< -L. -lcadical\n \n-libcadical.a: $(OBJ) makefile\n-\tar rc $@ $(OBJ)\n+libcadical.a: $(OBJ_SOLVER) $(OBJ_CONTRIB) makefile\n+\tar rc $@ $(OBJ_SOLVER) $(OBJ_CONTRIB)\n \n #--------------------------------------------------------------------------#\n \n # Note that 'build.hpp' is generated and resides in the build directory.\n \n build.hpp: always\n-\t../scripts/make-build-header.sh > build.hpp\n+\t$(ROOT)/scripts/make-build-header.sh > build.hpp\n \n-version.o: build.hpp\n+src/version.o: build.hpp\n \n update:\n-\t../scripts/update-version.sh\n+\t$(ROOT)/scripts/update-version.sh\n \n #--------------------------------------------------------------------------#\n \n # These two 'C' interfaces include '.h' headers and thus require explicitly\n # defined additional dependencies.\n \n-ccadical.o: ../src/ccadical.h\n-ipasir.o: ../src/ipasir.h ../src/ccadical.h\n+ccadical.o: $(ROOT)/src/ccadical.h\n+ipasir.o: $(ROOT)/src/ipasir.h $(ROOT)/src/ccadical.h\n \n #--------------------------------------------------------------------------#\n \n analyze: all\n-\t$(COMPILE) --analyze ../src/*.cpp\n+\t$(COMPILE) --analyze $(ROOT)/src/*.cpp\n+\t$(COMPILE) --analyze $(ROOT)/contrib/*.cpp\n \n format:\n-\tclang-format -i ../*/*.[ch]pp\n-\tclang-format -i ../*/*.[ch]\n-\tclang-format -i ../test/*/*.[ch]pp\n-\tclang-format -i ../test/*/*.[ch]\n+\tclang-format -i $(ROOT)/*/*.[ch]pp\n+\tclang-format -i $(ROOT)/*/*.[ch]\n+\tclang-format -i $(ROOT)/test/*/*.[ch]pp\n+\tclang-format -i $(ROOT)/test/*/*.[ch]\n \n clean:\n \trm -f *.o *.a cadical mobical makefile build.hpp\n \trm -f *.gcda *.gcno *.gcov gmon.out\n \n test: all\n-\tCADICALBUILD=\"$(DIR)\" $(MAKE) -j1 -C ../test\n+\tCADICALBUILD=\"$(DIR)\" $(MAKE) -j1 -C $(ROOT)/test\n \n #--------------------------------------------------------------------------#\n \ndiff --git a/test/contrib/README.md b/test/contrib/README.md\nnew file mode 100644\nindex 000000000..9b7453536\n--- /dev/null\n+++ b/test/contrib/README.md\n@@ -0,0 +1,8 @@\n+These are unit tests of the contributed code executed with `run.sh` which\n+actually needs to be called from an immediate sub-directory of CaDiCaL.\n+\n+The binary and results of the tests are put into the build directory.\n+\n+The `makefile` allows to compile and execute the tests from within this\n+sub-directory with a single `make` command, but then uses `../../build` as\n+build directory.\ndiff --git a/test/contrib/craigtracer.cpp b/test/contrib/craigtracer.cpp\nnew file mode 100644\nindex 000000000..200530370\n--- /dev/null\n+++ b/test/contrib/craigtracer.cpp\n@@ -0,0 +1,37 @@\n+#include \"../../contrib/craigtracer.hpp\"\n+#include \"../../src/cadical.hpp\"\n+\n+#ifdef NDEBUG\n+#undef NDEBUG\n+#endif\n+\n+#include <cassert>\n+#include <vector>\n+\n+int main () {\n+  CaDiCaL::Solver *solver = new CaDiCaL::Solver ();\n+  CaDiCraig::CraigTracer *tracer = new CaDiCraig::CraigTracer ();\n+  solver->connect_proof_tracer (tracer, true);\n+  tracer->set_craig_construction (CaDiCraig::CraigConstruction::ASYMMETRIC);\n+\n+  tracer->label_variable (1, CaDiCraig::CraigVarType::GLOBAL);\n+  tracer->label_clause (1, CaDiCraig::CraigClauseType::A_CLAUSE);\n+  tracer->label_clause (2, CaDiCraig::CraigClauseType::B_CLAUSE);\n+  solver->add (-1); solver->add (0);\n+  solver->add (1); solver->add (0);\n+  assert (solver->solve () == CaDiCaL::Status::UNSATISFIABLE);\n+\n+  int next_var = 2;\n+  std::vector<std::vector<int>> clauses;\n+  CaDiCraig::CraigCnfType result = tracer->create_craig_interpolant (\n+      CaDiCraig::CraigInterpolant::ASYMMETRIC, clauses, next_var);\n+  assert (result == CaDiCraig::CraigCnfType::NORMAL);\n+  assert (clauses == std::vector<std::vector<int>>{{-1}});\n+  assert (next_var == 2);\n+\n+  solver->disconnect_proof_tracer (tracer);\n+  delete tracer;\n+  delete solver;\n+\n+  return 0;\n+}\ndiff --git a/test/contrib/craigtracer_incremental.cpp b/test/contrib/craigtracer_incremental.cpp\nnew file mode 100644\nindex 000000000..42eedfbb4\n--- /dev/null\n+++ b/test/contrib/craigtracer_incremental.cpp\n@@ -0,0 +1,65 @@\n+#include \"../../contrib/craigtracer.hpp\"\n+#include \"../../src/cadical.hpp\"\n+\n+#ifdef NDEBUG\n+#undef NDEBUG\n+#endif\n+\n+#include <cassert>\n+#include <vector>\n+\n+int main () {\n+  CaDiCaL::Solver *solver = new CaDiCaL::Solver ();\n+  CaDiCraig::CraigTracer *tracer = new CaDiCraig::CraigTracer ();\n+  solver->connect_proof_tracer (tracer, true);\n+  tracer->set_craig_construction (CaDiCraig::CraigConstruction::ASYMMETRIC);\n+\n+  tracer->label_variable (1, CaDiCraig::CraigVarType::A_LOCAL);\n+  tracer->label_variable (2, CaDiCraig::CraigVarType::B_LOCAL);\n+  tracer->label_variable (3, CaDiCraig::CraigVarType::GLOBAL);\n+  tracer->label_clause (1, CaDiCraig::CraigClauseType::A_CLAUSE);\n+  tracer->label_clause (2, CaDiCraig::CraigClauseType::B_CLAUSE);\n+  solver->add (1); solver->add (0);\n+  solver->add (2); solver->add (0);\n+\n+  // ------------------------------------------------\n+  // A side is UNSATISFIABLE => Craig interpolant is CONSTANT0\n+  solver->assume (-1);\n+  assert (solver->solve () == CaDiCaL::Status::UNSATISFIABLE);\n+\n+  int next_var = 2;\n+  std::vector<std::vector<int>> clauses;\n+  CaDiCraig::CraigCnfType result = tracer->create_craig_interpolant (\n+      CaDiCraig::CraigInterpolant::ASYMMETRIC, clauses, next_var);\n+  assert (result == CaDiCraig::CraigCnfType::CONSTANT0);\n+  assert (clauses == std::vector<std::vector<int>>{{}});\n+  assert (next_var == 2);\n+\n+  // ------------------------------------------------\n+  // B side is UNSATISFIABLE\n+  solver->assume (-2);\n+  assert (solver->solve () == CaDiCaL::Status::UNSATISFIABLE);\n+\n+  result = tracer->create_craig_interpolant (\n+      CaDiCraig::CraigInterpolant::ASYMMETRIC, clauses, next_var);\n+  assert (result == CaDiCraig::CraigCnfType::CONSTANT1);\n+  assert (clauses == std::vector<std::vector<int>>{});\n+  assert (next_var == 2);\n+\n+  // ------------------------------------------------\n+  solver->add (-1); solver->add (3); solver->add (0);\n+  solver->constrain (-2); solver->constrain (-3); solver->constrain (0);\n+  assert (solver->solve () == CaDiCaL::Status::UNSATISFIABLE);\n+\n+  result = tracer->create_craig_interpolant (\n+      CaDiCraig::CraigInterpolant::ASYMMETRIC, clauses, next_var);\n+  assert (result == CaDiCraig::CraigCnfType::NORMAL);\n+  assert (clauses == std::vector<std::vector<int>>{{3}});\n+  assert (next_var == 2);\n+\n+  solver->disconnect_proof_tracer (tracer);\n+  delete tracer;\n+  delete solver;\n+\n+  return 0;\n+}\ndiff --git a/test/contrib/makefile b/test/contrib/makefile\nnew file mode 100644\nindex 000000000..89d026664\n--- /dev/null\n+++ b/test/contrib/makefile\n@@ -0,0 +1,3 @@\n+# compile and execute with a single 'make' the contrib tests in '../../build'\n+test:\n+\t$(MAKE) -C .. contrib\ndiff --git a/test/contrib/run.sh b/test/contrib/run.sh\nnew file mode 100755\nindex 000000000..386924e32\n--- /dev/null\n+++ b/test/contrib/run.sh\n@@ -0,0 +1,118 @@\n+#!/bin/sh\n+\n+#--------------------------------------------------------------------------#\n+\n+die () {\n+  cecho \"${HIDE}test/contrib/run.sh:${NORMAL} ${BAD}error:${NORMAL} $*\"\n+  exit 1\n+}\n+\n+msg () {\n+  cecho \"${HIDE}test/contrib/run.sh:${NORMAL} $*\"\n+}\n+\n+for dir in . .. ../..\n+do\n+  [ -f $dir/scripts/colors.sh ] || continue\n+  . $dir/scripts/colors.sh || exit 1\n+  break\n+done\n+\n+#--------------------------------------------------------------------------#\n+\n+[ -d ../test -a -d ../test/contrib ] || \\\n+die \"needs to be called from a top-level sub-directory of CaDiCaL\"\n+\n+[ x\"$CADICALBUILD\" = x ] && CADICALBUILD=\"../build\"\n+\n+[ -f \"$CADICALBUILD/makefile\" ] || \\\n+  die \"can not find '$CADICALBUILD/makefile' (run 'configure' first)\"\n+\n+[ -f \"$CADICALBUILD/libcadical.a\" ] || \\\n+  die \"can not find '$CADICALBUILD/libcadical.a' (run 'make' first)\"\n+\n+cecho -n \"$HILITE\"\n+cecho \"---------------------------------------------------------\"\n+cecho \"Contributions testing in '$CADICALBUILD'\"\n+cecho \"---------------------------------------------------------\"\n+cecho -n \"$NORMAL\"\n+\n+make -C $CADICALBUILD\n+res=$?\n+[ $res = 0 ] || exit $res\n+\n+#--------------------------------------------------------------------------#\n+\n+makefile=$CADICALBUILD/makefile\n+\n+CXX=`grep '^CXX=' \"$makefile\"|sed -e 's,CXX=,,'`\n+CXXFLAGS=`grep '^CXXFLAGS=' \"$makefile\"|sed -e 's,CXXFLAGS=,,'`\n+\n+msg \"using CXX=$CXX\"\n+msg \"using CXXFLAGS=$CXXFLAGS\"\n+\n+tests=../test/contrib\n+source=../src\n+contrib=../contrib\n+\n+export CADICALBUILD\n+\n+#--------------------------------------------------------------------------#\n+\n+ok=0\n+failed=0\n+\n+cmd () {\n+  test $status = 1 && return\n+  cecho $*\n+  $* >> $name.log\n+  status=$?\n+}\n+\n+run () {\n+  msg \"running contrib test ${HILITE}'$1'${NORMAL}\"\n+  if [ -f $tests/$1.c ]\n+  then\n+    src=$tests/$1.c\n+    language=\" -x c\"\n+    COMPILE=\"$CXX `echo $CXXFLAGS|sed -e 's,-std=c++11,-std=c11,'`\"\n+  elif [ -f $tests/$1.cpp ]\n+  then\n+    src=$tests/$1.cpp\n+    language=\"\"\n+    COMPILE=\"$CXX $CXXFLAGS\"\n+  else\n+    die \"can not find '$tests.c' nor '$tests.cpp'\"\n+  fi\n+  name=$CADICALBUILD/test-contrib-$1\n+  rm -f $name.log $name.o $name\n+  status=0\n+  cmd $COMPILE$language -I$source -I$contrib -o $name.o -c $src\n+  cmd $COMPILE -o $name $name.o -L$CADICALBUILD -lcadical\n+  cmd $name\n+  if test $status = 0\n+  then\n+    cecho \"# 0 ... ${GOOD}ok${NORMAL} (zero exit code)\"\n+    ok=`expr $ok + 1`\n+  else\n+    cecho \"# 0 ... ${BAD}failed${NORMAL} (non-zero exit code)\"\n+    failed=`expr $failed + 1`\n+  fi\n+}\n+\n+#--------------------------------------------------------------------------#\n+\n+if [ \"`grep DNCONTRIB $makefile`\" = \"\" ]\n+then\n+  run craigtracer\n+  run craigtracer_incremental\n+fi\n+\n+#--------------------------------------------------------------------------#\n+\n+[ $ok -gt 0 ] && OK=\"$GOOD\"\n+[ $failed -gt 0 ] && FAILED=\"$BAD\"\n+\n+msg \"${HILITE}contrib testing results:${NORMAL} ${OK}$ok ok${NORMAL}, ${FAILED}$failed failed${NORMAL}\"\n+\n+exit $failed\ndiff --git a/test/makefile b/test/makefile\nindex 1c46862bb..ae0a74902 100644\n--- a/test/makefile\n+++ b/test/makefile\n@@ -1,4 +1,4 @@\n-test: usage trace api cnf icnf mbt\n+test: usage trace api cnf icnf mbt contrib\n api:\n \t@api/run.sh\n cnf:\n@@ -11,4 +11,6 @@ trace:\n \t@trace/run.sh\n usage:\n \t@usage/run.sh\n-.PHONY: test api cnf icnf mbt trace usage\n+contrib:\n+\t@contrib/run.sh\n+.PHONY: test api cnf icnf mbt trace usage contrib\n\"\"\""
  },
  {
    "pr_number": 88,
    "title": "Add support for setting CPPFLAGS and LDFLAGS",
    "author": "swt2c",
    "head_sha": "77d46b51c762b4b2f5324ed88ea1a43ce6c6501d",
    "base_sha": "2df7b7fed0f9c522fd4cdf6e88cecad4cac8a2df",
    "head_ref": "ldflags",
    "base_ref": "master",
    "merge_commit_sha": null,
    "state": "open",
    "created_at": "2024-02-11T01:05:02Z",
    "updated_at": "2024-10-09T06:43:48Z",
    "merged_at": null,
    "pr_body": null,
    "diff": "\"\"\"diff --git a/configure b/configure\nindex 87ca8cd28..ce5d41e45 100755\n--- a/configure\n+++ b/configure\n@@ -263,6 +263,8 @@ fi\n \n [ x\"$CXX\" = x ] && CXX=g++\n [ x\"$CXXFLAGS\" = x ] || CXXFLAGS=\"$CXXFLAGS \"\n+[ x\"$CPPFLAGS\" = x ] || CPPFLAGS=\"$CPPFLAGS \"\n+[ x\"$LDFLAGS\" = x ] || LDFLAGS=\"$LDFLAGS \"\n \n case x\"$CXX\" in\n   x*g++*|x*clang++*) CXXFLAGS=\"${CXXFLAGS}-Wall -Wextra\";;\n@@ -497,6 +499,8 @@ sed \\\n # This 'makefile' is generated from '../makefile.in'.\" \\\n -e \"s,@CXX@,$CXX,\" \\\n -e \"s#@CXXFLAGS@#$CXXFLAGS#\" \\\n+-e \"s#@CPPFLAGS@#$CPPFLAGS#\" \\\n+-e \"s#@LDFLAGS@#$LDFLAGS#\" \\\n -e \"s#@LIBS@#$libs#\" \\\n -e \"s#@CONTRIB@#$contrib#\" \\\n -e \"s#@ROOT@#$root#\" \\\ndiff --git a/makefile.in b/makefile.in\nindex 291cb3e34..09db460ce 100644\n--- a/makefile.in\n+++ b/makefile.in\n@@ -9,6 +9,8 @@\n \n CXX=@CXX@\n CXXFLAGS=@CXXFLAGS@\n+CPPFLAGS=@CPPFLAGS@\n+LDFLAGS=@LDFLAGS@\n \n LIBS=@LIBS@\n ROOT=@ROOT@\n@@ -30,7 +32,7 @@ OBJ_CONTRIB=$(FILT_CONTRIB:.cpp=.o)\n # Include for current build directory is required for including the\n # generated build header build.hpp.\n DIR=../$(shell pwd|sed -e 's,.*/,,')\n-COMPILE=$(CXX) $(CXXFLAGS) -I$(DIR) -I$(ROOT)/src\n+COMPILE=$(CXX) $(CXXFLAGS) $(CPPFLAGS) -I$(DIR) -I$(ROOT)/src\n \n #--------------------------------------------------------------------------#\n \n@@ -54,10 +56,10 @@ contrib/%.o: $(ROOT)/contrib/%.cpp $(ROOT)/contrib/%.hpp $(ROOT)/src/*.hpp makef\n # tester 'mobical') and the library are the main build targets.\n \n cadical: src/cadical.o libcadical.a makefile\n-\t$(COMPILE) -o $@ $< -L. -lcadical $(LIBS)\n+\t$(COMPILE) -o $@ $< $(LDFLAGS) -L. -lcadical $(LIBS)\n \n mobical: src/mobical.o libcadical.a makefile $(LIBS)\n-\t$(COMPILE) -o $@ $< -L. -lcadical\n+\t$(COMPILE) -o $@ $< $(LDFLAGS) -L. -lcadical\n \n libcadical.a: $(OBJ_SOLVER) $(OBJ_CONTRIB) makefile\n \tar rc $@ $(OBJ_SOLVER) $(OBJ_CONTRIB)\ndiff --git a/test/api/run.sh b/test/api/run.sh\nindex 2f5df1da9..775edce3f 100755\n--- a/test/api/run.sh\n+++ b/test/api/run.sh\n@@ -47,9 +47,13 @@ makefile=$CADICALBUILD/makefile\n \n CXX=`grep '^CXX=' \"$makefile\"|sed -e 's,CXX=,,'`\n CXXFLAGS=`grep '^CXXFLAGS=' \"$makefile\"|sed -e 's,CXXFLAGS=,,'`\n+CPPFLAGS=`grep '^CPPFLAGS=' \"$makefile\"|sed -e 's,CPPFLAGS=,,'`\n+LDFLAGS=`grep '^LDFLAGS=' \"$makefile\"|sed -e 's,LDFLAGS=,,'`\n \n msg \"using CXX=$CXX\"\n msg \"using CXXFLAGS=$CXXFLAGS\"\n+msg \"using CPPFLAGS=$CPPFLAGS\"\n+msg \"using LDFLAGS=$LDFLAGS\"\n \n tests=../test/api\n \n@@ -73,12 +77,12 @@ run () {\n   then\n     src=$tests/$1.c\n     language=\" -x c\"\n-    COMPILE=\"$CXX `echo $CXXFLAGS|sed -e 's,-std=c++11,-std=c11,'`\"\n+    COMPILE=\"$CXX `echo $CXXFLAGS|sed -e 's,-std=c++11,-std=c11,'` $CPPFLAGS\"\n   elif [ -f $tests/$1.cpp ]\n   then\n     src=$tests/$1.cpp\n     language=\"\"\n-    COMPILE=\"$CXX $CXXFLAGS\"\n+    COMPILE=\"$CXX $CXXFLAGS $CPPFLAGS\"\n   else\n     die \"can not find '$tests.c' nor '$tests.cpp'\"\n   fi\n@@ -86,7 +90,7 @@ run () {\n   rm -f $name.log $name.o $name\n   status=0\n   cmd $COMPILE$language -o $name.o -c $src\n-  cmd $COMPILE -o $name $name.o -L$CADICALBUILD -lcadical\n+  cmd $COMPILE -o $name $name.o $LDFLAGS -L$CADICALBUILD -lcadical\n   cmd $name\n   if test $status = 0\n   then\ndiff --git a/test/cnf/run.sh b/test/cnf/run.sh\nindex 8326f0a63..b16229090 100755\n--- a/test/cnf/run.sh\n+++ b/test/cnf/run.sh\n@@ -25,6 +25,9 @@ die \"needs to be called from a top-level sub-directory of CaDiCaL\"\n \n [ x\"$CADICALBUILD\" = x ] && CADICALBUILD=\"../build\"\n \n+[ -f \"$CADICALBUILD/makefile\" ] || \\\n+  die \"can not find '$CADICALBUILD/makefile' (run 'configure' first)\"\n+\n [ -x \"$CADICALBUILD/cadical\" ] || \\\n   die \"can not find '$CADICALBUILD/cadical' (run 'make' first)\"\n \n@@ -47,12 +50,22 @@ lratchecker=$CADICALBUILD/lrat-trim\n solutionchecker=$CADICALBUILD/precochk\n makefile=$CADICALBUILD/makefile\n \n+CXX=`grep '^CXX=' \"$makefile\"|sed -e 's,CXX=,,'`\n+CXXFLAGS=`grep '^CXXFLAGS=' \"$makefile\"|sed -e 's,CXXFLAGS=,,'`\n+CPPFLAGS=`grep '^CPPFLAGS=' \"$makefile\"|sed -e 's,CPPFLAGS=,,'`\n+LDFLAGS=`grep '^LDFLAGS=' \"$makefile\"|sed -e 's,LDFLAGS=,,'`\n+\n+msg \"using CXX=$CXX\"\n+msg \"using CXXFLAGS=$CXXFLAGS\"\n+msg \"using CPPFLAGS=$CPPFLAGS\"\n+msg \"using LDFLAGS=$LDFLAGS\"\n+\n if [ ! -f $solutionchecker -o ! -f $dratchecker -o ! -f $lratchecker ]\n then\n \n   if [ ! -f $solutionchecker -o ../test/cnf/precochk.c -nt $solutionchecker ]\n   then\n-    cmd=\"cc -O -o $solutionchecker ../test/cnf/precochk.c -lz\"\n+    cmd=\"cc -O `echo $CXXFLAGS|sed -e 's,-std=c++11,-std=c11,'` $CPPFLAGS -o $solutionchecker ../test/cnf/precochk.c -lz $LDFLAGS\"\n     cecho \"$cmd\"\n     if $cmd 2>/dev/null\n     then\n@@ -66,7 +79,7 @@ then\n \n   if [ ! -f $dratchecker -o ../test/cnf/drat-trim.c -nt $dratchecker ]\n   then\n-    cmd=\"cc -O -o $dratchecker ../test/cnf/drat-trim.c\"\n+    cmd=\"cc -O `echo $CXXFLAGS|sed -e 's,-std=c++11,-std=c11,'` $CPPFLAGS -o $dratchecker ../test/cnf/drat-trim.c $LDFLAGS\"\n     if $cmd 2>/dev/null\n     then\n       msg \"external proof checking with '$dratchecker'\"\n@@ -79,7 +92,7 @@ then\n \n   if [ ! -f $lratchecker -o ../test/cnf/lrat-trim.c -nt $lratchecker ]\n   then\n-    cmd=\"cc -O -o $lratchecker ../test/cnf/lrat-trim.c\"\n+    cmd=\"cc -O `echo $CXXFLAGS|sed -e 's,-std=c++11,-std=c11,'` $CPPFLAGS -o $lratchecker ../test/cnf/lrat-trim.c $LDFLAGS\"\n     if $cmd 2>/dev/null\n     then\n       msg \"external proof checking with '$lratchecker'\"\n\"\"\""
  },
  {
    "pr_number": 85,
    "title": "Fixed copy & paste error in test/icnf/makefile",
    "author": "TobiasFaller",
    "head_sha": "94be394f445ccefc656da1860a880314d2a0127f",
    "base_sha": "a3ebcea9903f7b71d28fb5133d81d5592b05089a",
    "head_ref": "fix-makefile-copy-paste",
    "base_ref": "development",
    "merge_commit_sha": "b8434e3951ae020a455dfabf60b24ce0b9febef9",
    "state": "closed",
    "created_at": "2024-01-14T13:41:55Z",
    "updated_at": "2024-01-27T16:50:27Z",
    "merged_at": "2024-01-27T16:50:27Z",
    "pr_body": null,
    "diff": "\"\"\"diff --git a/test/icnf/makefile b/test/icnf/makefile\nindex 683eaf157..5fc6b0620 100644\n--- a/test/icnf/makefile\n+++ b/test/icnf/makefile\n@@ -1,3 +1,3 @@\n # execute ICNF tests with a single 'make' command in '../../build'\n test:\n-\t$(MAKE) -C .. cnf\n+\t$(MAKE) -C .. icnf\n\"\"\""
  },
  {
    "pr_number": 84,
    "title": "Added Dockerfile to build and run CaDiCaL",
    "author": "TobiasFaller",
    "head_sha": "4fb874b4c1b766f1b83255b5f002e0ae8e4b0a30",
    "base_sha": "e71bd58937e6513f71bd8c93d91578785c592721",
    "head_ref": "master",
    "base_ref": "master",
    "merge_commit_sha": "1dd9a346bce1d0477840ced1c4b9732c59cab47a",
    "state": "closed",
    "created_at": "2024-01-08T09:22:46Z",
    "updated_at": "2024-01-08T13:21:49Z",
    "merged_at": null,
    "pr_body": "Minimalistic Dockerfile to build and run CaDiCaL",
    "diff": "\"\"\"diff --git a/.dockerignore b/.dockerignore\nnew file mode 100644\nindex 000000000..94143827e\n--- /dev/null\n+++ b/.dockerignore\n@@ -0,0 +1 @@\n+Dockerfile\ndiff --git a/Dockerfile b/Dockerfile\nnew file mode 100644\nindex 000000000..2d270e3fb\n--- /dev/null\n+++ b/Dockerfile\n@@ -0,0 +1,34 @@\n+# -----------------------------------------------------------------------------\n+# Builder container\n+# -----------------------------------------------------------------------------\n+FROM ubuntu:22.04 as builder\n+\n+ENV DEBIAN_FRONTEND \"noninteractive\"\n+ENV TZ \"Europe/Berlin\"\n+\n+# Install compiler, build tools and required libraries\n+RUN apt-get update \\\n+  && apt-get install -y --no-install-recommends build-essential g++ \\\n+  && apt-get clean\n+\n+COPY . /work\n+\n+WORKDIR /work\n+RUN ./configure \\\n+  && make\n+\n+# -----------------------------------------------------------------------------\n+# Runtime container\n+# -----------------------------------------------------------------------------\n+\n+FROM ubuntu:22.04 as runner\n+\n+ENV DEBIAN_FRONTEND \"noninteractive\"\n+ENV TZ \"Europe/Berlin\"\n+\n+COPY --from=builder /work/build/cadical /cadical/cadical\n+COPY --from=builder /work/build/mobical /cadical/mobical\n+\n+WORKDIR /cadical\n+ENTRYPOINT [\"/cadical/cadical\"]\n+CMD [\"--help\"]\n\"\"\""
  },
  {
    "pr_number": 78,
    "title": "Add cmake FetchContent support",
    "author": "madmaxieee",
    "head_sha": "36495b277dae3fb782113a54065d2b937c31dee4",
    "base_sha": "a282a68d8a4cf7763c2f36d3247b389ea6366463",
    "head_ref": "add-cmake-fetchcontent-support-development",
    "base_ref": "development",
    "merge_commit_sha": "ef04fd605889d68542d0f02a2a21615c554cf37f",
    "state": "closed",
    "created_at": "2023-12-09T19:20:50Z",
    "updated_at": "2024-10-09T06:44:52Z",
    "merged_at": null,
    "pr_body": "Adds cmake FetchContent support so other cmake users can easily add this project as a dependency. We plan to use this for our open-source quantum circuit synthesis tool [qysn](https://github.com/DVLab-NTU/qsyn). It would be nice if you could accept this PR. This CMakeLists.txt only has the library build, I can help you add a binary build option if you're interested.",
    "diff": "\"\"\"diff --git a/CMakeLists.txt b/CMakeLists.txt\nnew file mode 100644\nindex 000000000..519ab33fb\n--- /dev/null\n+++ b/CMakeLists.txt\n@@ -0,0 +1,34 @@\n+cmake_minimum_required(VERSION 3.19)\n+\n+set(CMAKE_CXX_STANDARD 11)\n+\n+if(NOT CMAKE_BUILD_TYPE)\n+  set(CMAKE_BUILD_TYPE Release)\n+endif()\n+\n+file(READ \"${CMAKE_CURRENT_SOURCE_DIR}/VERSION\" CADICAL_VERSION)\n+# remove version suffix to make make it valid for cmake\n+string(REGEX REPLACE \"([0-9]+\\.[0-9]+\\.[0-9]+).*$\" \"\\\\1\" CADICAL_VERSION\n+                     \"${CADICAL_VERSION}\")\n+\n+project(\n+  cadical\n+  LANGUAGES CXX\n+  VERSION ${CADICAL_VERSION})\n+\n+file(\n+  GLOB_RECURSE SOURCES\n+  RELATIVE ${CMAKE_CURRENT_SOURCE_DIR}\n+  \"src/*.cpp\" \"src/*.hpp\")\n+\n+list(REMOVE_ITEM SOURCES \"src/mobical.cpp\")\n+list(REMOVE_ITEM SOURCES \"src/cadical.cpp\")\n+\n+add_library(cadical STATIC ${SOURCES})\n+add_library(cadical::cadical ALIAS cadical)\n+# don't generate the build header file when building the library\n+target_compile_definitions(cadical PRIVATE NBUILD=1)\n+\n+target_include_directories(\n+  cadical INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\n+                    $<INSTALL_INTERFACE:include>)\ndiff --git a/include/cadical/arena.hpp b/include/cadical/arena.hpp\nnew file mode 120000\nindex 000000000..2f71c353e\n--- /dev/null\n+++ b/include/cadical/arena.hpp\n@@ -0,0 +1 @@\n+../../src/arena.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/averages.hpp b/include/cadical/averages.hpp\nnew file mode 120000\nindex 000000000..33fc32e2c\n--- /dev/null\n+++ b/include/cadical/averages.hpp\n@@ -0,0 +1 @@\n+../../src/averages.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/bins.hpp b/include/cadical/bins.hpp\nnew file mode 120000\nindex 000000000..3a560c411\n--- /dev/null\n+++ b/include/cadical/bins.hpp\n@@ -0,0 +1 @@\n+../../src/bins.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/block.hpp b/include/cadical/block.hpp\nnew file mode 120000\nindex 000000000..f99e45672\n--- /dev/null\n+++ b/include/cadical/block.hpp\n@@ -0,0 +1 @@\n+../../src/block.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/build.hpp b/include/cadical/build.hpp\nnew file mode 120000\nindex 000000000..2108c9bf3\n--- /dev/null\n+++ b/include/cadical/build.hpp\n@@ -0,0 +1 @@\n+../../src/build.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/cadical.hpp b/include/cadical/cadical.hpp\nnew file mode 120000\nindex 000000000..04ddb398f\n--- /dev/null\n+++ b/include/cadical/cadical.hpp\n@@ -0,0 +1 @@\n+../../src/cadical.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/checker.hpp b/include/cadical/checker.hpp\nnew file mode 120000\nindex 000000000..1596907a5\n--- /dev/null\n+++ b/include/cadical/checker.hpp\n@@ -0,0 +1 @@\n+../../src/checker.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/clause.hpp b/include/cadical/clause.hpp\nnew file mode 120000\nindex 000000000..1752a031d\n--- /dev/null\n+++ b/include/cadical/clause.hpp\n@@ -0,0 +1 @@\n+../../src/clause.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/config.hpp b/include/cadical/config.hpp\nnew file mode 120000\nindex 000000000..4e667e68e\n--- /dev/null\n+++ b/include/cadical/config.hpp\n@@ -0,0 +1 @@\n+../../src/config.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/contract.hpp b/include/cadical/contract.hpp\nnew file mode 120000\nindex 000000000..ab5224464\n--- /dev/null\n+++ b/include/cadical/contract.hpp\n@@ -0,0 +1 @@\n+../../src/contract.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/cover.hpp b/include/cadical/cover.hpp\nnew file mode 120000\nindex 000000000..20ecfda8d\n--- /dev/null\n+++ b/include/cadical/cover.hpp\n@@ -0,0 +1 @@\n+../../src/cover.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/decompose.hpp b/include/cadical/decompose.hpp\nnew file mode 120000\nindex 000000000..3864e242f\n--- /dev/null\n+++ b/include/cadical/decompose.hpp\n@@ -0,0 +1 @@\n+../../src/decompose.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/drattracer.hpp b/include/cadical/drattracer.hpp\nnew file mode 120000\nindex 000000000..97929efb5\n--- /dev/null\n+++ b/include/cadical/drattracer.hpp\n@@ -0,0 +1 @@\n+../../src/drattracer.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/elim.hpp b/include/cadical/elim.hpp\nnew file mode 120000\nindex 000000000..499502aba\n--- /dev/null\n+++ b/include/cadical/elim.hpp\n@@ -0,0 +1 @@\n+../../src/elim.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/ema.hpp b/include/cadical/ema.hpp\nnew file mode 120000\nindex 000000000..80077802f\n--- /dev/null\n+++ b/include/cadical/ema.hpp\n@@ -0,0 +1 @@\n+../../src/ema.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/external.hpp b/include/cadical/external.hpp\nnew file mode 120000\nindex 000000000..1db137945\n--- /dev/null\n+++ b/include/cadical/external.hpp\n@@ -0,0 +1 @@\n+../../src/external.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/file.hpp b/include/cadical/file.hpp\nnew file mode 120000\nindex 000000000..5e851ecd4\n--- /dev/null\n+++ b/include/cadical/file.hpp\n@@ -0,0 +1 @@\n+../../src/file.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/flags.hpp b/include/cadical/flags.hpp\nnew file mode 120000\nindex 000000000..1360df716\n--- /dev/null\n+++ b/include/cadical/flags.hpp\n@@ -0,0 +1 @@\n+../../src/flags.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/format.hpp b/include/cadical/format.hpp\nnew file mode 120000\nindex 000000000..1ebdb82ca\n--- /dev/null\n+++ b/include/cadical/format.hpp\n@@ -0,0 +1 @@\n+../../src/format.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/frattracer.hpp b/include/cadical/frattracer.hpp\nnew file mode 120000\nindex 000000000..adac3d1e6\n--- /dev/null\n+++ b/include/cadical/frattracer.hpp\n@@ -0,0 +1 @@\n+../../src/frattracer.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/heap.hpp b/include/cadical/heap.hpp\nnew file mode 120000\nindex 000000000..8415cbeca\n--- /dev/null\n+++ b/include/cadical/heap.hpp\n@@ -0,0 +1 @@\n+../../src/heap.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/idruptracer.hpp b/include/cadical/idruptracer.hpp\nnew file mode 120000\nindex 000000000..98d93a790\n--- /dev/null\n+++ b/include/cadical/idruptracer.hpp\n@@ -0,0 +1 @@\n+../../src/idruptracer.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/instantiate.hpp b/include/cadical/instantiate.hpp\nnew file mode 120000\nindex 000000000..17f1c1df8\n--- /dev/null\n+++ b/include/cadical/instantiate.hpp\n@@ -0,0 +1 @@\n+../../src/instantiate.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/internal.hpp b/include/cadical/internal.hpp\nnew file mode 120000\nindex 000000000..9f3bc88ce\n--- /dev/null\n+++ b/include/cadical/internal.hpp\n@@ -0,0 +1 @@\n+../../src/internal.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/inttypes.hpp b/include/cadical/inttypes.hpp\nnew file mode 120000\nindex 000000000..68c6ca015\n--- /dev/null\n+++ b/include/cadical/inttypes.hpp\n@@ -0,0 +1 @@\n+../../src/inttypes.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/level.hpp b/include/cadical/level.hpp\nnew file mode 120000\nindex 000000000..cab9b0afd\n--- /dev/null\n+++ b/include/cadical/level.hpp\n@@ -0,0 +1 @@\n+../../src/level.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/limit.hpp b/include/cadical/limit.hpp\nnew file mode 120000\nindex 000000000..2843fe30b\n--- /dev/null\n+++ b/include/cadical/limit.hpp\n@@ -0,0 +1 @@\n+../../src/limit.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/logging.hpp b/include/cadical/logging.hpp\nnew file mode 120000\nindex 000000000..0ee698461\n--- /dev/null\n+++ b/include/cadical/logging.hpp\n@@ -0,0 +1 @@\n+../../src/logging.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/lratbuilder.hpp b/include/cadical/lratbuilder.hpp\nnew file mode 120000\nindex 000000000..1f5b6cdc0\n--- /dev/null\n+++ b/include/cadical/lratbuilder.hpp\n@@ -0,0 +1 @@\n+../../src/lratbuilder.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/lratchecker.hpp b/include/cadical/lratchecker.hpp\nnew file mode 120000\nindex 000000000..f82199911\n--- /dev/null\n+++ b/include/cadical/lratchecker.hpp\n@@ -0,0 +1 @@\n+../../src/lratchecker.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/lrattracer.hpp b/include/cadical/lrattracer.hpp\nnew file mode 120000\nindex 000000000..c22dba2c8\n--- /dev/null\n+++ b/include/cadical/lrattracer.hpp\n@@ -0,0 +1 @@\n+../../src/lrattracer.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/message.hpp b/include/cadical/message.hpp\nnew file mode 120000\nindex 000000000..dc8cb4b7a\n--- /dev/null\n+++ b/include/cadical/message.hpp\n@@ -0,0 +1 @@\n+../../src/message.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/occs.hpp b/include/cadical/occs.hpp\nnew file mode 120000\nindex 000000000..297fbd0b5\n--- /dev/null\n+++ b/include/cadical/occs.hpp\n@@ -0,0 +1 @@\n+../../src/occs.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/options.hpp b/include/cadical/options.hpp\nnew file mode 120000\nindex 000000000..88a16ebae\n--- /dev/null\n+++ b/include/cadical/options.hpp\n@@ -0,0 +1 @@\n+../../src/options.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/parse.hpp b/include/cadical/parse.hpp\nnew file mode 120000\nindex 000000000..db538d75c\n--- /dev/null\n+++ b/include/cadical/parse.hpp\n@@ -0,0 +1 @@\n+../../src/parse.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/phases.hpp b/include/cadical/phases.hpp\nnew file mode 120000\nindex 000000000..1be2e9576\n--- /dev/null\n+++ b/include/cadical/phases.hpp\n@@ -0,0 +1 @@\n+../../src/phases.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/profile.hpp b/include/cadical/profile.hpp\nnew file mode 120000\nindex 000000000..3156e9b01\n--- /dev/null\n+++ b/include/cadical/profile.hpp\n@@ -0,0 +1 @@\n+../../src/profile.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/proof.hpp b/include/cadical/proof.hpp\nnew file mode 120000\nindex 000000000..b54ec77b8\n--- /dev/null\n+++ b/include/cadical/proof.hpp\n@@ -0,0 +1 @@\n+../../src/proof.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/queue.hpp b/include/cadical/queue.hpp\nnew file mode 120000\nindex 000000000..7134182ac\n--- /dev/null\n+++ b/include/cadical/queue.hpp\n@@ -0,0 +1 @@\n+../../src/queue.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/radix.hpp b/include/cadical/radix.hpp\nnew file mode 120000\nindex 000000000..4c62dc3f7\n--- /dev/null\n+++ b/include/cadical/radix.hpp\n@@ -0,0 +1 @@\n+../../src/radix.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/random.hpp b/include/cadical/random.hpp\nnew file mode 120000\nindex 000000000..709253fbb\n--- /dev/null\n+++ b/include/cadical/random.hpp\n@@ -0,0 +1 @@\n+../../src/random.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/range.hpp b/include/cadical/range.hpp\nnew file mode 120000\nindex 000000000..b48ac58c2\n--- /dev/null\n+++ b/include/cadical/range.hpp\n@@ -0,0 +1 @@\n+../../src/range.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/reap.hpp b/include/cadical/reap.hpp\nnew file mode 120000\nindex 000000000..45ded52a0\n--- /dev/null\n+++ b/include/cadical/reap.hpp\n@@ -0,0 +1 @@\n+../../src/reap.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/reluctant.hpp b/include/cadical/reluctant.hpp\nnew file mode 120000\nindex 000000000..8f76390a6\n--- /dev/null\n+++ b/include/cadical/reluctant.hpp\n@@ -0,0 +1 @@\n+../../src/reluctant.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/resources.hpp b/include/cadical/resources.hpp\nnew file mode 120000\nindex 000000000..6877c6109\n--- /dev/null\n+++ b/include/cadical/resources.hpp\n@@ -0,0 +1 @@\n+../../src/resources.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/score.hpp b/include/cadical/score.hpp\nnew file mode 120000\nindex 000000000..1217eefee\n--- /dev/null\n+++ b/include/cadical/score.hpp\n@@ -0,0 +1 @@\n+../../src/score.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/signal.hpp b/include/cadical/signal.hpp\nnew file mode 120000\nindex 000000000..3565ba321\n--- /dev/null\n+++ b/include/cadical/signal.hpp\n@@ -0,0 +1 @@\n+../../src/signal.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/stats.hpp b/include/cadical/stats.hpp\nnew file mode 120000\nindex 000000000..38bfd4952\n--- /dev/null\n+++ b/include/cadical/stats.hpp\n@@ -0,0 +1 @@\n+../../src/stats.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/terminal.hpp b/include/cadical/terminal.hpp\nnew file mode 120000\nindex 000000000..18a443911\n--- /dev/null\n+++ b/include/cadical/terminal.hpp\n@@ -0,0 +1 @@\n+../../src/terminal.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/tracer.hpp b/include/cadical/tracer.hpp\nnew file mode 120000\nindex 000000000..70fc42f43\n--- /dev/null\n+++ b/include/cadical/tracer.hpp\n@@ -0,0 +1 @@\n+../../src/tracer.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/util.hpp b/include/cadical/util.hpp\nnew file mode 120000\nindex 000000000..339edabc2\n--- /dev/null\n+++ b/include/cadical/util.hpp\n@@ -0,0 +1 @@\n+../../src/util.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/var.hpp b/include/cadical/var.hpp\nnew file mode 120000\nindex 000000000..686673aae\n--- /dev/null\n+++ b/include/cadical/var.hpp\n@@ -0,0 +1 @@\n+../../src/var.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/veripbtracer.hpp b/include/cadical/veripbtracer.hpp\nnew file mode 120000\nindex 000000000..7d4005e48\n--- /dev/null\n+++ b/include/cadical/veripbtracer.hpp\n@@ -0,0 +1 @@\n+../../src/veripbtracer.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/version.hpp b/include/cadical/version.hpp\nnew file mode 120000\nindex 000000000..08dc92e41\n--- /dev/null\n+++ b/include/cadical/version.hpp\n@@ -0,0 +1 @@\n+../../src/version.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/vivify.hpp b/include/cadical/vivify.hpp\nnew file mode 120000\nindex 000000000..d88ea7be3\n--- /dev/null\n+++ b/include/cadical/vivify.hpp\n@@ -0,0 +1 @@\n+../../src/vivify.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/watch.hpp b/include/cadical/watch.hpp\nnew file mode 120000\nindex 000000000..a1d6251da\n--- /dev/null\n+++ b/include/cadical/watch.hpp\n@@ -0,0 +1 @@\n+../../src/watch.hpp\n\\ No newline at end of file\n\"\"\""
  },
  {
    "pr_number": 77,
    "title": "chore: add cmake build system",
    "author": "madmaxieee",
    "head_sha": "3454787960ba88d31013424058595ed73749b0a8",
    "base_sha": "56f667c858dd7d9da1cc98ce0fb4030713881914",
    "head_ref": "add-cmake-fetchcontent-support",
    "base_ref": "master",
    "merge_commit_sha": "8f97cf93d20a88ec4d7248b560fbc1a469051308",
    "state": "closed",
    "created_at": "2023-12-09T18:54:56Z",
    "updated_at": "2023-12-09T18:57:16Z",
    "merged_at": null,
    "pr_body": "add a cmake configuration to support cmake FetchContent",
    "diff": "\"\"\"diff --git a/CMakeLists.txt b/CMakeLists.txt\nnew file mode 100644\nindex 000000000..5d229f7a4\n--- /dev/null\n+++ b/CMakeLists.txt\n@@ -0,0 +1,33 @@\n+cmake_minimum_required(VERSION 3.19)\n+\n+set(CMAKE_CXX_STANDARD 11)\n+\n+if(NOT CMAKE_BUILD_TYPE)\n+  set(CMAKE_BUILD_TYPE Release)\n+endif()\n+\n+file(READ \"${CMAKE_CURRENT_SOURCE_DIR}/VERSION\" CADICAL_VERSION)\n+# remove trailing newline\n+string(REGEX REPLACE \"\\n$\" \"\" CADICAL_VERSION \"${CADICAL_VERSION}\")\n+\n+project(\n+  cadical\n+  LANGUAGES CXX\n+  VERSION ${CADICAL_VERSION})\n+\n+file(\n+  GLOB_RECURSE SOURCES\n+  RELATIVE ${CMAKE_CURRENT_SOURCE_DIR}\n+  \"src/*.cpp\" \"src/*.hpp\")\n+\n+list(REMOVE_ITEM SOURCES \"src/mobical.cpp\")\n+list(REMOVE_ITEM SOURCES \"src/cadical.cpp\")\n+\n+add_library(cadical STATIC ${SOURCES})\n+add_library(cadical::cadical ALIAS cadical)\n+# don't generate the build header file when building the library\n+target_compile_definitions(cadical PRIVATE NBUILD=1)\n+\n+target_include_directories(\n+  cadical INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\n+                    $<INSTALL_INTERFACE:include>)\ndiff --git a/include/cadical/arena.hpp b/include/cadical/arena.hpp\nnew file mode 120000\nindex 000000000..2f71c353e\n--- /dev/null\n+++ b/include/cadical/arena.hpp\n@@ -0,0 +1 @@\n+../../src/arena.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/averages.hpp b/include/cadical/averages.hpp\nnew file mode 120000\nindex 000000000..33fc32e2c\n--- /dev/null\n+++ b/include/cadical/averages.hpp\n@@ -0,0 +1 @@\n+../../src/averages.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/bins.hpp b/include/cadical/bins.hpp\nnew file mode 120000\nindex 000000000..3a560c411\n--- /dev/null\n+++ b/include/cadical/bins.hpp\n@@ -0,0 +1 @@\n+../../src/bins.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/block.hpp b/include/cadical/block.hpp\nnew file mode 120000\nindex 000000000..f99e45672\n--- /dev/null\n+++ b/include/cadical/block.hpp\n@@ -0,0 +1 @@\n+../../src/block.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/build.hpp b/include/cadical/build.hpp\nnew file mode 120000\nindex 000000000..2108c9bf3\n--- /dev/null\n+++ b/include/cadical/build.hpp\n@@ -0,0 +1 @@\n+../../src/build.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/cadical.hpp b/include/cadical/cadical.hpp\nnew file mode 120000\nindex 000000000..04ddb398f\n--- /dev/null\n+++ b/include/cadical/cadical.hpp\n@@ -0,0 +1 @@\n+../../src/cadical.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/checker.hpp b/include/cadical/checker.hpp\nnew file mode 120000\nindex 000000000..1596907a5\n--- /dev/null\n+++ b/include/cadical/checker.hpp\n@@ -0,0 +1 @@\n+../../src/checker.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/clause.hpp b/include/cadical/clause.hpp\nnew file mode 120000\nindex 000000000..1752a031d\n--- /dev/null\n+++ b/include/cadical/clause.hpp\n@@ -0,0 +1 @@\n+../../src/clause.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/config.hpp b/include/cadical/config.hpp\nnew file mode 120000\nindex 000000000..4e667e68e\n--- /dev/null\n+++ b/include/cadical/config.hpp\n@@ -0,0 +1 @@\n+../../src/config.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/contract.hpp b/include/cadical/contract.hpp\nnew file mode 120000\nindex 000000000..ab5224464\n--- /dev/null\n+++ b/include/cadical/contract.hpp\n@@ -0,0 +1 @@\n+../../src/contract.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/cover.hpp b/include/cadical/cover.hpp\nnew file mode 120000\nindex 000000000..20ecfda8d\n--- /dev/null\n+++ b/include/cadical/cover.hpp\n@@ -0,0 +1 @@\n+../../src/cover.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/decompose.hpp b/include/cadical/decompose.hpp\nnew file mode 120000\nindex 000000000..3864e242f\n--- /dev/null\n+++ b/include/cadical/decompose.hpp\n@@ -0,0 +1 @@\n+../../src/decompose.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/drattracer.hpp b/include/cadical/drattracer.hpp\nnew file mode 120000\nindex 000000000..97929efb5\n--- /dev/null\n+++ b/include/cadical/drattracer.hpp\n@@ -0,0 +1 @@\n+../../src/drattracer.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/elim.hpp b/include/cadical/elim.hpp\nnew file mode 120000\nindex 000000000..499502aba\n--- /dev/null\n+++ b/include/cadical/elim.hpp\n@@ -0,0 +1 @@\n+../../src/elim.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/ema.hpp b/include/cadical/ema.hpp\nnew file mode 120000\nindex 000000000..80077802f\n--- /dev/null\n+++ b/include/cadical/ema.hpp\n@@ -0,0 +1 @@\n+../../src/ema.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/external.hpp b/include/cadical/external.hpp\nnew file mode 120000\nindex 000000000..1db137945\n--- /dev/null\n+++ b/include/cadical/external.hpp\n@@ -0,0 +1 @@\n+../../src/external.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/file.hpp b/include/cadical/file.hpp\nnew file mode 120000\nindex 000000000..5e851ecd4\n--- /dev/null\n+++ b/include/cadical/file.hpp\n@@ -0,0 +1 @@\n+../../src/file.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/flags.hpp b/include/cadical/flags.hpp\nnew file mode 120000\nindex 000000000..1360df716\n--- /dev/null\n+++ b/include/cadical/flags.hpp\n@@ -0,0 +1 @@\n+../../src/flags.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/format.hpp b/include/cadical/format.hpp\nnew file mode 120000\nindex 000000000..1ebdb82ca\n--- /dev/null\n+++ b/include/cadical/format.hpp\n@@ -0,0 +1 @@\n+../../src/format.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/frattracer.hpp b/include/cadical/frattracer.hpp\nnew file mode 120000\nindex 000000000..adac3d1e6\n--- /dev/null\n+++ b/include/cadical/frattracer.hpp\n@@ -0,0 +1 @@\n+../../src/frattracer.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/heap.hpp b/include/cadical/heap.hpp\nnew file mode 120000\nindex 000000000..8415cbeca\n--- /dev/null\n+++ b/include/cadical/heap.hpp\n@@ -0,0 +1 @@\n+../../src/heap.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/idruptracer.hpp b/include/cadical/idruptracer.hpp\nnew file mode 120000\nindex 000000000..98d93a790\n--- /dev/null\n+++ b/include/cadical/idruptracer.hpp\n@@ -0,0 +1 @@\n+../../src/idruptracer.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/instantiate.hpp b/include/cadical/instantiate.hpp\nnew file mode 120000\nindex 000000000..17f1c1df8\n--- /dev/null\n+++ b/include/cadical/instantiate.hpp\n@@ -0,0 +1 @@\n+../../src/instantiate.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/internal.hpp b/include/cadical/internal.hpp\nnew file mode 120000\nindex 000000000..9f3bc88ce\n--- /dev/null\n+++ b/include/cadical/internal.hpp\n@@ -0,0 +1 @@\n+../../src/internal.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/inttypes.hpp b/include/cadical/inttypes.hpp\nnew file mode 120000\nindex 000000000..68c6ca015\n--- /dev/null\n+++ b/include/cadical/inttypes.hpp\n@@ -0,0 +1 @@\n+../../src/inttypes.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/level.hpp b/include/cadical/level.hpp\nnew file mode 120000\nindex 000000000..cab9b0afd\n--- /dev/null\n+++ b/include/cadical/level.hpp\n@@ -0,0 +1 @@\n+../../src/level.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/limit.hpp b/include/cadical/limit.hpp\nnew file mode 120000\nindex 000000000..2843fe30b\n--- /dev/null\n+++ b/include/cadical/limit.hpp\n@@ -0,0 +1 @@\n+../../src/limit.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/logging.hpp b/include/cadical/logging.hpp\nnew file mode 120000\nindex 000000000..0ee698461\n--- /dev/null\n+++ b/include/cadical/logging.hpp\n@@ -0,0 +1 @@\n+../../src/logging.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/lratbuilder.hpp b/include/cadical/lratbuilder.hpp\nnew file mode 120000\nindex 000000000..1f5b6cdc0\n--- /dev/null\n+++ b/include/cadical/lratbuilder.hpp\n@@ -0,0 +1 @@\n+../../src/lratbuilder.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/lratchecker.hpp b/include/cadical/lratchecker.hpp\nnew file mode 120000\nindex 000000000..f82199911\n--- /dev/null\n+++ b/include/cadical/lratchecker.hpp\n@@ -0,0 +1 @@\n+../../src/lratchecker.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/lrattracer.hpp b/include/cadical/lrattracer.hpp\nnew file mode 120000\nindex 000000000..c22dba2c8\n--- /dev/null\n+++ b/include/cadical/lrattracer.hpp\n@@ -0,0 +1 @@\n+../../src/lrattracer.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/message.hpp b/include/cadical/message.hpp\nnew file mode 120000\nindex 000000000..dc8cb4b7a\n--- /dev/null\n+++ b/include/cadical/message.hpp\n@@ -0,0 +1 @@\n+../../src/message.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/occs.hpp b/include/cadical/occs.hpp\nnew file mode 120000\nindex 000000000..297fbd0b5\n--- /dev/null\n+++ b/include/cadical/occs.hpp\n@@ -0,0 +1 @@\n+../../src/occs.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/options.hpp b/include/cadical/options.hpp\nnew file mode 120000\nindex 000000000..88a16ebae\n--- /dev/null\n+++ b/include/cadical/options.hpp\n@@ -0,0 +1 @@\n+../../src/options.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/parse.hpp b/include/cadical/parse.hpp\nnew file mode 120000\nindex 000000000..db538d75c\n--- /dev/null\n+++ b/include/cadical/parse.hpp\n@@ -0,0 +1 @@\n+../../src/parse.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/phases.hpp b/include/cadical/phases.hpp\nnew file mode 120000\nindex 000000000..1be2e9576\n--- /dev/null\n+++ b/include/cadical/phases.hpp\n@@ -0,0 +1 @@\n+../../src/phases.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/profile.hpp b/include/cadical/profile.hpp\nnew file mode 120000\nindex 000000000..3156e9b01\n--- /dev/null\n+++ b/include/cadical/profile.hpp\n@@ -0,0 +1 @@\n+../../src/profile.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/proof.hpp b/include/cadical/proof.hpp\nnew file mode 120000\nindex 000000000..b54ec77b8\n--- /dev/null\n+++ b/include/cadical/proof.hpp\n@@ -0,0 +1 @@\n+../../src/proof.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/queue.hpp b/include/cadical/queue.hpp\nnew file mode 120000\nindex 000000000..7134182ac\n--- /dev/null\n+++ b/include/cadical/queue.hpp\n@@ -0,0 +1 @@\n+../../src/queue.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/radix.hpp b/include/cadical/radix.hpp\nnew file mode 120000\nindex 000000000..4c62dc3f7\n--- /dev/null\n+++ b/include/cadical/radix.hpp\n@@ -0,0 +1 @@\n+../../src/radix.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/random.hpp b/include/cadical/random.hpp\nnew file mode 120000\nindex 000000000..709253fbb\n--- /dev/null\n+++ b/include/cadical/random.hpp\n@@ -0,0 +1 @@\n+../../src/random.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/range.hpp b/include/cadical/range.hpp\nnew file mode 120000\nindex 000000000..b48ac58c2\n--- /dev/null\n+++ b/include/cadical/range.hpp\n@@ -0,0 +1 @@\n+../../src/range.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/reap.hpp b/include/cadical/reap.hpp\nnew file mode 120000\nindex 000000000..45ded52a0\n--- /dev/null\n+++ b/include/cadical/reap.hpp\n@@ -0,0 +1 @@\n+../../src/reap.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/reluctant.hpp b/include/cadical/reluctant.hpp\nnew file mode 120000\nindex 000000000..8f76390a6\n--- /dev/null\n+++ b/include/cadical/reluctant.hpp\n@@ -0,0 +1 @@\n+../../src/reluctant.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/resources.hpp b/include/cadical/resources.hpp\nnew file mode 120000\nindex 000000000..6877c6109\n--- /dev/null\n+++ b/include/cadical/resources.hpp\n@@ -0,0 +1 @@\n+../../src/resources.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/score.hpp b/include/cadical/score.hpp\nnew file mode 120000\nindex 000000000..1217eefee\n--- /dev/null\n+++ b/include/cadical/score.hpp\n@@ -0,0 +1 @@\n+../../src/score.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/signal.hpp b/include/cadical/signal.hpp\nnew file mode 120000\nindex 000000000..3565ba321\n--- /dev/null\n+++ b/include/cadical/signal.hpp\n@@ -0,0 +1 @@\n+../../src/signal.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/stats.hpp b/include/cadical/stats.hpp\nnew file mode 120000\nindex 000000000..38bfd4952\n--- /dev/null\n+++ b/include/cadical/stats.hpp\n@@ -0,0 +1 @@\n+../../src/stats.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/terminal.hpp b/include/cadical/terminal.hpp\nnew file mode 120000\nindex 000000000..18a443911\n--- /dev/null\n+++ b/include/cadical/terminal.hpp\n@@ -0,0 +1 @@\n+../../src/terminal.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/tracer.hpp b/include/cadical/tracer.hpp\nnew file mode 120000\nindex 000000000..70fc42f43\n--- /dev/null\n+++ b/include/cadical/tracer.hpp\n@@ -0,0 +1 @@\n+../../src/tracer.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/util.hpp b/include/cadical/util.hpp\nnew file mode 120000\nindex 000000000..339edabc2\n--- /dev/null\n+++ b/include/cadical/util.hpp\n@@ -0,0 +1 @@\n+../../src/util.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/var.hpp b/include/cadical/var.hpp\nnew file mode 120000\nindex 000000000..686673aae\n--- /dev/null\n+++ b/include/cadical/var.hpp\n@@ -0,0 +1 @@\n+../../src/var.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/veripbtracer.hpp b/include/cadical/veripbtracer.hpp\nnew file mode 120000\nindex 000000000..7d4005e48\n--- /dev/null\n+++ b/include/cadical/veripbtracer.hpp\n@@ -0,0 +1 @@\n+../../src/veripbtracer.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/version.hpp b/include/cadical/version.hpp\nnew file mode 120000\nindex 000000000..08dc92e41\n--- /dev/null\n+++ b/include/cadical/version.hpp\n@@ -0,0 +1 @@\n+../../src/version.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/vivify.hpp b/include/cadical/vivify.hpp\nnew file mode 120000\nindex 000000000..d88ea7be3\n--- /dev/null\n+++ b/include/cadical/vivify.hpp\n@@ -0,0 +1 @@\n+../../src/vivify.hpp\n\\ No newline at end of file\ndiff --git a/include/cadical/watch.hpp b/include/cadical/watch.hpp\nnew file mode 120000\nindex 000000000..a1d6251da\n--- /dev/null\n+++ b/include/cadical/watch.hpp\n@@ -0,0 +1 @@\n+../../src/watch.hpp\n\\ No newline at end of file\n\"\"\""
  },
  {
    "pr_number": 75,
    "title": "Fixing Option Ordering",
    "author": "BrianLi009",
    "head_sha": "ec09d92ab8f65af03777e877ddc5fbe847a898bf",
    "base_sha": "b2f125cfedf4f81bff049bf0a8bb0b95aaa1ca74",
    "head_ref": "fix",
    "base_ref": "master",
    "merge_commit_sha": "2db4f25359c80b3da15fa51149d730fe97d7d307",
    "state": "closed",
    "created_at": "2023-11-25T05:12:05Z",
    "updated_at": "2023-11-25T05:24:45Z",
    "merged_at": null,
    "pr_body": "Resolving the following error after compilation:\r\ncadical: fatal error: 'instantiateonce' ordered before 'idrup' in 'options.hpp'",
    "diff": "\"\"\"diff --git a/src/options.hpp b/src/options.hpp\nindex 16d3698d2..9d7ccbcc4 100644\n--- a/src/options.hpp\n+++ b/src/options.hpp\n@@ -98,6 +98,7 @@ OPTION( flushfactor,       3,  1,1e3,0,0,1, \"interval increase\") \\\n OPTION( flushint,        1e5,  1,2e9,0,0,1, \"initial limit\") \\\n OPTION( forcephase,        0,  0,  1,0,0,1, \"always use initial phase\") \\\n OPTION( frat,              0,  0,  2,0,0,1, \"1=frat(lrat), 2=frat(drat)\") \\\n+OPTION( idrup,              0,  0,  1,0,0,1, \"incremental proof format\") \\\n OPTION( ilb,               1,  0,  1,0,0,1, \"ILB (incremental lazy backtrack)\") \\\n OPTION( ilbassumptions,    1,  0,  1,0,0,1, \"trail reuse for assumptions (ILB-like)\") \\\n OPTION( inprocessing,      1,  0,  1,0,0,1, \"enable inprocessing\") \\\n@@ -105,7 +106,6 @@ OPTION( instantiate,       0,  0,  1,0,1,1, \"variable instantiation\") \\\n OPTION( instantiateclslim, 3,  2,2e9,0,0,1, \"minimum clause size\") \\\n OPTION( instantiateocclim, 1,  1,2e9,2,0,1, \"maximum occurrence limit\") \\\n OPTION( instantiateonce,   1,  0,  1,0,0,1, \"instantiate each clause once\") \\\n-OPTION( idrup,              0,  0,  1,0,0,1, \"incremental proof format\") \\\n LOGOPT( log,               0,  0,  1,0,0,0, \"enable logging\") \\\n LOGOPT( logsort,           0,  0,  1,0,0,0, \"sort logged clauses\") \\\n OPTION( lrat,              0,  0,  1,0,0,1, \"use lrat proof format\") \\\n\"\"\""
  },
  {
    "pr_number": 67,
    "title": "WIP: C interface for IPASIR-UP",
    "author": "Dekker1",
    "head_sha": "fb601b21192871f1d721a1d2d8bdb1b060408603",
    "base_sha": "831669281271639e0f5193380c1ae3a8b18379d2",
    "head_ref": "feature/c_ipasir_up",
    "base_ref": "master",
    "merge_commit_sha": "2654742f96e3a19684f85d6d47781aea7d89f6c1",
    "state": "closed",
    "created_at": "2023-10-03T03:20:43Z",
    "updated_at": "2023-10-07T00:02:32Z",
    "merged_at": null,
    "pr_body": "This PR adds a C interface for the functionality added by the IPASIR-UP API. The `CCaDiCaLPropagator` has a single attached `state` that is given to all call back functions added to the external propagator.\r\n\r\nI've tried to keep all code in IPASIR and CCaDiCaL as much in style as possible.\r\n\r\nI've marked this PR as `WIP` because the comments added are currently only copied from the triggered code. I will adjust them to be specific to the interface, and add the missing documentation to the undocumented functions.\r\n\r\nI would love to get any feedback on the interface design, code style, or any other details",
    "diff": "\"\"\"diff --git a/src/ccadical.cpp b/src/ccadical.cpp\nindex ac11e4456..5c7385f7d 100644\n--- a/src/ccadical.cpp\n+++ b/src/ccadical.cpp\n@@ -61,6 +61,84 @@ struct Wrapper : Learner, Terminator {\n   }\n };\n \n+struct PropagatorWrapper : ExternalPropagator {\n+  void *state;\n+\n+  void (*notify_assignment_fn) (void *state, int lit, bool is_fixed);\n+  void (*notify_new_decision_level_fn) (void *state);\n+  void (*notify_backtrack_fn) (void *state, size_t new_level);\n+\n+  bool (*check_model_fn) (void *state, size_t size, const int *model);\n+  int (*decide_fn) (void *state);\n+  int (*propagate_fn) (void *state);\n+  int (*add_reason_clause_lit_fn) (void *state, int propagated_lit);\n+  bool (*has_external_clause_fn) (void *state);\n+  int (*add_external_clause_lit_fn) (void *state);\n+\n+  PropagatorWrapper (void *state)\n+      : state (state), notify_assignment_fn (nullptr),\n+        notify_new_decision_level_fn (nullptr),\n+        notify_backtrack_fn (nullptr), check_model_fn (nullptr),\n+        propagate_fn (nullptr), add_reason_clause_lit_fn (nullptr),\n+        has_external_clause_fn (nullptr),\n+        add_external_clause_lit_fn (nullptr) {}\n+\n+  virtual void notify_assignment (int lit, bool is_fixed) {\n+    if (notify_assignment_fn != nullptr) {\n+      notify_assignment_fn (state, lit, is_fixed);\n+    }\n+  };\n+  virtual void notify_new_decision_level () {\n+    if (notify_new_decision_level_fn != nullptr) {\n+      notify_new_decision_level_fn (state);\n+    }\n+  };\n+  virtual void notify_backtrack (size_t new_level) {\n+    if (notify_backtrack_fn != nullptr) {\n+      notify_backtrack_fn (state, new_level);\n+    }\n+  };\n+\n+  virtual bool cb_check_found_model (const std::vector<int> &model) {\n+    if (check_model_fn != nullptr) {\n+      return check_model_fn (state, model.size (), model.data ());\n+    }\n+    return true;\n+  };\n+  virtual int cb_decide () {\n+    if (decide_fn != nullptr) {\n+      return decide_fn (state);\n+    }\n+    return 0;\n+  };\n+  virtual int cb_propagate () {\n+    if (propagate_fn != nullptr) {\n+      return propagate_fn (state);\n+    }\n+    return 0;\n+  };\n+\n+  virtual int cb_add_reason_clause_lit (int propagated_lit) {\n+    if (add_reason_clause_lit_fn != nullptr) {\n+      return add_reason_clause_lit_fn (state, propagated_lit);\n+    }\n+    return 0;\n+  };\n+\n+  virtual bool cb_has_external_clause () {\n+    if (has_external_clause_fn != nullptr) {\n+      return has_external_clause_fn (state);\n+    }\n+    return false;\n+  };\n+  virtual int cb_add_external_clause_lit () {\n+    if (add_external_clause_lit_fn != nullptr) {\n+      return add_external_clause_lit_fn (state);\n+    }\n+    return 0;\n+  };\n+};\n+\n } // namespace CaDiCaL\n \n using namespace CaDiCaL;\n@@ -173,4 +251,94 @@ void ccadical_melt (CCaDiCaL *ptr, int lit) {\n int ccadical_frozen (CCaDiCaL *ptr, int lit) {\n   return ((Wrapper *) ptr)->solver->frozen (lit);\n }\n+\n+void ccadical_connect_external_propagator (CCaDiCaL *slv,\n+                                           CCaDiCaLPropagator *prop) {\n+  ((Wrapper *) slv)\n+      ->solver->connect_external_propagator (((PropagatorWrapper *) prop));\n+}\n+void ccadical_disconnect_external_propagator (CCaDiCaL *slv) {\n+  ((Wrapper *) slv)->solver->disconnect_external_propagator ();\n+}\n+\n+void ccadical_add_observed_var (CCaDiCaL *slv, int var) {\n+  ((Wrapper *) slv)->solver->add_observed_var (var);\n+}\n+void ccadical_remove_observed_var (CCaDiCaL *slv, int var) {\n+  ((Wrapper *) slv)->solver->remove_observed_var (var);\n+}\n+void ccadical_reset_observed_vars (CCaDiCaL *slv) {\n+  ((Wrapper *) slv)->solver->reset_observed_vars ();\n+}\n+bool ccadical_is_decision (CCaDiCaL *slv, int lit) {\n+  return ((Wrapper *) slv)->solver->is_decision (lit);\n+}\n+\n+void ccadical_phase (CCaDiCaL *slv, int lit) {\n+  ((Wrapper *) slv)->solver->phase (lit);\n+}\n+void ccadical_unphase (CCaDiCaL *slv, int lit) {\n+  ((Wrapper *) slv)->solver->unphase (lit);\n+}\n+\n+CCaDiCaLPropagator *ccadical_prop_init (void *state) {\n+  return (CCaDiCaLPropagator *) new PropagatorWrapper (state);\n+}\n+void ccadical_prop_release (CCaDiCaLPropagator *prop) {\n+  delete (PropagatorWrapper *) prop;\n+}\n+void ccadical_prop_lazy (CCaDiCaLPropagator *prop, bool is_lazy) {\n+  ((PropagatorWrapper *) prop)->is_lazy = is_lazy;\n+}\n+\n+void ccadical_prop_set_notify_assignment (\n+    CCaDiCaLPropagator *prop,\n+    void (*notify_assignment) (void *state, int lit, bool is_fixed)) {\n+  ((PropagatorWrapper *) prop)->notify_assignment_fn = notify_assignment;\n+}\n+void ccadical_prop_set_notify_new_decision_level (\n+    CCaDiCaLPropagator *prop,\n+    void (*notify_new_decision_level) (void *state)) {\n+  ((PropagatorWrapper *) prop)->notify_new_decision_level_fn =\n+      notify_new_decision_level;\n+}\n+void ccadical_prop_set_notify_backtrack (\n+    CCaDiCaLPropagator *prop,\n+    void (*notify_backtrack) (void *state, size_t new_level)) {\n+  ((PropagatorWrapper *) prop)->notify_backtrack_fn = notify_backtrack;\n+}\n+\n+void ccadical_prop_set_check_model (\n+    CCaDiCaLPropagator *prop,\n+    bool (*check_model) (void *state, size_t size, const int *model)) {\n+  ((PropagatorWrapper *) prop)->check_model_fn = check_model;\n+}\n+\n+void ccadical_prop_set_decide (CCaDiCaLPropagator *prop,\n+                               int (*decide) (void *state)) {\n+  ((PropagatorWrapper *) prop)->decide_fn = decide;\n+}\n+void ccadical_prop_set_propagate (CCaDiCaLPropagator *prop,\n+                                  int (*propagate) (void *state)) {\n+  ((PropagatorWrapper *) prop)->propagate_fn = propagate;\n+}\n+\n+void ccadical_prop_set_add_reason_clause_lit (\n+    CCaDiCaLPropagator *prop,\n+    int (*add_reason_clause_lit) (void *state, int propagated_lit)) {\n+  ((PropagatorWrapper *) prop)->add_reason_clause_lit_fn =\n+      add_reason_clause_lit;\n+}\n+\n+void ccadical_prop_set_has_external_clause (\n+    CCaDiCaLPropagator *prop, bool (*has_external_clause) (void *state)) {\n+  ((PropagatorWrapper *) prop)->has_external_clause_fn =\n+      has_external_clause;\n+}\n+void ccadical_prop_set_add_external_clause_lit (\n+    CCaDiCaLPropagator *prop,\n+    int (*add_external_clause_lit) (void *state)) {\n+  ((PropagatorWrapper *) prop)->add_external_clause_lit_fn =\n+      add_external_clause_lit;\n+}\n }\ndiff --git a/src/ccadical.h b/src/ccadical.h\nindex 30a79b3c8..98e09e4ab 100644\n--- a/src/ccadical.h\n+++ b/src/ccadical.h\n@@ -7,6 +7,7 @@ extern \"C\" {\n #endif\n /*------------------------------------------------------------------------*/\n \n+#include <stddef.h>\n #include <stdint.h>\n \n // C wrapper for CaDiCaL's C++ API following IPASIR.\n@@ -31,6 +32,55 @@ void ccadical_set_learn (CCaDiCaL *, void *state, int max_length,\n \n /*------------------------------------------------------------------------*/\n \n+// C wrapper for CaDiCaL's C++ API following IPASIR-UP.\n+\n+typedef struct CCaDiCaLPropagator CCaDiCaLPropagator;\n+\n+void ccadical_connect_external_propagator (CCaDiCaL *,\n+                                           CCaDiCaLPropagator *);\n+void ccadical_disconnect_external_propagator (CCaDiCaL *);\n+\n+void ccadical_add_observed_var (CCaDiCaL *, int var);\n+void ccadical_remove_observed_var (CCaDiCaL *, int var);\n+void ccadical_reset_observed_vars (CCaDiCaL *);\n+bool ccadical_is_decision (CCaDiCaL *, int lit);\n+\n+void ccadical_phase (CCaDiCaL *, int lit);\n+void ccadical_unphase (CCaDiCaL *, int lit);\n+\n+CCaDiCaLPropagator *ccadical_prop_init (void *state);\n+void ccadical_prop_release (CCaDiCaLPropagator *);\n+void ccadical_prop_lazy (CCaDiCaLPropagator *, bool is_lazy);\n+\n+void ccadical_prop_set_notify_assignment (\n+    CCaDiCaLPropagator *,\n+    void (*notify_assignment) (void *state, int lit, bool is_fixed));\n+void ccadical_prop_set_notify_new_decision_level (\n+    CCaDiCaLPropagator *, void (*notify_new_decision_level) (void *state));\n+void ccadical_prop_set_notify_backtrack (\n+    CCaDiCaLPropagator *,\n+    void (*notify_backtrack) (void *state, size_t new_level));\n+\n+void ccadical_prop_set_check_model (CCaDiCaLPropagator *,\n+                                    bool (*check_model) (void *state,\n+                                                         size_t size,\n+                                                         const int *model));\n+void ccadical_prop_set_decide (CCaDiCaLPropagator *,\n+                               int (*decide) (void *state));\n+void ccadical_prop_set_propagate (CCaDiCaLPropagator *,\n+                                  int (*propagate) (void *state));\n+\n+void ccadical_prop_set_add_reason_clause_lit (\n+    CCaDiCaLPropagator *,\n+    int (*add_reason_clause_lit) (void *state, int propagated_lit));\n+\n+void ccadical_prop_set_has_external_clause (\n+    CCaDiCaLPropagator *, bool (*has_external_clause) (void *state));\n+void ccadical_prop_set_add_external_clause_lit (\n+    CCaDiCaLPropagator *, int (*add_external_clause_lit) (void *state));\n+\n+/*------------------------------------------------------------------------*/\n+\n // Non-IPASIR conformant 'C' functions.\n \n void ccadical_constrain (CCaDiCaL *, int lit);\ndiff --git a/src/ipasir.cpp b/src/ipasir.cpp\nindex 0eae5e95f..b78b73439 100644\n--- a/src/ipasir.cpp\n+++ b/src/ipasir.cpp\n@@ -1,5 +1,6 @@\n #include \"ipasir.h\"\n #include \"ccadical.h\"\n+#include \"ipasir_up.h\"\n \n extern \"C\" {\n \n@@ -40,4 +41,90 @@ void ipasir_set_learn (void *solver, void *state, int max_length,\n                        void (*learn) (void *state, int *clause)) {\n   ccadical_set_learn ((CCaDiCaL *) solver, state, max_length, learn);\n }\n+\n+void ipasir_connect_external_propagator (void *solver, void *propagator) {\n+  ccadical_connect_external_propagator ((CCaDiCaL *) solver,\n+                                        (CCaDiCaLPropagator *) propagator);\n+}\n+void ipasir_disconnect_external_propagator (void *solver) {\n+  ccadical_disconnect_external_propagator ((CCaDiCaL *) solver);\n+}\n+\n+void ipasir_add_observed_var (void *solver, int32_t var) {\n+  ccadical_add_observed_var ((CCaDiCaL *) solver, var);\n+}\n+void ipasir_remove_observed_var (void *solver, int32_t var) {\n+  ccadical_remove_observed_var ((CCaDiCaL *) solver, var);\n+}\n+void ipasir_reset_observed_vars (void *solver) {\n+  ccadical_reset_observed_vars ((CCaDiCaL *) solver);\n+}\n+\n+bool ipasir_is_decision (void *solver, int32_t lit) {\n+  return ccadical_is_decision ((CCaDiCaL *) solver, lit);\n+}\n+\n+void ipasir_phase (void *solver, int32_t lit) {\n+  ccadical_phase ((CCaDiCaL *) solver, lit);\n+}\n+void ipasir_unphase (void *solver, int32_t lit) {\n+  ccadical_unphase ((CCaDiCaL *) solver, lit);\n+}\n+\n+void *ipasir_prop_init (void *state) { return ccadical_prop_init (state); }\n+void ipasir_prop_release (void *prop) {\n+  return ccadical_prop_release ((CCaDiCaLPropagator *) prop);\n+}\n+\n+void ipasir_prop_lazy (void *prop, bool is_lazy) {\n+  ccadical_prop_lazy ((CCaDiCaLPropagator *) prop, is_lazy);\n+}\n+\n+void ipasir_prop_set_notify_assignment (\n+    void *prop,\n+    void (*notify_assignment) (void *state, int32_t lit, bool is_fixed)) {\n+  ccadical_prop_set_notify_assignment ((CCaDiCaLPropagator *) prop,\n+                                       notify_assignment);\n+}\n+void ipasir_prop_set_notify_new_decision_level (\n+    void *prop, void (*notify_new_decision_level) (void *state)) {\n+  ccadical_prop_set_notify_new_decision_level ((CCaDiCaLPropagator *) prop,\n+                                               notify_new_decision_level);\n+}\n+void ipasir_prop_set_notify_backtrack (\n+    void *prop, void (*notify_backtrack) (void *state, size_t new_level)) {\n+  ccadical_prop_set_notify_backtrack ((CCaDiCaLPropagator *) prop,\n+                                      notify_backtrack);\n+}\n+\n+void ipasir_prop_set_check_model (\n+    void *prop,\n+    bool (*check_model) (void *state, size_t size, const int32_t *model)) {\n+  ccadical_prop_set_check_model ((CCaDiCaLPropagator *) prop, check_model);\n+}\n+void ipasir_prop_set_decide (void *prop, int32_t (*decide) (void *state)) {\n+  ccadical_prop_set_decide ((CCaDiCaLPropagator *) prop, decide);\n+}\n+void ipasir_prop_set_propagate (void *prop,\n+                                int32_t (*propagate) (void *state)) {\n+  ccadical_prop_set_propagate ((CCaDiCaLPropagator *) prop, propagate);\n+}\n+\n+void ipasir_prop_set_add_reason_clause_lit (\n+    void *prop,\n+    int32_t (*add_reason_clause_lit) (void *state, int propagated_lit)) {\n+  ccadical_prop_set_add_reason_clause_lit ((CCaDiCaLPropagator *) prop,\n+                                           add_reason_clause_lit);\n+}\n+\n+void ipasir_prop_set_has_external_clause (\n+    void *prop, bool (*has_external_clause) (void *state)) {\n+  ccadical_prop_set_has_external_clause ((CCaDiCaLPropagator *) prop,\n+                                         has_external_clause);\n+}\n+void ipasir_prop_set_add_external_clause_lit (\n+    void *prop, int32_t (*add_external_clause_lit) (void *state)) {\n+  ccadical_prop_set_add_external_clause_lit ((CCaDiCaLPropagator *) prop,\n+                                             add_external_clause_lit);\n+}\n }\ndiff --git a/src/ipasir_up.h b/src/ipasir_up.h\nnew file mode 100644\nindex 000000000..3bf24b093\n--- /dev/null\n+++ b/src/ipasir_up.h\n@@ -0,0 +1,145 @@\n+#ifndef _ipasir_up_h_INCLUDED\n+#define _ipasir_up_h_INCLUDED\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/*------------------------------------------------------------------------*/\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+/*------------------------------------------------------------------------*/\n+\n+// Add call-back which allows to learn, propagate and backtrack based on\n+// external constraints. Only one external propagator can be connected\n+// and after connection every related variables must be 'observed' (use\n+// 'add_observed_var' function).\n+// Disconnection of the external propagator resets all the observed\n+// variables.\n+//\n+//   require (VALID)\n+//   ensure (VALID)\n+//\n+void ipasir_connect_external_propagator (void *solver, void *propagator);\n+void ipasir_disconnect_external_propagator (void *solver);\n+\n+// Mark as 'observed' those variables that are relevant to the external\n+// propagator. External propagation, clause addition during search and\n+// notifications are all over these observed variabes.\n+// A variable can not be observed witouth having an external propagator\n+// connected. Observed variables are \"frozen\" internally, and so\n+// inprocessing will not consider them as candidates for elimination.\n+// An observed variable is allowed to be a fresh variable and it can be\n+// added also during solving.\n+//\n+//   require (VALID_OR_SOLVING)\n+//   ensure (VALID_OR_SOLVING)\n+//\n+void ipasir_add_observed_var (void *solver, int32_t var);\n+\n+// Removes the 'observed' flag from the given variable. A variable can be\n+// set unobserved only between solve calls, not during it (to guarantee\n+// that no yet unexplained external propagation involves it).\n+//\n+//   require (VALID)\n+//   ensure (VALID)\n+//\n+void ipasir_remove_observed_var (void *solver, int32_t var);\n+\n+// Removes all the 'observed' flags from the variables. Disconnecting the\n+// propagator invokes this step as well.\n+//\n+//   require (VALID)\n+//   ensure (VALID)\n+//\n+void ipasir_reset_observed_vars (void *solver);\n+\n+// Get reason of valid observed literal (true = it is an observed variable\n+// and it got assigned by a decision during the CDCL loop. Otherwise:\n+// false.\n+//\n+//   require (VALID_OR_SOLVING)\n+//   ensure (VALID_OR_SOLVING)\n+//\n+bool ipasir_is_decision (void *solver, int32_t lit);\n+\n+void ipasir_phase (void *solver, int32_t lit);\n+void ipasir_unphase (void *solver, int32_t lit);\n+\n+void *ipasir_prop_init (void *state);\n+void ipasir_prop_release (void *prop);\n+\n+// This flag is currently checked only when the propagator is connected.\n+// lazy propagator only checks complete assignments\n+void ipasir_prop_lazy (void *prop, bool is_lazy);\n+\n+// Notify the propagator about assignments to observed variables.\n+// The notification is not necessarily eager. It usually happens before\n+// the call of propagator callbacks and when a driving clause is leading\n+// to an assignment.\n+void ipasir_prop_set_notify_assignment (\n+    void *prop,\n+    void (*notify_assignment) (void *state, int32_t lit, bool is_fixed));\n+void ipasir_prop_set_notify_new_decision_level (\n+    void *prop, void (*notify_new_decision_level) (void *state));\n+void ipasir_prop_set_notify_backtrack (\n+    void *prop, void (*notify_backtrack) (void *state, size_t new_level));\n+\n+// Check by the external propagator the found complete solution (after\n+// solution reconstruction). If it returns false, the propagator must\n+// provide an external clause during the next callback.\n+void ipasir_prop_set_check_model (\n+    void *prop,\n+    bool (*check_model) (void *state, size_t size, const int32_t *model));\n+\n+// Ask the external propagator for the next decision literal. If it\n+// returns 0, the solver makes its own choice.\n+void ipasir_prop_set_decide (void *prop, int32_t (*decide) (void *state));\n+\n+// Ask the external propagator if there is an external propagation to make\n+// under the current assignment. It returns either a literal to be\n+// propagated or 0, indicating that there is no external propagation under\n+// the current assignment.\n+void ipasir_prop_set_propagate (void *prop,\n+                                int32_t (*propagate) (void *state));\n+\n+// Ask the external propagator for the reason clause of a previous\n+// external propagation step (done by cb_propagate). The clause must be\n+// added literal-by-literal closed with a 0. Further, the clause must\n+// contain the propagated literal.\n+void ipasir_prop_set_add_reason_clause_lit (\n+    void *prop,\n+    int32_t (*add_reason_clause_lit) (void *state, int propagated_lit));\n+\n+// The following two functions are used to add external clauses to the\n+// solver during the CDCL loop. The external clause is added\n+// literal-by-literal and learned by the solver as an irredundant\n+// (original) input clause. The clause can be arbitrary, but if it is\n+// root-satisfied or tautology, the solver will ignore it without learning\n+// it. Root-falsified literals are eagerly removed from the clause.\n+// Falsified clauses trigger conflict analysis, propagating clauses\n+// trigger propagation. In case chrono is 0, the solver backtracks to\n+// propagate the new literal on the right decision level, otherwise it\n+// potentially will be an out-of-order assignment on the current level.\n+// Unit clauses always (unless root-satisfied, see above) trigger\n+// backtracking (independently from the value of the chrono option and\n+// independently from being falsified or satisfied or unassigned) to level\n+// 0. Empty clause (or root falsified clause, see above) makes the problem\n+// unsat and stops the search immediately. A literal 0 must close the\n+// clause.\n+\n+// The external propagator indicates that there is a clause to add.\n+void ipasir_prop_set_has_external_clause (\n+    void *prop, bool (*has_external_clause) (void *state));\n+\n+// The actual function called to add the external clause.\n+void ipasir_prop_set_add_external_clause_lit (\n+    void *prop, int32_t (*add_external_clause_lit) (void *state));\n+\n+/*------------------------------------------------------------------------*/\n+#ifdef __cplusplus\n+}\n+#endif\n+/*------------------------------------------------------------------------*/\n+\n+#endif\n\"\"\""
  },
  {
    "pr_number": 62,
    "title": "Fix LRAT error handling in Solver::set().",
    "author": "aniemetz",
    "head_sha": "0f1cfc15306113cdd33126a81f40940d95964822",
    "base_sha": "70f593ae33e96c5fb4257e9efdfe10a9aa637c50",
    "head_ref": "set-lrat-fix",
    "base_ref": "master",
    "merge_commit_sha": "9aad8b00372f45c0d1299cb9bf385bf758c6cb19",
    "state": "closed",
    "created_at": "2023-08-21T23:31:35Z",
    "updated_at": "2023-09-04T07:22:57Z",
    "merged_at": null,
    "pr_body": "This fixes incorrect error handling to guard not using lrat with\r\nexternal propagators, which caused the guard to fire every time\r\nSolver::set() was called.",
    "diff": "\"\"\"diff --git a/src/solver.cpp b/src/solver.cpp\nindex 3887a97cc..c31dab69d 100644\n--- a/src/solver.cpp\n+++ b/src/solver.cpp\n@@ -456,7 +456,7 @@ bool Solver::set (const char *arg, int val) {\n         \"can only set option 'set (\\\"%s\\\", %d)' right after initialization\",\n         arg, val);\n   }\n-  if (strcmp (arg, \"lrat\")) {\n+  if (!strcmp (arg, \"lrat\")) {\n     REQUIRE (!internal->external_prop,\n              \"lrat is currently not compatible with external propagation\");\n   }\n\"\"\""
  },
  {
    "pr_number": 38,
    "title": "Create 'src/makefile' symlink during configure",
    "author": "recoules",
    "head_sha": "e52fb3b22d2ab8d764f974cae01dec701b19c6f5",
    "base_sha": "88623ef0866370448c34f6e320c148fc18e6f4cc",
    "head_ref": "master",
    "base_ref": "master",
    "merge_commit_sha": "cd631e6a5a6e3d505a426ec17d4ce59a30efb3c0",
    "state": "closed",
    "created_at": "2021-06-20T11:04:28Z",
    "updated_at": "2021-06-21T07:14:30Z",
    "merged_at": null,
    "pr_body": "Closes #36.",
    "diff": "\"\"\"diff --git a/configure b/configure\nindex f96269b46..7f8200375 100755\n--- a/configure\n+++ b/configure\n@@ -436,6 +436,7 @@ msg \"generated '$build/makefile' from '../makefile.in'\"\n \n build=\"`pwd`\"\n makefile=\"`dirname \"$build\"`/makefile\"\n+symlink=\"$root/src/makefile\"\n cat <<EOF > \"$makefile\"\n CADICALBUILD=$build\n all:\n@@ -451,6 +452,7 @@ clean:\n \t  rm -rf \"\\$(CADICALBUILD)\"; \\\\\n \tfi\n \trm -f \"$makefile\"\n+\trm -f \"$symlink\"\n test:\n \t\\$(MAKE) -C \"\\$(CADICALBUILD)\" test\n cadical:\n@@ -461,6 +463,7 @@ update:\n \t\\$(MAKE) -C \"\\$(CADICALBUILD)\" update\n .PHONY: all cadical clean mobical test update\n EOF\n+ln -s \"$makefile\" \"$symlink\"\n \n msg \"generated '../makefile' as proxy to ...\"\n msg \"... '$build/makefile'\"\ndiff --git a/src/makefile b/src/makefile\ndeleted file mode 120000\nindex cc63b08c8..000000000\n--- a/src/makefile\n+++ /dev/null\n@@ -1 +0,0 @@\n-../makefile\n\\ No newline at end of file\n\"\"\""
  },
  {
    "pr_number": 34,
    "title": "Compatibility with C++11",
    "author": "m-fleury",
    "head_sha": "a439820ee7da2eca652c202d624c13c1f9696ff5",
    "base_sha": "0e209ae20ae3ac563750edae83bdb4a753d798d6",
    "head_ref": "master",
    "base_ref": "master",
    "merge_commit_sha": "88623ef0866370448c34f6e320c148fc18e6f4cc",
    "state": "closed",
    "created_at": "2021-04-30T07:54:51Z",
    "updated_at": "2021-04-30T17:46:59Z",
    "merged_at": "2021-04-30T17:46:58Z",
    "pr_body": "* also remove the deprecated ualarm\r\n* C++11 instead of C++14\r\n* Should also fix part of #32.",
    "diff": "\"\"\"diff --git a/configure b/configure\nindex bdb943bb5..f96269b46 100755\n--- a/configure\n+++ b/configure\n@@ -281,7 +281,7 @@ fi\n [ $coverage = yes ] && CXXFLAGS=\"$CXXFLAGS -ftest-coverage -fprofile-arcs\"\n if [ $pedantic = yes ]\n then\n-  CXXFLAGS=\"$CXXFLAGS --pedantic -Werror -std=c++14\"\n+  CXXFLAGS=\"$CXXFLAGS --pedantic -Werror -std=c++11\"\n   case x\"$CXX\" in\n     xg++*|xclang++*) CXXFLAGS=\"${CXXFLAGS} -Wp,-D_GLIBCXX_ASSERTIONS\"\n     ;;\n@@ -328,10 +328,9 @@ fi\n # explicitly enforce the new standard with '-std=c++11'.  Here we try to\n # figure out whether we need that flag.  In earlier versions we used\n # '-std=c++0x' but due to issues with older MacOS builds we switched to\n-# '-std=c++11' instead and more recently, due to using reverse iterators\n-# as well as 'std::rend' and 'std::rbegin', we even switched to 'C++14'.\n+# '-std=c++11' instead.\n \n-feature=./configure-requires-c++14\n+feature=./configure-requires-c++11\n cat <<EOF > $feature.cpp\n #include <cstdio>\n #include <vector>\n@@ -350,11 +349,6 @@ unsigned f (const std::vector<unsigned> & a) {\n   return res;\n }\n \n-// we want to use reverse iterators too available since C++14\n-//\n-bool g (const std::vector<int> & a) {\n-  return std::rbegin (a) == std::rend (a);\n-}\n \n int main () { MACRO (\"%d\", 42); return 0; }\n EOF\n@@ -362,22 +356,22 @@ if $CXX $CXXFLAGS $WERROR -o $feature.exe $feature.cpp 2>>configure.log\n then\n   if [ \"`$feature.exe 2>>configure.log|tr -d '\\r'`\" = 42 ]\n   then\n-    msg \"compiler supports all required C99/C++14 extensions\"\n+    msg \"compiler supports all required C99/C++11 extensions\"\n   else\n-    die \"checking compilation without '-std=c++14' failed\"\n+    die \"checking compilation without '-std=c++11' failed\"\n   fi\n else\n-  CXXFLAGS=\"$CXXFLAGS -std=c++14\"\n+  CXXFLAGS=\"$CXXFLAGS -std=c++11\"\n   if $CXX $CXXFLAGS -o $feature.exe $feature.cpp 2>>configure.log\n   then\n     if [ \"`$feature.exe 2>>configure.log|tr -d '\\r'`\" = 42 ]\n     then\n-      msg \"using '-std=c++14' for all required C99/C++14 extensions\"\n+      msg \"using '-std=c++11' for all required C99/C++11 extensions\"\n     else\n-      die \"checking compilation with '-std=c++14' failed\"\n+      die \"checking compilation with '-std=c++11' failed\"\n     fi\n   else\n-    die \"compiler does not support C99/C++14 even with '-std=c++14'\"\n+    die \"compiler does not support C99/C++11 even with '-std=c++11'\"\n   fi\n fi\n \ndiff --git a/src/heap.hpp b/src/heap.hpp\nindex eb29c5f17..5e470afee 100644\n--- a/src/heap.hpp\n+++ b/src/heap.hpp\n@@ -28,7 +28,6 @@ template<class C> class heap {\n   // Map an element to its position entry in the 'pos' map.\n   //\n   unsigned & index (unsigned e) {\n-    assert (e >= 0);\n     while ((size_t) e >= pos.size ()) pos.push_back (invalid_heap_position);\n     unsigned & res = pos[e];\n     assert (res == invalid_heap_position || (size_t) res < array.size ());\n@@ -126,7 +125,6 @@ template<class C> class heap {\n   // Check whether 'e' is already in the heap.\n   //\n   bool contains (unsigned e) const {\n-    assert (e >= 0);\n     if ((size_t) e >= pos.size ()) return false;\n     return pos[e] != invalid_heap_position;\n   }\ndiff --git a/src/shrink.cpp b/src/shrink.cpp\nindex 40acefe1d..3b5228af9 100644\n--- a/src/shrink.cpp\n+++ b/src/shrink.cpp\n@@ -106,7 +106,7 @@ namespace CaDiCaL {\n \n     LOG(\"UIP on level %u, uip: %i (replacing by %i)\", blevel, uip, uip0);\n     assert(rend_block > rbegin_block);\n-    assert(rend_block < rend(clause));\n+    assert(rend_block < clause.rend());\n     unsigned block_shrunken = 0;\n     *rbegin_block = -uip;\n     Var &v = var(-uip);\n@@ -337,7 +337,7 @@ namespace CaDiCaL {\n \n   {\n     LOG(\"shrinking block\");\n-    assert(rbegin_block < rend(clause) -1);\n+    assert(rbegin_block < clause.rend() -1);\n     int blevel;\n     unsigned open = 0;\n     unsigned max_trail;\n@@ -345,7 +345,7 @@ namespace CaDiCaL {\n     // find begining of block;\n     std::vector<int>::reverse_iterator rend_block;\n     {\n-      assert(rbegin_block <= rend(clause));\n+      assert(rbegin_block <= clause.rend());\n       const int lit = *rbegin_block;\n       const int idx = vidx (lit);\n       blevel = vtab[idx].level;\n@@ -371,7 +371,7 @@ namespace CaDiCaL {\n     assert(open > 0);\n     assert(open < clause.size());\n     assert(rbegin_block < clause.rend());\n-    assert(rend_block < rend(clause));\n+    assert(rend_block < clause.rend());\n \n     unsigned block_shrunken = 0, block_minimized = 0;\n     if (open < 2) {\n@@ -403,8 +403,8 @@ namespace CaDiCaL {\n \n     LOG(clause, \"shrink first UIP clause (asserting lit: %i)\", clause[0]);\n \n-    auto rend_lits = std::rend(clause)-1;\n-    auto rend_block = std::rbegin(clause);\n+    auto rend_lits = clause.rend() -1;\n+    auto rend_block = clause.rbegin();\n     const int uip0 = clause[0];\n \n     while (rend_block != rend_lits) {\ndiff --git a/test/api/cipasir.c b/test/api/cipasir.c\nindex 44ee5d0dc..9972731c7 100644\n--- a/test/api/cipasir.c\n+++ b/test/api/cipasir.c\n@@ -7,7 +7,7 @@\n #include <assert.h>\n #include <signal.h>\n #include <stdio.h>\n-#include <unistd.h>\n+#include <sys/time.h>\n \n #if __GNUC__ > 4 || defined(__llvm__)\n static const int n = 8;\n@@ -85,7 +85,18 @@ int main () {\n     fflush (stdout);\n     saved = signal (SIGALRM, handler);\n #if __GNUC__ > 4 || defined(__llvm__)\n-    ualarm (2e4, 0);\n+    struct timeval value;\n+    value.tv_sec = 0;\n+    value.tv_usec = 2e4;\n+\n+    struct timeval interval;\n+    interval.tv_sec = 0;\n+    interval.tv_usec = 0;\n+\n+    struct itimerval t;\n+    t.it_interval = interval;\n+    t.it_value = value;\n+    setitimer(0, &t, NULL);\n #else\n     alarm (1);\n #endif\ndiff --git a/test/api/run.sh b/test/api/run.sh\nindex 713cf96b8..5ee10e9c9 100755\n--- a/test/api/run.sh\n+++ b/test/api/run.sh\n@@ -73,7 +73,7 @@ run () {\n   then\n     src=$tests/$1.c\n     language=\" -x c\"\n-    COMPILE=\"$CXX `echo $CXXFLAGS|sed -e 's,-std=c++14,-std=c11,'`\"\n+    COMPILE=\"$CXX `echo $CXXFLAGS|sed -e 's,-std=c++11,-std=c11,'`\"\n   elif [ -f $tests/$1.cpp ]\n   then\n     src=$tests/$1.cpp\n\"\"\""
  },
  {
    "pr_number": 33,
    "title": "Change code to be compatible with C++11",
    "author": "m-fleury",
    "head_sha": "a439820ee7da2eca652c202d624c13c1f9696ff5",
    "base_sha": "0e209ae20ae3ac563750edae83bdb4a753d798d6",
    "head_ref": "master",
    "base_ref": "master",
    "merge_commit_sha": "6bfc97e1b9f75e85a772fc898eda2f1f5fe6aecb",
    "state": "closed",
    "created_at": "2021-04-30T05:27:42Z",
    "updated_at": "2021-04-30T05:59:06Z",
    "merged_at": null,
    "pr_body": "Should also fix part of #32.",
    "diff": "\"\"\"diff --git a/configure b/configure\nindex bdb943bb5..f96269b46 100755\n--- a/configure\n+++ b/configure\n@@ -281,7 +281,7 @@ fi\n [ $coverage = yes ] && CXXFLAGS=\"$CXXFLAGS -ftest-coverage -fprofile-arcs\"\n if [ $pedantic = yes ]\n then\n-  CXXFLAGS=\"$CXXFLAGS --pedantic -Werror -std=c++14\"\n+  CXXFLAGS=\"$CXXFLAGS --pedantic -Werror -std=c++11\"\n   case x\"$CXX\" in\n     xg++*|xclang++*) CXXFLAGS=\"${CXXFLAGS} -Wp,-D_GLIBCXX_ASSERTIONS\"\n     ;;\n@@ -328,10 +328,9 @@ fi\n # explicitly enforce the new standard with '-std=c++11'.  Here we try to\n # figure out whether we need that flag.  In earlier versions we used\n # '-std=c++0x' but due to issues with older MacOS builds we switched to\n-# '-std=c++11' instead and more recently, due to using reverse iterators\n-# as well as 'std::rend' and 'std::rbegin', we even switched to 'C++14'.\n+# '-std=c++11' instead.\n \n-feature=./configure-requires-c++14\n+feature=./configure-requires-c++11\n cat <<EOF > $feature.cpp\n #include <cstdio>\n #include <vector>\n@@ -350,11 +349,6 @@ unsigned f (const std::vector<unsigned> & a) {\n   return res;\n }\n \n-// we want to use reverse iterators too available since C++14\n-//\n-bool g (const std::vector<int> & a) {\n-  return std::rbegin (a) == std::rend (a);\n-}\n \n int main () { MACRO (\"%d\", 42); return 0; }\n EOF\n@@ -362,22 +356,22 @@ if $CXX $CXXFLAGS $WERROR -o $feature.exe $feature.cpp 2>>configure.log\n then\n   if [ \"`$feature.exe 2>>configure.log|tr -d '\\r'`\" = 42 ]\n   then\n-    msg \"compiler supports all required C99/C++14 extensions\"\n+    msg \"compiler supports all required C99/C++11 extensions\"\n   else\n-    die \"checking compilation without '-std=c++14' failed\"\n+    die \"checking compilation without '-std=c++11' failed\"\n   fi\n else\n-  CXXFLAGS=\"$CXXFLAGS -std=c++14\"\n+  CXXFLAGS=\"$CXXFLAGS -std=c++11\"\n   if $CXX $CXXFLAGS -o $feature.exe $feature.cpp 2>>configure.log\n   then\n     if [ \"`$feature.exe 2>>configure.log|tr -d '\\r'`\" = 42 ]\n     then\n-      msg \"using '-std=c++14' for all required C99/C++14 extensions\"\n+      msg \"using '-std=c++11' for all required C99/C++11 extensions\"\n     else\n-      die \"checking compilation with '-std=c++14' failed\"\n+      die \"checking compilation with '-std=c++11' failed\"\n     fi\n   else\n-    die \"compiler does not support C99/C++14 even with '-std=c++14'\"\n+    die \"compiler does not support C99/C++11 even with '-std=c++11'\"\n   fi\n fi\n \ndiff --git a/src/heap.hpp b/src/heap.hpp\nindex eb29c5f17..5e470afee 100644\n--- a/src/heap.hpp\n+++ b/src/heap.hpp\n@@ -28,7 +28,6 @@ template<class C> class heap {\n   // Map an element to its position entry in the 'pos' map.\n   //\n   unsigned & index (unsigned e) {\n-    assert (e >= 0);\n     while ((size_t) e >= pos.size ()) pos.push_back (invalid_heap_position);\n     unsigned & res = pos[e];\n     assert (res == invalid_heap_position || (size_t) res < array.size ());\n@@ -126,7 +125,6 @@ template<class C> class heap {\n   // Check whether 'e' is already in the heap.\n   //\n   bool contains (unsigned e) const {\n-    assert (e >= 0);\n     if ((size_t) e >= pos.size ()) return false;\n     return pos[e] != invalid_heap_position;\n   }\ndiff --git a/src/shrink.cpp b/src/shrink.cpp\nindex 40acefe1d..3b5228af9 100644\n--- a/src/shrink.cpp\n+++ b/src/shrink.cpp\n@@ -106,7 +106,7 @@ namespace CaDiCaL {\n \n     LOG(\"UIP on level %u, uip: %i (replacing by %i)\", blevel, uip, uip0);\n     assert(rend_block > rbegin_block);\n-    assert(rend_block < rend(clause));\n+    assert(rend_block < clause.rend());\n     unsigned block_shrunken = 0;\n     *rbegin_block = -uip;\n     Var &v = var(-uip);\n@@ -337,7 +337,7 @@ namespace CaDiCaL {\n \n   {\n     LOG(\"shrinking block\");\n-    assert(rbegin_block < rend(clause) -1);\n+    assert(rbegin_block < clause.rend() -1);\n     int blevel;\n     unsigned open = 0;\n     unsigned max_trail;\n@@ -345,7 +345,7 @@ namespace CaDiCaL {\n     // find begining of block;\n     std::vector<int>::reverse_iterator rend_block;\n     {\n-      assert(rbegin_block <= rend(clause));\n+      assert(rbegin_block <= clause.rend());\n       const int lit = *rbegin_block;\n       const int idx = vidx (lit);\n       blevel = vtab[idx].level;\n@@ -371,7 +371,7 @@ namespace CaDiCaL {\n     assert(open > 0);\n     assert(open < clause.size());\n     assert(rbegin_block < clause.rend());\n-    assert(rend_block < rend(clause));\n+    assert(rend_block < clause.rend());\n \n     unsigned block_shrunken = 0, block_minimized = 0;\n     if (open < 2) {\n@@ -403,8 +403,8 @@ namespace CaDiCaL {\n \n     LOG(clause, \"shrink first UIP clause (asserting lit: %i)\", clause[0]);\n \n-    auto rend_lits = std::rend(clause)-1;\n-    auto rend_block = std::rbegin(clause);\n+    auto rend_lits = clause.rend() -1;\n+    auto rend_block = clause.rbegin();\n     const int uip0 = clause[0];\n \n     while (rend_block != rend_lits) {\ndiff --git a/test/api/cipasir.c b/test/api/cipasir.c\nindex 44ee5d0dc..9972731c7 100644\n--- a/test/api/cipasir.c\n+++ b/test/api/cipasir.c\n@@ -7,7 +7,7 @@\n #include <assert.h>\n #include <signal.h>\n #include <stdio.h>\n-#include <unistd.h>\n+#include <sys/time.h>\n \n #if __GNUC__ > 4 || defined(__llvm__)\n static const int n = 8;\n@@ -85,7 +85,18 @@ int main () {\n     fflush (stdout);\n     saved = signal (SIGALRM, handler);\n #if __GNUC__ > 4 || defined(__llvm__)\n-    ualarm (2e4, 0);\n+    struct timeval value;\n+    value.tv_sec = 0;\n+    value.tv_usec = 2e4;\n+\n+    struct timeval interval;\n+    interval.tv_sec = 0;\n+    interval.tv_usec = 0;\n+\n+    struct itimerval t;\n+    t.it_interval = interval;\n+    t.it_value = value;\n+    setitimer(0, &t, NULL);\n #else\n     alarm (1);\n #endif\ndiff --git a/test/api/run.sh b/test/api/run.sh\nindex 713cf96b8..5ee10e9c9 100755\n--- a/test/api/run.sh\n+++ b/test/api/run.sh\n@@ -73,7 +73,7 @@ run () {\n   then\n     src=$tests/$1.c\n     language=\" -x c\"\n-    COMPILE=\"$CXX `echo $CXXFLAGS|sed -e 's,-std=c++14,-std=c11,'`\"\n+    COMPILE=\"$CXX `echo $CXXFLAGS|sed -e 's,-std=c++11,-std=c11,'`\"\n   elif [ -f $tests/$1.cpp ]\n   then\n     src=$tests/$1.cpp\n\"\"\""
  },
  {
    "pr_number": 5,
    "title": "Remove `;` at closing bracket of namespace and extern C declaration",
    "author": "mgudemann",
    "head_sha": "867d981c9ad1bb05356a88450dcfc17d87d1e50a",
    "base_sha": "b44ce4f0e64aa400358ae3a8adb45b24ae6e742c",
    "head_ref": "enhancement/remove_semicolon_after_closing_bracket",
    "base_ref": "master",
    "merge_commit_sha": "3409150156697f19058143d8d2cf9bfe2fbfafa2",
    "state": "closed",
    "created_at": "2018-05-04T07:10:57Z",
    "updated_at": "2018-05-04T09:55:16Z",
    "merged_at": null,
    "pr_body": "This removes the warnings about `warning: extra \u2018;\u2019 [-Wpedantic]` when compiling with `g++` with `-Wall -Wpedantic`, see also #4 ",
    "diff": "\"\"\"diff --git a/src/analyze.cpp b/src/analyze.cpp\nindex ef182e6c7..1fe50caff 100644\n--- a/src/analyze.cpp\n+++ b/src/analyze.cpp\n@@ -291,4 +291,4 @@ void Internal::analyze () {\n \n void Internal::iterate () { iterating = false; report ('i'); }\n \n-};\n+}\ndiff --git a/src/app.cpp b/src/app.cpp\nindex b6eae924b..1406964a3 100644\n--- a/src/app.cpp\n+++ b/src/app.cpp\n@@ -25,7 +25,7 @@\n \n extern \"C\" {\n #include \"unistd.h\"     // for 'isatty'\n-};\n+}\n \n /*------------------------------------------------------------------------*/\n \n@@ -232,4 +232,4 @@ int App::main (int argc, char ** argv) {\n   return res;\n }\n \n-};\n+}\ndiff --git a/src/app.hpp b/src/app.hpp\nindex 6d41aacfb..fbd7517ef 100644\n--- a/src/app.hpp\n+++ b/src/app.hpp\n@@ -35,6 +35,6 @@ class App {\n   static int main (int arg, char ** argv);\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/arena.cpp b/src/arena.cpp\nindex 68f01746a..6515b3c31 100644\n--- a/src/arena.cpp\n+++ b/src/arena.cpp\n@@ -29,4 +29,4 @@ void Arena::swap () {\n   to.start = to.top = to.end = 0;\n }\n \n-};\n+}\ndiff --git a/src/arena.hpp b/src/arena.hpp\nindex eafbfa36e..9a994c1d5 100644\n--- a/src/arena.hpp\n+++ b/src/arena.hpp\n@@ -98,6 +98,6 @@ class Arena {\n   void swap ();\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/backtrack.cpp b/src/backtrack.cpp\nindex 53d8e74c5..a77c4ccb3 100644\n--- a/src/backtrack.cpp\n+++ b/src/backtrack.cpp\n@@ -32,4 +32,4 @@ void Internal::backtrack (int target_level) {\n   level = target_level;\n }\n \n-};\n+}\ndiff --git a/src/bins.cpp b/src/bins.cpp\nindex ea0b977cf..ddfd1e679 100644\n--- a/src/bins.cpp\n+++ b/src/bins.cpp\n@@ -17,4 +17,4 @@ void Internal::reset_bins () {\n   big = 0;\n }\n \n-};\n+}\ndiff --git a/src/bins.hpp b/src/bins.hpp\nindex e4e4ec424..18781a032 100644\n--- a/src/bins.hpp\n+++ b/src/bins.hpp\n@@ -23,6 +23,6 @@ inline void erase_bins (Bins & bs) { erase_vector (bs); }\n typedef Bins::iterator bins_iterator;\n typedef Bins::const_iterator const_bins_iterator;\n \n-};\n+}\n \n #endif\ndiff --git a/src/cadical.cpp b/src/cadical.cpp\nindex bbe624bd5..98f95d852 100644\n--- a/src/cadical.cpp\n+++ b/src/cadical.cpp\n@@ -209,4 +209,4 @@ void Solver::error (const char * fmt, ...) {\n   va_end (ap);\n }\n \n-};\n+}\ndiff --git a/src/cadical.hpp b/src/cadical.hpp\nindex cf0739984..d0147f098 100644\n--- a/src/cadical.hpp\n+++ b/src/cadical.hpp\n@@ -141,6 +141,6 @@ class Solver {\n   File * output ();             // get access to internal 'output' file\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/ccadical.cpp b/src/ccadical.cpp\nindex 4779d77be..fe6a93cdd 100644\n--- a/src/ccadical.cpp\n+++ b/src/ccadical.cpp\n@@ -39,5 +39,4 @@ void ccadical_print_statistics (CCaDiCaL * solver) {\n   ((Solver*) solver)->statistics ();\n }\n \n-};\n-\n+}\ndiff --git a/src/clause.cpp b/src/clause.cpp\nindex a2c4bdd9f..f788e4ef1 100644\n--- a/src/clause.cpp\n+++ b/src/clause.cpp\n@@ -361,4 +361,4 @@ Clause * Internal::new_resolved_irredundant_clause () {\n   return res;\n }\n \n-};\n+}\ndiff --git a/src/clause.hpp b/src/clause.hpp\nindex 11300771b..698c5a765 100644\n--- a/src/clause.hpp\n+++ b/src/clause.hpp\n@@ -176,6 +176,6 @@ struct lit_less_than {\n   }\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/collect.cpp b/src/collect.cpp\nindex 7a555f440..14d317b6d 100644\n--- a/src/collect.cpp\n+++ b/src/collect.cpp\n@@ -359,4 +359,4 @@ void Internal::garbage_collection () {\n   STOP (collect);\n }\n \n-};\n+}\ndiff --git a/src/compact.cpp b/src/compact.cpp\nindex 4354f2127..0accea07b 100644\n--- a/src/compact.cpp\n+++ b/src/compact.cpp\n@@ -363,4 +363,4 @@ void Internal::compact () {\n   PRINT (\"AFTER\");\n }\n \n-};\n+}\ndiff --git a/src/decide.cpp b/src/decide.cpp\nindex acd5ca995..f7e500874 100644\n--- a/src/decide.cpp\n+++ b/src/decide.cpp\n@@ -45,4 +45,4 @@ void Internal::decide () {\n   STOP (decide);\n }\n \n-};\n+}\ndiff --git a/src/duplicated.cpp b/src/duplicated.cpp\nindex 2ee1dc44d..affe2bd6b 100644\n--- a/src/duplicated.cpp\n+++ b/src/duplicated.cpp\n@@ -82,4 +82,4 @@ void Internal::mark_duplicated_binary_clauses_as_garbage () {\n   STOP (deduplicate);\n }\n \n-};\n+}\ndiff --git a/src/elim.cpp b/src/elim.cpp\nindex 20096b0b0..6a2237cfa 100644\n--- a/src/elim.cpp\n+++ b/src/elim.cpp\n@@ -672,4 +672,4 @@ void Internal::elim () {\n   lim.fixed_at_last_elim = stats.all.fixed;\n }\n \n-};\n+}\ndiff --git a/src/elim.hpp b/src/elim.hpp\nindex da3d6b276..639d9c489 100644\n--- a/src/elim.hpp\n+++ b/src/elim.hpp\n@@ -23,6 +23,6 @@ struct more_noccs2 {\n \n typedef heap<more_noccs2> ElimSchedule;\n \n-};\n+}\n \n #endif\ndiff --git a/src/ema.cpp b/src/ema.cpp\nindex d97a2d098..ec46e07b1 100644\n--- a/src/ema.cpp\n+++ b/src/ema.cpp\n@@ -37,4 +37,4 @@ void EMA::update (Internal * internal, double y, const char * name) {\n   LOG (\"new %s EMA wait = period = %ld, beta = %g\", name, wait, beta);\n }\n \n-};\n+}\ndiff --git a/src/ema.hpp b/src/ema.hpp\nindex f8b8e9910..983783202 100644\n--- a/src/ema.hpp\n+++ b/src/ema.hpp\n@@ -28,7 +28,7 @@ struct EMA {\n   void update (Internal *, double y, const char * name);\n };\n \n-};\n+}\n \n /*------------------------------------------------------------------------*/\n \ndiff --git a/src/extend.cpp b/src/extend.cpp\nindex 455b1700b..9784e25ad 100644\n--- a/src/extend.cpp\n+++ b/src/extend.cpp\n@@ -85,4 +85,4 @@ void External::extend () {\n   STOP (extend);\n }\n \n-};\n+}\ndiff --git a/src/external.cpp b/src/external.cpp\nindex f9fbf6965..4272d76a3 100644\n--- a/src/external.cpp\n+++ b/src/external.cpp\n@@ -70,4 +70,4 @@ int External::solve () {\n \n void External::terminate () { internal->terminate (); }\n \n-};\n+}\ndiff --git a/src/external.hpp b/src/external.hpp\nindex 65346d90f..3d58ed668 100644\n--- a/src/external.hpp\n+++ b/src/external.hpp\n@@ -135,6 +135,6 @@ class External {\n   void check (int (External::*assignment) (int) const);\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/file.cpp b/src/file.cpp\nindex e93d377d1..bbcd297c4 100644\n--- a/src/file.cpp\n+++ b/src/file.cpp\n@@ -10,7 +10,7 @@ extern \"C\" {\n #include <sys/types.h>\n #include <unistd.h>\n #include <stdlib.h>\n-};\n+}\n \n /*------------------------------------------------------------------------*/\n \n@@ -189,4 +189,4 @@ File::~File () {\n #endif\n }\n \n-};\n+}\ndiff --git a/src/file.hpp b/src/file.hpp\nindex b2194f364..8cc45bbf2 100644\n--- a/src/file.hpp\n+++ b/src/file.hpp\n@@ -130,6 +130,6 @@ class File {\n   long bytes () const { return _bytes; }\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/flags.hpp b/src/flags.hpp\nindex 7c4bc72d3..4e3a3d8db 100644\n--- a/src/flags.hpp\n+++ b/src/flags.hpp\n@@ -36,6 +36,6 @@ struct Flags {        // Variable flags.\n   bool substituted () const { return status == SUBSTITUTED; }\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/format.cpp b/src/format.cpp\nindex 7dcd3cfbb..d50f8b4df 100644\n--- a/src/format.cpp\n+++ b/src/format.cpp\n@@ -57,4 +57,4 @@ const char * Format::append (const char * fmt, ...) {\n   return res;\n }\n \n-};\n+}\ndiff --git a/src/format.hpp b/src/format.hpp\nindex eca4b0c49..8d91d3b3d 100644\n--- a/src/format.hpp\n+++ b/src/format.hpp\n@@ -25,6 +25,6 @@ class Format {\n   operator const char * () const { return count ? buffer : 0; }\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/heap.hpp b/src/heap.hpp\nindex d6d1cdf4a..01fbd44b1 100644\n--- a/src/heap.hpp\n+++ b/src/heap.hpp\n@@ -181,6 +181,6 @@ template<class C> class heap {\n   const_iterator end () const { return array.end (); }\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/internal.cpp b/src/internal.cpp\nindex 972cadac5..e221a624f 100644\n--- a/src/internal.cpp\n+++ b/src/internal.cpp\n@@ -307,4 +307,4 @@ void Internal::dump () {\n   fflush (stdout);\n }\n \n-};\n+}\ndiff --git a/src/internal.hpp b/src/internal.hpp\nindex 6829e99e2..5a769d695 100644\n--- a/src/internal.hpp\n+++ b/src/internal.hpp\n@@ -596,6 +596,6 @@ inline int Proof::externalize (int lit) {\n   return res;\n }\n \n-};\n+}\n \n #endif\ndiff --git a/src/level.hpp b/src/level.hpp\nindex 0cbc2aa15..532a78985 100644\n--- a/src/level.hpp\n+++ b/src/level.hpp\n@@ -20,6 +20,6 @@ struct Level {\n   Level () { }\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/limit.cpp b/src/limit.cpp\nindex 49ae7cf01..156e56d6b 100644\n--- a/src/limit.cpp\n+++ b/src/limit.cpp\n@@ -22,4 +22,4 @@ bool Internal::terminating () {\n \n Inc::Inc () { memset (this, 0, sizeof *this); }\n \n-};\n+}\ndiff --git a/src/limit.hpp b/src/limit.hpp\nindex 48bde7186..3b6b07e56 100644\n--- a/src/limit.hpp\n+++ b/src/limit.hpp\n@@ -57,6 +57,6 @@ struct Inc {\n   Inc ();\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/logging.cpp b/src/logging.cpp\nindex 5ca0382d9..884f7b745 100644\n--- a/src/logging.cpp\n+++ b/src/logging.cpp\n@@ -71,6 +71,6 @@ void Logger::log (Internal * internal,\n   fflush (stdout);\n }\n \n-};\n+}\n \n #endif\ndiff --git a/src/logging.hpp b/src/logging.hpp\nindex c0732cbdf..28da394f5 100644\n--- a/src/logging.hpp\n+++ b/src/logging.hpp\n@@ -37,7 +37,7 @@ static void log (Internal *, const vector<int> &, const char *fmt, ...);\n \n };\n \n-};\n+}\n \n /*------------------------------------------------------------------------*/\n \ndiff --git a/src/message.cpp b/src/message.cpp\nindex 2d492b34b..0f9077f73 100644\n--- a/src/message.cpp\n+++ b/src/message.cpp\n@@ -97,4 +97,4 @@ void Message::error (Internal * internal, const char *fmt, ...) {\n   va_end (ap);                          // unreachable\n }\n \n-};\n+}\ndiff --git a/src/message.hpp b/src/message.hpp\nindex 98018d119..8dfc4f7a5 100644\n--- a/src/message.hpp\n+++ b/src/message.hpp\n@@ -49,7 +49,7 @@ struct Message {\n   static void error (Internal *, const char *, ...);\n };\n \n-};\n+}\n \n /*------------------------------------------------------------------------*/\n \ndiff --git a/src/minimize.cpp b/src/minimize.cpp\nindex 4e3f8b02e..0e68e37d3 100644\n--- a/src/minimize.cpp\n+++ b/src/minimize.cpp\n@@ -79,4 +79,4 @@ void Internal::clear_minimized () {\n   minimized.clear ();\n }\n \n-};\n+}\ndiff --git a/src/occs.cpp b/src/occs.cpp\nindex 82ad4bae3..c5ba5bdb0 100644\n--- a/src/occs.cpp\n+++ b/src/occs.cpp\n@@ -47,4 +47,4 @@ void Internal::reset_noccs2 () {\n   ntab2 = 0;\n }\n \n-};\n+}\ndiff --git a/src/occs.hpp b/src/occs.hpp\nindex b456f1178..32445eec7 100644\n--- a/src/occs.hpp\n+++ b/src/occs.hpp\n@@ -20,6 +20,6 @@ inline void erase_occs (Occs & os) { erase_vector (os); }\n typedef Occs::iterator occs_iterator;\n typedef Occs::const_iterator const_occs_iterator;\n \n-};\n+}\n \n #endif\ndiff --git a/src/options.cpp b/src/options.cpp\nindex 501978d3e..eeb08592e 100644\n--- a/src/options.cpp\n+++ b/src/options.cpp\n@@ -149,4 +149,4 @@ void Options::usage () {\n \n /*------------------------------------------------------------------------*/\n \n-};\n+}\ndiff --git a/src/options.hpp b/src/options.hpp\nindex f198bfa23..055a12ff6 100644\n--- a/src/options.hpp\n+++ b/src/options.hpp\n@@ -183,6 +183,6 @@ class Options {\n   static void usage ();      // print usage message for all options\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/packtrack.cpp b/src/packtrack.cpp\nindex 3cede3483..b45eb0a7f 100644\n--- a/src/packtrack.cpp\n+++ b/src/packtrack.cpp\n@@ -29,4 +29,4 @@ void Internal::packtrack (int probe) {\n   level = 0;\n }\n \n-};\n+}\ndiff --git a/src/parse.cpp b/src/parse.cpp\nindex a861daf7f..a7a417b4e 100644\n--- a/src/parse.cpp\n+++ b/src/parse.cpp\n@@ -186,4 +186,4 @@ const char * Parser::parse_solution () {\n   return err;\n }\n \n-};\n+}\ndiff --git a/src/parse.hpp b/src/parse.hpp\nindex 437e4b38a..df07357fd 100644\n--- a/src/parse.hpp\n+++ b/src/parse.hpp\n@@ -46,6 +46,6 @@ class Parser {\n   const char * parse_solution ();\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/probagate.cpp b/src/probagate.cpp\nindex 5bb47e1e2..98c37d8b0 100644\n--- a/src/probagate.cpp\n+++ b/src/probagate.cpp\n@@ -279,4 +279,4 @@ bool Internal::probagate () {\n   return !conflict;\n }\n \n-};\n+}\ndiff --git a/src/probe.cpp b/src/probe.cpp\nindex 4f86b9ba6..8c6262c2d 100644\n--- a/src/probe.cpp\n+++ b/src/probe.cpp\n@@ -241,4 +241,4 @@ void CaDiCaL::Internal::probe () {\n   STOP_AND_SWITCH (probe, simplify, search);\n }\n \n-};\n+}\ndiff --git a/src/profile.cpp b/src/profile.cpp\nindex 5ed22afb6..7bfca82c7 100644\n--- a/src/profile.cpp\n+++ b/src/profile.cpp\n@@ -63,6 +63,6 @@ void Internal::print_profile (double now) {\n   MSG (\"%12.2f %7.2f%% all\", now, 100.0);\n }\n \n-};\n+}\n \n #endif // ifndef QUIET\ndiff --git a/src/profile.hpp b/src/profile.hpp\nindex 8d5758120..100c3c5fe 100644\n--- a/src/profile.hpp\n+++ b/src/profile.hpp\n@@ -96,7 +96,7 @@ struct Profiles {\n   Profiles (Internal *);\n };\n \n-};\n+}\n \n /*------------------------------------------------------------------------*/\n \n@@ -104,17 +104,11 @@ struct Profiles {\n \n #ifndef QUIET //...........................................................\n \n-#define START(P,ARGS...) \\\n-do { \\\n-  if (internal->profiles.P.level > internal->opts.profile) break; \\\n-  internal->start_profiling (&internal->profiles.P, ##ARGS); \\\n-} while (0)\n+#define START(...) \\\n+do { } while (0)\n \n-#define STOP(P,ARGS...) \\\n-do { \\\n-  if (internal->profiles.P.level > internal->opts.profile) break; \\\n-  internal->stop_profiling (&internal->profiles.P, ##ARGS); \\\n-} while (0)\n+#define STOP(...) \\\n+do { } while (0)\n \n #define SWITCH_AND_START(F,T,P) \\\n do { \\\n@@ -136,11 +130,11 @@ do { \\\n \n #else // ifndef QUIET //...................................................\n \n-#define START(ARGS...) do { } while (0)\n-#define STOP(ARGS...) do { } while (0)\n+#define START(...) do { } while (0)\n+#define STOP(...) do { } while (0)\n \n-#define SWITCH_AND_START(ARGS...) do { } while (0)\n-#define STOP_AND_SWITCH(ARGS...) do { } while (0)\n+#define SWITCH_AND_START(...) do { } while (0)\n+#define STOP_AND_SWITCH(...) do { } while (0)\n \n #endif\n /*------------------------------------------------------------------------*/\ndiff --git a/src/proof.cpp b/src/proof.cpp\nindex 4d16d3a30..237451665 100644\n--- a/src/proof.cpp\n+++ b/src/proof.cpp\n@@ -156,4 +156,4 @@ void Proof::trace_strengthen_clause (Clause * c, int remove) {\n   trace_clause (c, false);\n }\n \n-};\n+}\ndiff --git a/src/proof.hpp b/src/proof.hpp\nindex bff5c709a..24132f942 100644\n--- a/src/proof.hpp\n+++ b/src/proof.hpp\n@@ -38,6 +38,6 @@ class Proof {\n   void trace_strengthen_clause (Clause *, int);\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/propagate.cpp b/src/propagate.cpp\nindex 2fd743466..9cd5d48d9 100644\n--- a/src/propagate.cpp\n+++ b/src/propagate.cpp\n@@ -278,4 +278,4 @@ bool Internal::propagate () {\n   return !conflict;\n }\n \n-};\n+}\ndiff --git a/src/queue.hpp b/src/queue.hpp\nindex 46378dc90..87e033e8d 100644\n--- a/src/queue.hpp\n+++ b/src/queue.hpp\n@@ -44,6 +44,6 @@ struct Queue {\n   }\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/reduce.cpp b/src/reduce.cpp\nindex 19317884c..78463c65c 100644\n--- a/src/reduce.cpp\n+++ b/src/reduce.cpp\n@@ -147,4 +147,4 @@ void Internal::reduce () {\n   STOP (reduce);\n }\n \n-};\n+}\ndiff --git a/src/rephase.cpp b/src/rephase.cpp\nindex 135274e14..246bedda1 100644\n--- a/src/rephase.cpp\n+++ b/src/rephase.cpp\n@@ -20,4 +20,4 @@ void Internal::rephase () {\n   report ('~');\n }\n \n-};\n+}\ndiff --git a/src/report.cpp b/src/report.cpp\nindex 52adc1078..34912492a 100644\n--- a/src/report.cpp\n+++ b/src/report.cpp\n@@ -133,5 +133,5 @@ void Internal::report (char type, int verbose) { }\n \n #endif\n \n-};\n \n+}\ndiff --git a/src/resources.cpp b/src/resources.cpp\nindex 6b020193b..d0861c580 100644\n--- a/src/resources.cpp\n+++ b/src/resources.cpp\n@@ -13,7 +13,7 @@ extern \"C\" {\n #include <sys/types.h>\n #include <unistd.h>\n #include <string.h>\n-};\n+}\n \n namespace CaDiCaL {\n \n@@ -58,6 +58,6 @@ size_t current_resident_set_size () {\n   return scanned == 2 ? rss * sysconf (_SC_PAGESIZE) : 0;\n }\n \n-};\n+}\n \n #endif // ifndef QUIET\ndiff --git a/src/resources.hpp b/src/resources.hpp\nindex 382c95a77..381b4b255 100644\n--- a/src/resources.hpp\n+++ b/src/resources.hpp\n@@ -10,7 +10,7 @@ double process_time ();\n size_t maximum_resident_set_size ();\n size_t current_resident_set_size ();\n \n-};\n+}\n \n #endif // ifndef _resources_hpp_INCLUDED\n #endif // ifndef QUIET\ndiff --git a/src/restart.cpp b/src/restart.cpp\nindex 2b796ddcd..ea0928321 100644\n--- a/src/restart.cpp\n+++ b/src/restart.cpp\n@@ -45,5 +45,4 @@ void Internal::restart () {\n   STOP (restart);\n }\n \n-};\n-\n+}\ndiff --git a/src/signal.cpp b/src/signal.cpp\nindex a38e57777..d4c681049 100644\n--- a/src/signal.cpp\n+++ b/src/signal.cpp\n@@ -12,7 +12,7 @@ int CaDiCaL::Solver::contract_violation_signal = SIGUSR1;\n \n extern \"C\" {\n #include <unistd.h>\n-};\n+}\n \n /*------------------------------------------------------------------------*/\n \n@@ -95,4 +95,4 @@ void Signal::alarm (int seconds) {\n   ::alarm (seconds);\n }\n \n-};\n+}\ndiff --git a/src/signal.hpp b/src/signal.hpp\nindex b652ee0b4..4631c813e 100644\n--- a/src/signal.hpp\n+++ b/src/signal.hpp\n@@ -23,6 +23,6 @@ class Signal {\n   static void alarm (int seconds);\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/solution.cpp b/src/solution.cpp\nindex d9298d5ac..dfc904db7 100644\n--- a/src/solution.cpp\n+++ b/src/solution.cpp\n@@ -46,4 +46,4 @@ void External::check_solution_on_shrunken_clause (Clause * c) {\n   abort ();\n }\n \n-};\n+}\ndiff --git a/src/stats.cpp b/src/stats.cpp\nindex ee96a73a1..a1a730edf 100644\n--- a/src/stats.cpp\n+++ b/src/stats.cpp\n@@ -119,4 +119,4 @@ void Stats::print (Internal * internal) {\n \n }\n \n-};\n+}\ndiff --git a/src/stats.hpp b/src/stats.hpp\nindex 2531764ed..9e27eb4d5 100644\n--- a/src/stats.hpp\n+++ b/src/stats.hpp\n@@ -106,6 +106,6 @@ do { \\\n \n /*------------------------------------------------------------------------*/\n \n-};\n+}\n \n #endif\ndiff --git a/src/subsume.cpp b/src/subsume.cpp\nindex db78fe918..f3bcf9286 100644\n--- a/src/subsume.cpp\n+++ b/src/subsume.cpp\n@@ -498,4 +498,4 @@ void Internal::subsume () {\n   lim.subsume = stats.conflicts + inc.subsume;\n }\n \n-};\n+}\ndiff --git a/src/transred.cpp b/src/transred.cpp\nindex c9cad63f7..e3fd47a3b 100644\n--- a/src/transred.cpp\n+++ b/src/transred.cpp\n@@ -177,4 +177,4 @@ void Internal::transred () {\n   STOP_AND_SWITCH (transred, simplify, search);\n }\n \n-};\n+}\ndiff --git a/src/util.cpp b/src/util.cpp\nindex 04a0feb53..d10f0f3f5 100644\n--- a/src/util.cpp\n+++ b/src/util.cpp\n@@ -31,4 +31,4 @@ bool has_suffix (const char * str, const char * suffix) {\n   return k > l && !strcmp (str + k - l, suffix);\n }\n \n-};\n+}\ndiff --git a/src/util.hpp b/src/util.hpp\nindex f5710c1eb..706199d59 100644\n--- a/src/util.hpp\n+++ b/src/util.hpp\n@@ -70,6 +70,6 @@ template<class T> void shrink_vector (vector<T> & v) {\n \n /*------------------------------------------------------------------------*/\n \n-};\n+}\n \n #endif\ndiff --git a/src/var.cpp b/src/var.cpp\nindex e4e643e35..f17c0b0a2 100644\n--- a/src/var.cpp\n+++ b/src/var.cpp\n@@ -30,4 +30,4 @@ void Internal::check_var_stats () {\n #endif\n }\n \n-};\n+}\ndiff --git a/src/var.hpp b/src/var.hpp\nindex 739a72813..fcd61c3ba 100644\n--- a/src/var.hpp\n+++ b/src/var.hpp\n@@ -23,6 +23,6 @@ struct Var {\n   };\n };\n \n-};\n+}\n \n #endif\ndiff --git a/src/vivify.cpp b/src/vivify.cpp\nindex e4a01156d..b9be2ced3 100644\n--- a/src/vivify.cpp\n+++ b/src/vivify.cpp\n@@ -544,4 +544,4 @@ void Internal::vivify () {\n   STOP_AND_SWITCH (vivify, simplify, search);\n }\n \n-};\n+}\ndiff --git a/src/watch.cpp b/src/watch.cpp\nindex 33135ca37..788793478 100644\n--- a/src/watch.cpp\n+++ b/src/watch.cpp\n@@ -79,4 +79,4 @@ void Internal::disconnect_watches () {\n       watches (sign * idx).clear ();\n }\n \n-};\n+}\ndiff --git a/src/watch.hpp b/src/watch.hpp\nindex c020baa0a..90c68144d 100644\n--- a/src/watch.hpp\n+++ b/src/watch.hpp\n@@ -39,6 +39,6 @@ inline void shrink_watches (Watches & ws) { shrink_vector (ws); }\n typedef Watches::iterator watch_iterator;\n typedef Watches::const_iterator const_watch_iterator;\n \n-};\n+}\n \n #endif\n\"\"\""
  },
  {
    "pr_number": 3,
    "title": "Allow user specific CXXFLAGS.",
    "author": "mpreiner",
    "head_sha": "86e964bcf5405f9c9ff2bc582ed93a2ae2a9140b",
    "base_sha": "d971f9a48ae06dde1b8e1445755fa9a6167641fe",
    "head_ref": "allow-user-cxxflags",
    "base_ref": "master",
    "merge_commit_sha": "345da079697dc117ce5db0fc4e9eac9733aa9590",
    "state": "closed",
    "created_at": "2018-03-09T00:26:07Z",
    "updated_at": "2018-03-10T14:09:30Z",
    "merged_at": null,
    "pr_body": "Only append to CXXFLAGS in configure script in order to allow user specific CXXFLAGS,\r\ne.g., CXXFLAGS=\"-fPIC\" ./configure",
    "diff": "\"\"\"diff --git a/configure b/configure\nindex 357bfbfe6..bbf93b96f 100755\n--- a/configure\n+++ b/configure\n@@ -126,8 +126,8 @@ fi\n if [ x\"$CXXFLAGS\" ]\n then\n   case x\"$CXX\" in\n-    xg++*|xclang++*) CXXFLAGS=\"-Wall\";;\n-    *) CXXFLAGS=\"-W\";;\n+    xg++*|xclang++*) CXXFLAGS=\"$CXXFLAGS -Wall\";;\n+    *) CXXFLAGS=\"$CXXFLAGS -W\";;\n   esac\n   if [ $debug = yes ]\n   then\n\"\"\""
  },
  {
    "pr_number": 1,
    "title": "Add CMake files for building and testing.",
    "author": "PetterS",
    "head_sha": "8266927433d1df6c61207de15a52bad903bd19c8",
    "base_sha": "d971f9a48ae06dde1b8e1445755fa9a6167641fe",
    "head_ref": "cmake",
    "base_ref": "master",
    "merge_commit_sha": "25aa2204c1e76930f4f6fa70e27501cde941503f",
    "state": "closed",
    "created_at": "2018-01-19T09:47:03Z",
    "updated_at": "2018-03-10T14:10:34Z",
    "merged_at": null,
    "pr_body": "This allows building with e.g. Visual Studio.\r\n\r\nAll unit tests and regression tests will be run with\r\n\r\n    ctest .\r\n\r\nafter building.\r\n\r\nNot all parameters will be present in config.hpp yet.",
    "diff": "\"\"\"diff --git a/CMakeLists.txt b/CMakeLists.txt\nnew file mode 100644\nindex 000000000..f3b1defe0\n--- /dev/null\n+++ b/CMakeLists.txt\n@@ -0,0 +1,13 @@\n+cmake_minimum_required(VERSION 3.0)\n+project(Cadical C CXX)\n+\n+enable_testing()\n+\n+set(VERSION \"0.0\")\n+configure_file(${CMAKE_CURRENT_SOURCE_DIR}/config.hpp.in ${CMAKE_CURRENT_BINARY_DIR}/config.hpp)\n+include_directories(${CMAKE_CURRENT_BINARY_DIR})\n+\n+include_directories(${CMAKE_CURRENT_SOURCE_DIR}/src)\n+\n+add_subdirectory(src)\n+add_subdirectory(test)\ndiff --git a/config.hpp.in b/config.hpp.in\nnew file mode 100644\nindex 000000000..c3a0ca1eb\n--- /dev/null\n+++ b/config.hpp.in\n@@ -0,0 +1,20 @@\n+// The current version number.\n+#define CADICAL_VERSION \"${VERSION}\"\n+\n+// The unique GIT hash.\n+#define CADICAL_GITID \"unknown\"\n+\n+// The C++ compiler as used in the current 'makefile'.\n+#define CADICAL_CXX \"${CMAKE_CXX_COMPILER_ID}\"\n+\n+// Compile flags as used in the current 'makefile'.\n+#define CADICAL_CXXFLAGS \"${CMAKE_CXX_FLAGS}\"\n+\n+// The version of the compiler (currently works only for 'g++' and 'clang++')\n+#define CADICAL_CXXVERSION \"unknown\"\n+\n+// The time and date we compiled the CaDiCaL library.\n+#define CADICAL_COMPILED __DATE__ __TIME__\n+\n+// The operating system on which this compilation took place.\n+#define CADICAL_OS \"unknown\"\ndiff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\nnew file mode 100644\nindex 000000000..82f0a3f38\n--- /dev/null\n+++ b/src/CMakeLists.txt\n@@ -0,0 +1,8 @@\n+\n+file(GLOB cadical_source_files \"*.hpp\" \"*.cpp\")\n+list(REMOVE_ITEM cadical_source_files \"app.cpp\")\n+list(REMOVE_ITEM cadical_source_files \"main.cpp\")\n+\n+add_library(cadical_lib ${cadical_source_files})\n+add_executable(cadical app.cpp main.cpp)\n+target_link_libraries(cadical cadical_lib)\ndiff --git a/test/CMakeLists.txt b/test/CMakeLists.txt\nnew file mode 100644\nindex 000000000..2c47fb8f0\n--- /dev/null\n+++ b/test/CMakeLists.txt\n@@ -0,0 +1,112 @@\n+\n+add_executable(ctest api/ctest.c)\n+target_link_libraries(ctest cadical_lib)\n+add_test(NAME ctest COMMAND ctest)\n+\n+add_executable(morenmore api/morenmore.cpp)\n+target_link_libraries(morenmore cadical_lib)\n+add_test(NAME morenmore COMMAND morenmore)\n+\n+add_executable(newdelete api/newdelete.cpp)\n+target_link_libraries(newdelete cadical_lib)\n+add_test(NAME newdelete COMMAND newdelete)\n+\n+add_executable(unit api/unit.cpp)\n+target_link_libraries(unit cadical_lib)\n+add_test(NAME unit COMMAND unit)\n+\n+function (cnf_test FILE CODE)\n+\tadd_test(NAME ${FILE} COMMAND cadical ${CMAKE_CURRENT_SOURCE_DIR}/cnfs/${FILE}.cnf)\n+\tSET_TESTS_PROPERTIES(${FILE} PROPERTIES PASS_REGULAR_EXPRESSION \"c exit ${CODE}\")\n+endfunction()\n+\n+cnf_test(unit0 10)\n+cnf_test(unit1 10)\n+cnf_test(unit2 10)\n+cnf_test(unit3 10)\n+cnf_test(unit4 20)\n+cnf_test(unit5 20)\n+cnf_test(unit6 20)\n+cnf_test(unit7 20)\n+\n+cnf_test(sub0 10)\n+\n+cnf_test(sat0 20)\n+cnf_test(sat1 10)\n+cnf_test(sat2 10)\n+cnf_test(sat3 10)\n+cnf_test(sat4 10)\n+cnf_test(sat5 20)\n+cnf_test(sat6 10)\n+cnf_test(sat7 10)\n+cnf_test(sat8 10)\n+cnf_test(sat9 10)\n+cnf_test(sat10 10)\n+cnf_test(sat11 10)\n+cnf_test(sat12 10)\n+cnf_test(sat13 10)\n+\n+cnf_test(full1 20)\n+cnf_test(full2 20)\n+cnf_test(full3 20)\n+cnf_test(full4 20)\n+cnf_test(full5 20)\n+cnf_test(full6 20)\n+cnf_test(full7 20)\n+\n+cnf_test(regr000 10)\n+cnf_test(elimclash 20)\n+cnf_test(elimredundant 10)\n+\n+cnf_test(block0 10)\n+\n+cnf_test(prime4 10)\n+cnf_test(prime9 10)\n+cnf_test(prime25 10)\n+cnf_test(prime49 10)\n+cnf_test(prime121 10)\n+cnf_test(prime169 10)\n+cnf_test(prime361 10)\n+cnf_test(prime289 10)\n+cnf_test(prime529 10)\n+cnf_test(prime841 10)\n+cnf_test(prime961 10)\n+cnf_test(prime1369 10)\n+cnf_test(prime1681 10)\n+cnf_test(prime1849 10)\n+cnf_test(prime2209 10)\n+\n+cnf_test(sqrt2809 10)\n+cnf_test(sqrt3481 10)\n+cnf_test(sqrt3721 10)\n+cnf_test(sqrt4489 10)\n+cnf_test(sqrt5041 10)\n+cnf_test(sqrt5329 10)\n+cnf_test(sqrt6241 10)\n+cnf_test(sqrt6889 10)\n+cnf_test(sqrt7921 10)\n+cnf_test(sqrt9409 10)\n+cnf_test(sqrt10201 10)\n+cnf_test(sqrt10609 10)\n+cnf_test(sqrt11449 10)\n+cnf_test(sqrt11881 10)\n+cnf_test(sqrt12769 10)\n+cnf_test(sqrt16129 10)\n+cnf_test(sqrt63001 10)\n+cnf_test(sqrt259081 10)\n+cnf_test(sqrt1042441 10)\n+\n+cnf_test(ph2 20)\n+cnf_test(ph3 20)\n+cnf_test(ph4 20)\n+cnf_test(ph5 20)\n+cnf_test(ph6 20)\n+\n+cnf_test(add4 20)\n+cnf_test(add8 20)\n+cnf_test(add16 20)\n+cnf_test(add32 20)\n+cnf_test(add64 20)\n+cnf_test(add128 20)\n+\n+cnf_test(prime65537 20)\n\"\"\""
  }
]